// Copyright (c) 2012 GREE, Inc - http://git.io/uvS3hQ
// Copyright (c) 2010-2012 Tween.js authors - http://git.io/tiDrNw
// Copyright (c) 2001 Robert Penner - http://goo.gl/Qjqc0
// Copyright (c) 2012 imaya - http://git.io/SKEzIQ http://git.io/cC8gDw
if (typeof global === "undefined" && typeof window !== "undefined") {
	/* Browsers */
	global = window;
} else if (typeof window === "undefined" && typeof self !== "undefined") {
	/* Workers */
	global = self;
}
// Generated by CoffeeScript 1.4.0
(function() { var __FILE__ = 'lwf.js';
  var Align, AlphaTransform, Animation, Bitmap, BitmapEx, Button, ButtonEventHandlers, CanvasBitmapContext, CanvasBitmapRenderer, CanvasRendererFactory, CanvasResourceCache, CanvasTextContext, CanvasTextRenderer, ClipEvent, Color, ColorTransform, Condition, Constant, ControlType, Data, EventHandlers, Format, GObjType, Graphic, IObject, LObject, LWF, LWFContainer, LWFLoader, LWFLoaderWithArray, LWFLoaderWithArrayBuffer, Loader, Matrix, Movie, MovieEventHandlers, NullRendererFactory, Particle, Point, ProgramObject, Property, Text, Translate, Type, Utility, WebkitCSSBitmapContext, WebkitCSSBitmapRenderer, WebkitCSSDomElementRenderer, WebkitCSSRendererFactory, WebkitCSSResourceCache, WebkitCSSTextContext, WebkitCSSTextRenderer, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Point = (function() {

    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    return Point;

  })();

  Translate = (function() {

    function Translate(translateX, translateY) {
      this.translateX = translateX != null ? translateX : 0;
      this.translateY = translateY != null ? translateY : 0;
    }

    return Translate;

  })();

  Matrix = (function() {

    function Matrix(scaleX, scaleY, skew0, skew1, translateX, translateY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.skew0 = skew0;
      this.skew1 = skew1;
      this.translateX = translateX;
      this.translateY = translateY;
      if (this.scaleX == null) {
        this.clear();
      }
    }

    Matrix.prototype.clear = function() {
      this.scaleX = 1;
      this.scaleY = 1;
      this.skew0 = 0;
      this.skew1 = 0;
      this.translateX = 0;
      this.translateY = 0;
    };

    Matrix.prototype.set = function(m) {
      this.scaleX = m.scaleX;
      this.scaleY = m.scaleY;
      this.skew0 = m.skew0;
      this.skew1 = m.skew1;
      this.translateX = m.translateX;
      this.translateY = m.translateY;
      return this;
    };

    Matrix.prototype.setWithComparing = function(m) {
      var changed, scaleX, scaleY, skew0, skew1, translateX, translateY;
      if (m === null) {
        return false;
      }
      scaleX = m.scaleX;
      scaleY = m.scaleY;
      skew0 = m.skew0;
      skew1 = m.skew1;
      translateX = m.translateX;
      translateY = m.translateY;
      changed = false;
      if (this.scaleX !== scaleX) {
        this.scaleX = scaleX;
        changed = true;
      }
      if (this.scaleY !== scaleY) {
        this.scaleY = scaleY;
        changed = true;
      }
      if (this.skew0 !== skew0) {
        this.skew0 = skew0;
        changed = true;
      }
      if (this.skew1 !== skew1) {
        this.skew1 = skew1;
        changed = true;
      }
      if (this.translateX !== translateX) {
        this.translateX = translateX;
        changed = true;
      }
      if (this.translateY !== translateY) {
        this.translateY = translateY;
        changed = true;
      }
      return changed;
    };

    return Matrix;

  })();

  Color = (function() {

    function Color(red, green, blue, alpha) {
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = alpha;
      if (this.red == null) {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;
      }
    }

    Color.prototype.set = function(r, g, b, a) {
      var c;
      if (typeof r === "object") {
        c = r;
        this.red = c.red;
        this.green = c.green;
        this.blue = c.blue;
        this.alpha = c.alpha;
      } else {
        this.red = r;
        this.green = g;
        this.blue = b;
        this.alpha = a;
      }
    };

    return Color;

  })();

  AlphaTransform = (function() {

    function AlphaTransform(alpha) {
      this.alpha = alpha;
    }

    return AlphaTransform;

  })();

  ColorTransform = (function() {

    function ColorTransform(mr, mg, mb, ma, ar, ag, ab, aa) {
      this.multi = new Color(mr, mg, mb, ma);
      if (mr == null) {
        this.clear();
      }
    }

    ColorTransform.prototype.clear = function() {
      this.multi.set(1, 1, 1, 1);
    };

    ColorTransform.prototype.set = function(c) {
      this.multi.set(c.multi);
      return this;
    };

    ColorTransform.prototype.setWithComparing = function(c) {
      var alpha, blue, changed, cm, green, m, red;
      if (c === null) {
        return false;
      }
      cm = c.multi;
      red = cm.red;
      green = cm.green;
      blue = cm.blue;
      alpha = cm.alpha;
      changed = false;
      m = this.multi;
      if (m.red !== red) {
        m.red = red;
        changed = true;
      }
      if (m.green !== green) {
        m.green = green;
        changed = true;
      }
      if (m.blue !== blue) {
        m.blue = blue;
        changed = true;
      }
      if (m.alpha !== alpha) {
        m.alpha = alpha;
        changed = true;
      }
      return changed;
    };

    return ColorTransform;

  })();

  Format = (function() {

    function Format() {}

    Format.Constant = (function() {

      function Constant() {}

      Constant.HEADER_SIZE = 324;

      Constant.FORMAT_VERSION_0 = 0x12;

      Constant.FORMAT_VERSION_1 = 0x10;

      Constant.FORMAT_VERSION_2 = 0x10;

      Constant.FORMAT_TYPE = 0;

      Constant.OPTION_USE_SCRIPT = 1 << 0;

      Constant.OPTION_USE_TEXTUREATLAS = 1 << 1;

      Constant.MATRIX_FLAG = 1 << 31;

      Constant.COLORTRANSFORM_FLAG = 1 << 31;

      Constant.TEXTUREFORMAT_NORMAL = 0;

      Constant.TEXTUREFORMAT_PREMULTIPLIEDALPHA = 1;

      return Constant;

    })();

    Format.StringBase = (function() {

      function StringBase(stringId) {
        this.stringId = stringId;
      }

      return StringBase;

    })();

    Format.Texture = (function() {

      function Texture(stringId, format, width, height, scale) {
        this.stringId = stringId;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      Texture.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return Texture;

    })();

    Format.TextureReplacement = (function() {

      function TextureReplacement(filename, format, width, height, scale) {
        this.filename = filename;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      return TextureReplacement;

    })();

    Format.TextureFragment = (function() {

      function TextureFragment(stringId, textureId, rotated, x, y, u, v, w, h) {
        this.stringId = stringId;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      TextureFragment.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return TextureFragment;

    })();

    Format.TextureFragmentReplacement = (function() {

      function TextureFragmentReplacement(filename, textureId, rotated, x, y, u, v, w, h) {
        this.filename = filename;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      return TextureFragmentReplacement;

    })();

    Format.Bitmap = (function() {

      function Bitmap(matrixId, textureFragmentId) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
      }

      return Bitmap;

    })();

    Format.BitmapEx = (function() {

      BitmapEx.Attribute = (function() {

        function Attribute() {}

        Attribute.REPEAT_S = 1 << 0;

        Attribute.REPEAT_T = 1 << 1;

        return Attribute;

      })();

      function BitmapEx(matrixId, textureFragmentId, attribute, u, v, w, h) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
        this.attribute = attribute;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      return BitmapEx;

    }).call(this);

    Format.Font = (function() {

      function Font(stringId, letterspacing) {
        this.stringId = stringId;
        this.letterspacing = letterspacing;
      }

      return Font;

    })();

    Format.TextProperty = (function() {

      TextProperty.Align = (function() {

        function Align() {}

        Align.LEFT = 0;

        Align.RIGHT = 1;

        Align.CENTER = 2;

        Align.ALIGN_MASK = 0x3;

        Align.VERTICAL_BOTTOM = 1 << 2;

        Align.VERTICAL_MIDDLE = 2 << 2;

        Align.VERTICAL_MASK = 0xc;

        return Align;

      })();

      function TextProperty(maxLength, fontId, fontHeight, align, leftMargin, rightMargin, indent, leading, strokeColorId, strokeWidth, shadowColorId, shadowOffsetX, shadowOffsetY, shadowBlur) {
        this.maxLength = maxLength;
        this.fontId = fontId;
        this.fontHeight = fontHeight;
        this.align = align;
        this.leftMargin = leftMargin;
        this.rightMargin = rightMargin;
        this.indent = indent;
        this.leading = leading;
        this.strokeColorId = strokeColorId;
        this.strokeWidth = strokeWidth;
        this.shadowColorId = shadowColorId;
        this.shadowOffsetX = shadowOffsetX;
        this.shadowOffsetY = shadowOffsetY;
        this.shadowBlur = shadowBlur;
      }

      return TextProperty;

    }).call(this);

    Format.Text = (function() {

      function Text(matrixId, nameStringId, textPropertyId, stringId, colorId, width, height) {
        this.matrixId = matrixId;
        this.nameStringId = nameStringId;
        this.textPropertyId = textPropertyId;
        this.stringId = stringId;
        this.colorId = colorId;
        this.width = width;
        this.height = height;
      }

      return Text;

    })();

    Format.ParticleData = (function() {

      function ParticleData(stringId) {
        this.stringId = stringId;
      }

      return ParticleData;

    })();

    Format.Particle = (function() {

      function Particle(matrixId, colorTransformId, particleDataId) {
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.particleDataId = particleDataId;
      }

      return Particle;

    })();

    Format.ProgramObject = (function(_super) {

      __extends(ProgramObject, _super);

      function ProgramObject(stringId, width, height, matrixId, colorTransformId) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        ProgramObject.__super__.constructor.call(this, stringId);
      }

      return ProgramObject;

    })(Format.StringBase);

    Format.GraphicObject = (function() {

      GraphicObject.Type = (function() {

        function Type() {}

        Type.BITMAP = 0;

        Type.BITMAPEX = 1;

        Type.TEXT = 2;

        Type.GRAPHIC_OBJECT_MAX = 3;

        return Type;

      })();

      function GraphicObject(graphicObjectType, graphicObjectId) {
        this.graphicObjectType = graphicObjectType;
        this.graphicObjectId = graphicObjectId;
      }

      return GraphicObject;

    }).call(this);

    Format.Graphic = (function() {

      function Graphic(graphicObjectId, graphicObjects) {
        this.graphicObjectId = graphicObjectId;
        this.graphicObjects = graphicObjects;
      }

      return Graphic;

    })();

    Format.LObject = (function() {

      LObject.Type = (function() {

        function Type() {}

        Type.BUTTON = 0;

        Type.GRAPHIC = 1;

        Type.MOVIE = 2;

        Type.BITMAP = 3;

        Type.BITMAPEX = 4;

        Type.TEXT = 5;

        Type.PARTICLE = 6;

        Type.PROGRAMOBJECT = 7;

        Type.ATTACHEDMOVIE = 8;

        Type.OBJECT_MAX = 9;

        return Type;

      })();

      function LObject(objectType, objectId) {
        this.objectType = objectType;
        this.objectId = objectId;
      }

      return LObject;

    }).call(this);

    Format.Animation = (function() {

      function Animation(animationOffset, animationLength) {
        this.animationOffset = animationOffset;
        this.animationLength = animationLength;
      }

      return Animation;

    })();

    Format.ButtonCondition = (function() {

      ButtonCondition.Condition = (function() {

        function Condition() {}

        Condition.ROLLOVER = 1 << 0;

        Condition.ROLLOUT = 1 << 1;

        Condition.PRESS = 1 << 2;

        Condition.RELEASE = 1 << 3;

        Condition.DRAGOUT = 1 << 4;

        Condition.DRAGOVER = 1 << 5;

        Condition.RELEASEOUTSIDE = 1 << 6;

        Condition.KEYPRESS = 1 << 7;

        return Condition;

      })();

      function ButtonCondition(condition, keyCode, animationId) {
        this.condition = condition;
        this.keyCode = keyCode;
        this.animationId = animationId;
      }

      return ButtonCondition;

    }).call(this);

    Format.Button = (function() {

      function Button(width, height, matrixId, colorTransformId, conditionId, conditions) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.conditionId = conditionId;
        this.conditions = conditions;
      }

      return Button;

    })();

    Format.Label = (function(_super) {

      __extends(Label, _super);

      function Label(stringId, frameNo) {
        this.frameNo = frameNo;
        Label.__super__.constructor.call(this, stringId);
      }

      return Label;

    })(Format.StringBase);

    Format.InstanceName = (function(_super) {

      __extends(InstanceName, _super);

      function InstanceName(stringId) {
        InstanceName.__super__.constructor.apply(this, arguments);
      }

      return InstanceName;

    })(Format.StringBase);

    Format.Event = (function(_super) {

      __extends(Event, _super);

      function Event(stringId) {
        Event.__super__.constructor.apply(this, arguments);
      }

      return Event;

    })(Format.StringBase);

    Format.String = (function() {

      function String(stringOffset, stringLength) {
        this.stringOffset = stringOffset;
        this.stringLength = stringLength;
      }

      return String;

    })();

    Format.Place = (function() {

      function Place(depth, objectId, instanceId, matrixId) {
        this.depth = depth;
        this.objectId = objectId;
        this.instanceId = instanceId;
        this.matrixId = matrixId;
      }

      return Place;

    })();

    Format.ControlMoveM = (function() {

      function ControlMoveM(placeId, matrixId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
      }

      return ControlMoveM;

    })();

    Format.ControlMoveC = (function() {

      function ControlMoveC(placeId, colorTransformId) {
        this.placeId = placeId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveC;

    })();

    Format.ControlMoveMC = (function() {

      function ControlMoveMC(placeId, matrixId, colorTransformId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveMC;

    })();

    Format.Control = (function() {

      Control.Type = (function() {

        function Type() {}

        Type.MOVE = 0;

        Type.MOVEM = 1;

        Type.MOVEC = 2;

        Type.MOVEMC = 3;

        Type.ANIMATION = 4;

        Type.CONTROL_MAX = 5;

        return Type;

      })();

      function Control(controlType, controlId) {
        this.controlType = controlType;
        this.controlId = controlId;
      }

      return Control;

    }).call(this);

    Format.Frame = (function() {

      function Frame(controlOffset, controls) {
        this.controlOffset = controlOffset;
        this.controls = controls;
      }

      return Frame;

    })();

    Format.MovieClipEvent = (function() {

      MovieClipEvent.ClipEvent = (function() {

        function ClipEvent() {}

        ClipEvent.LOAD = 1 << 0;

        ClipEvent.UNLOAD = 1 << 1;

        ClipEvent.ENTERFRAME = 1 << 2;

        return ClipEvent;

      })();

      function MovieClipEvent(clipEvent, animationId) {
        this.clipEvent = clipEvent;
        this.animationId = animationId;
      }

      return MovieClipEvent;

    }).call(this);

    Format.Movie = (function() {

      function Movie(depths, labelOffset, labels, frameOffset, frames, clipEventId, clipEvents) {
        this.depths = depths;
        this.labelOffset = labelOffset;
        this.labels = labels;
        this.frameOffset = frameOffset;
        this.frames = frames;
        this.clipEventId = clipEventId;
        this.clipEvents = clipEvents;
      }

      return Movie;

    })();

    Format.MovieLinkage = (function(_super) {

      __extends(MovieLinkage, _super);

      function MovieLinkage(stringId, movieId) {
        this.movieId = movieId;
        MovieLinkage.__super__.constructor.call(this, stringId);
      }

      return MovieLinkage;

    })(Format.StringBase);

    Format.ItemArray = (function() {

      function ItemArray(offset, length) {
        this.offset = offset;
        this.length = length;
      }

      return ItemArray;

    })();

    Format.Header = (function() {

      function Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength) {
        this.id0 = id0;
        this.id1 = id1;
        this.id2 = id2;
        this.id3 = id3;
        this.formatVersion0 = formatVersion0;
        this.formatVersion1 = formatVersion1;
        this.formatVersion2 = formatVersion2;
        this.option = option;
        this.width = width;
        this.height = height;
        this.frameRate = frameRate;
        this.rootMovieId = rootMovieId;
        this.nameStringId = nameStringId;
        this.backgroundColor = backgroundColor;
        this.stringBytes = stringBytes;
        this.animationBytes = animationBytes;
        this.translate = translate;
        this.matrix = matrix;
        this.color = color;
        this.alphaTransform = alphaTransform;
        this.colorTransform = colorTransform;
        this.objectData = objectData;
        this.texture = texture;
        this.textureFragment = textureFragment;
        this.bitmap = bitmap;
        this.bitmapEx = bitmapEx;
        this.font = font;
        this.textProperty = textProperty;
        this.text = text;
        this.particleData = particleData;
        this.particle = particle;
        this.programObject = programObject;
        this.graphicObject = graphicObject;
        this.graphic = graphic;
        this.animation = animation;
        this.buttonCondition = buttonCondition;
        this.button = button;
        this.label = label;
        this.instanceName = instanceName;
        this.eventData = eventData;
        this.place = place;
        this.controlMoveM = controlMoveM;
        this.controlMoveC = controlMoveC;
        this.controlMoveMC = controlMoveMC;
        this.control = control;
        this.frame = frame;
        this.movieClipEvent = movieClipEvent;
        this.movie = movie;
        this.movieLinkage = movieLinkage;
        this.stringData = stringData;
        this.lwfLength = lwfLength;
      }

      return Header;

    })();

    return Format;

  }).call(this);

  Align = Format.TextProperty.Align;

  ClipEvent = Format.MovieClipEvent.ClipEvent;

  Condition = Format.ButtonCondition.Condition;

  Constant = Format.Constant;

  Type = Format.LObject.Type;

  ControlType = Format.Control.Type;

  GObjType = Format.GraphicObject.Type;

  Animation = (function() {

    function Animation() {}

    Animation.END = 0;

    Animation.PLAY = 1;

    Animation.STOP = 2;

    Animation.GOTONEXTFRAME = 3;

    Animation.GOTOPREVFRAME = 4;

    Animation.GOTOFRAME = 5;

    Animation.GOTOLABEL = 6;

    Animation.SETTARGET = 7;

    Animation.EVENT = 8;

    Animation.CALL = 9;

    Animation.INSTANCE_TARGET_ROOT = -1;

    Animation.INSTANCE_TARGET_PARENT = -2;

    return Animation;

  })();

  Data = (function() {

    function Data(header, translates, matrices, colors, alphaTransforms, colorTransforms, objects, textures, textureFragments, bitmaps, bitmapExs, fonts, textProperties, texts, particleDatas, particles, programObjects, graphicObjects, graphics, animations, buttonConditions, buttons, labels, instanceNames, events, places, controlMoveMs, controlMoveCs, controlMoveMCs, controls, frames, movieClipEvents, movies, movieLinkages, strings) {
      var d;
      this.header = header;
      this.translates = translates;
      this.matrices = matrices;
      this.colors = colors;
      this.alphaTransforms = alphaTransforms;
      this.colorTransforms = colorTransforms;
      this.objects = objects;
      this.textures = textures;
      this.textureFragments = textureFragments;
      this.bitmaps = bitmaps;
      this.bitmapExs = bitmapExs;
      this.fonts = fonts;
      this.textProperties = textProperties;
      this.texts = texts;
      this.particleDatas = particleDatas;
      this.particles = particles;
      this.programObjects = programObjects;
      this.graphicObjects = graphicObjects;
      this.graphics = graphics;
      this.animations = animations;
      this.buttonConditions = buttonConditions;
      this.buttons = buttons;
      this.labels = labels;
      this.instanceNames = instanceNames;
      this.events = events;
      this.places = places;
      this.controlMoveMs = controlMoveMs;
      this.controlMoveCs = controlMoveCs;
      this.controlMoveMCs = controlMoveMCs;
      this.controls = controls;
      this.frames = frames;
      this.movieClipEvents = movieClipEvents;
      this.movies = movies;
      this.movieLinkages = movieLinkages;
      this.strings = strings;
      if (this.header.header != null) {
        d = this.header;
        this.header = d.header;
        this.translates = d.translates;
        this.matrices = d.matrices;
        this.colors = d.colors;
        this.alphaTransforms = d.alphaTransforms;
        this.colorTransforms = d.colorTransforms;
        this.objects = d.objects;
        this.textures = d.textures;
        this.textureFragments = d.textureFragments;
        this.bitmaps = d.bitmaps;
        this.bitmapExs = d.bitmapExs;
        this.fonts = d.fonts;
        this.textProperties = d.textProperties;
        this.texts = d.texts;
        this.particleDatas = d.particleDatas;
        this.particles = d.particles;
        this.programObjects = d.programObjects;
        this.graphicObjects = d.graphicObjects;
        this.graphics = d.graphics;
        this.animations = d.animations;
        this.buttonConditions = d.buttonConditions;
        this.buttons = d.buttons;
        this.labels = d.labels;
        this.instanceNames = d.instanceNames;
        this.events = d.events;
        this.places = d.places;
        this.controlMoveMs = d.controlMoveMs;
        this.controlMoveCs = d.controlMoveCs;
        this.controlMoveMCs = d.controlMoveMCs;
        this.controls = d.controls;
        this.frames = d.frames;
        this.movieClipEvents = d.movieClipEvents;
        this.movies = d.movies;
        this.movieLinkages = d.movieLinkages;
        this.strings = d.strings;
        this.stringMap = d.stringMap;
        this.eventMap = d.eventMap;
        this.instanceNameMap = d.instanceNameMap;
        this.movieLinkageMap = d.movieLinkageMap;
        this.movieLinkageNameMap = d.movieLinkageNameMap;
        this.programObjectMap = d.programObjectMap;
        this.labelMap = d.labelMap;
        this.useScript = d.useScript;
        this.useTextureAtlas = d.useTextureAtlas;
      } else {
        this.stringMap = {};
        this.eventMap = {};
        this.instanceNameMap = {};
        this.movieLinkageMap = {};
        this.movieLinkageNameMap = {};
        this.programObjectMap = {};
        this.labelMap = [];
        if (this.header != null) {
          this.useScript = (this.header.option & Format.Constant.OPTION_USE_SCRIPT) !== 0;
          this.useTextureAtlas = (this.header.option & Format.Constant.OPTION_USE_TEXTUREATLAS) !== 0;
        } else {
          this.useScript = false;
          this.useTextureAtlas = false;
        }
      }
    }

    Data.prototype.check = function() {
      if ((this.header != null) && this.header.id0 === 'L' && this.header.id1 === 'W' && this.header.id2 === 'F' && this.header.formatVersion0 === Format.Constant.FORMAT_VERSION_0 && this.header.formatVersion1 === Format.Constant.FORMAT_VERSION_1 && this.header.formatVersion2 === Format.Constant.FORMAT_VERSION_2) {
        return true;
      } else {
        return false;
      }
    };

    Data.prototype.name = function() {
      return this.strings[this.header.nameStringId];
    };

    Data.prototype.replaceTexture = function(index, textureReplacement) {
      if (index < 0 || index >= textures.length) {
        return false;
      }
      textures[index] = textureReplacement;
      return true;
    };

    Data.prototype.replaceTextureFragment = function(index, textureFragmentReplacement) {
      if (index < 0 || index >= textureFragments.length) {
        return false;
      }
      textureFragments[index] = textureFragmentReplacement;
      return true;
    };

    return Data;

  })();

  LWFLoader = (function() {

    function LWFLoader() {}

    LWFLoader.prototype.readByte = function() {
      return this.d.charCodeAt(this.index++) & 0xff;
    };

    LWFLoader.prototype.readChar = function() {
      return String.fromCharCode(this.readByte());
    };

    LWFLoader.prototype.readBytes = function(length) {
      var bytes;
      bytes = this.d.substr(this.index, length);
      this.index += length;
      return bytes;
    };

    LWFLoader.prototype.readInt32 = function() {
      return (this.readByte() << 0) + (this.readByte() << 8) + (this.readByte() << 16) + (this.readByte() << 24);
    };

    LWFLoader.prototype.readSingle = function() {
      var b0, b1, b2, b3, exp, sig, sign;
      b3 = this.readByte();
      b2 = this.readByte();
      b1 = this.readByte();
      b0 = this.readByte();
      sign = 1 - (2 * (b0 >> 7));
      exp = (((b0 << 1) & 0xff) | (b1 >> 7)) - 127;
      sig = ((b1 & 0x7f) << 16) | (b2 << 8) | b3;
      if (sig === 0 && exp === -127) {
        return 0.0;
      }
      return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
    };

    LWFLoader.prototype.loadTranslate = function() {
      return new Translate(this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadMatrix = function() {
      return new Matrix(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadColor = function() {
      return new Color(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadAlphaTransform = function() {
      return new AlphaTransform(this.readSingle());
    };

    LWFLoader.prototype.loadColorTransform = function() {
      var add, multi;
      multi = this.loadColor();
      add = this.loadColor();
      return new ColorTransform(multi.red, multi.green, multi.blue, multi.alpha);
    };

    LWFLoader.prototype.loadTexture = function() {
      return new Format.Texture(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle());
    };

    LWFLoader.prototype.loadTextureFragment = function() {
      return new Format.TextureFragment(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadBitmap = function() {
      return new Format.Bitmap(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadBitmapEx = function() {
      return new Format.BitmapEx(this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadFont = function() {
      return new Format.Font(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadTextProperty = function() {
      return new Format.TextProperty(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadText = function() {
      return new Format.Text(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadParticleData = function() {
      return new Format.ParticleData(this.readInt32());
    };

    LWFLoader.prototype.loadParticle = function() {
      return new Format.Particle(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadProgramObject = function() {
      return new Format.ProgramObject(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphicObject = function() {
      return new Format.GraphicObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphic = function() {
      return new Format.Graphic(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadObject = function() {
      return new Format.LObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadAnimation = function() {
      return new Format.Animation(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButtonCondition = function() {
      return new Format.ButtonCondition(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButton = function() {
      return new Format.Button(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadLabel = function() {
      return new Format.Label(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadInstanceName = function() {
      return new Format.InstanceName(this.readInt32());
    };

    LWFLoader.prototype.loadEvent = function() {
      return new Format.Event(this.readInt32());
    };

    LWFLoader.prototype.loadString = function() {
      return new Format.String(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadPlace = function() {
      return new Format.Place(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveM = function() {
      return new Format.ControlMoveM(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveC = function() {
      return new Format.ControlMoveC(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveMC = function() {
      return new Format.ControlMoveMC(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControl = function() {
      return new Format.Control(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadFrame = function() {
      return new Format.Frame(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieClipEvent = function() {
      return new Format.MovieClipEvent(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovie = function() {
      return new Format.Movie(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieLinkage = function() {
      return new Format.MovieLinkage(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadItemArray = function() {
      return new Format.ItemArray(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadHeader = function() {
      var alphaTransform, animation, animationBytes, backgroundColor, bitmap, bitmapEx, button, buttonCondition, color, colorTransform, control, controlMoveC, controlMoveM, controlMoveMC, eventData, font, formatVersion0, formatVersion1, formatVersion2, frame, frameRate, graphic, graphicObject, height, id0, id1, id2, id3, instanceName, label, lwfLength, matrix, movie, movieClipEvent, movieLinkage, nameStringId, objectData, option, particle, particleData, place, programObject, rootMovieId, stringBytes, stringData, text, textProperty, texture, textureFragment, translate, width;
      id0 = this.readChar();
      id1 = this.readChar();
      id2 = this.readChar();
      id3 = this.readChar();
      formatVersion0 = this.readByte();
      formatVersion1 = this.readByte();
      formatVersion2 = this.readByte();
      option = this.readByte();
      width = this.readInt32();
      height = this.readInt32();
      frameRate = this.readInt32();
      rootMovieId = this.readInt32();
      nameStringId = this.readInt32();
      backgroundColor = this.readInt32();
      stringBytes = this.loadItemArray();
      animationBytes = this.loadItemArray();
      translate = this.loadItemArray();
      matrix = this.loadItemArray();
      color = this.loadItemArray();
      alphaTransform = this.loadItemArray();
      colorTransform = this.loadItemArray();
      objectData = this.loadItemArray();
      texture = this.loadItemArray();
      textureFragment = this.loadItemArray();
      bitmap = this.loadItemArray();
      bitmapEx = this.loadItemArray();
      font = this.loadItemArray();
      textProperty = this.loadItemArray();
      text = this.loadItemArray();
      particleData = this.loadItemArray();
      particle = this.loadItemArray();
      programObject = this.loadItemArray();
      graphicObject = this.loadItemArray();
      graphic = this.loadItemArray();
      animation = this.loadItemArray();
      buttonCondition = this.loadItemArray();
      button = this.loadItemArray();
      label = this.loadItemArray();
      instanceName = this.loadItemArray();
      eventData = this.loadItemArray();
      place = this.loadItemArray();
      controlMoveM = this.loadItemArray();
      controlMoveC = this.loadItemArray();
      controlMoveMC = this.loadItemArray();
      control = this.loadItemArray();
      frame = this.loadItemArray();
      movieClipEvent = this.loadItemArray();
      movie = this.loadItemArray();
      movieLinkage = this.loadItemArray();
      stringData = this.loadItemArray();
      lwfLength = this.readInt32();
      return new Format.Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength);
    };

    LWFLoader.prototype.load = function(d) {
      var a, animationBytes, animations, c, c2, c3, code, data, eventMap, header, i, instanceNameMap, l, labelMap, m, map, movieLinkageMap, movieLinkageNameMap, o, programObjectMap, s, str, stringBytes, stringDatas, stringMap, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.d = d;
      this.index = 0;
      header = this.loadHeader();
      data = new Data(header);
      if (!data.check()) {
        return null;
      }
      stringBytes = this.readBytes(header.stringBytes.length);
      animationBytes = this.readBytes(header.animationBytes.length);
      data.translates = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.translate.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTranslate());
        }
        return _results;
      }).call(this);
      data.matrices = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.matrix.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMatrix());
        }
        return _results;
      }).call(this);
      data.colors = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.color.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColor());
        }
        return _results;
      }).call(this);
      data.alphaTransforms = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.alphaTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAlphaTransform());
        }
        return _results;
      }).call(this);
      data.colorTransforms = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.colorTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColorTransform());
        }
        return _results;
      }).call(this);
      data.objects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.objectData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadObject());
        }
        return _results;
      }).call(this);
      data.textures = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.texture.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTexture());
        }
        return _results;
      }).call(this);
      data.textureFragments = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.textureFragment.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTextureFragment());
        }
        return _results;
      }).call(this);
      data.bitmaps = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.bitmap.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmap());
        }
        return _results;
      }).call(this);
      data.bitmapExs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.bitmapEx.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmapEx());
        }
        return _results;
      }).call(this);
      data.fonts = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.font.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFont());
        }
        return _results;
      }).call(this);
      data.textProperties = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.textProperty.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTextProperty());
        }
        return _results;
      }).call(this);
      data.texts = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadText());
        }
        return _results;
      }).call(this);
      data.particleDatas = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.particleData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticleData());
        }
        return _results;
      }).call(this);
      data.particles = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.particle.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticle());
        }
        return _results;
      }).call(this);
      data.programObjects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.programObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadProgramObject());
        }
        return _results;
      }).call(this);
      data.graphicObjects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.graphicObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphicObject());
        }
        return _results;
      }).call(this);
      data.graphics = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.graphic.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphic());
        }
        return _results;
      }).call(this);
      animations = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.animation.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAnimation());
        }
        return _results;
      }).call(this);
      data.buttonConditions = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.buttonCondition.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButtonCondition());
        }
        return _results;
      }).call(this);
      data.buttons = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.button.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButton());
        }
        return _results;
      }).call(this);
      data.labels = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.label.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadLabel());
        }
        return _results;
      }).call(this);
      data.instanceNames = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.instanceName.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadInstanceName());
        }
        return _results;
      }).call(this);
      data.events = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.eventData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadEvent());
        }
        return _results;
      }).call(this);
      data.places = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.place.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadPlace());
        }
        return _results;
      }).call(this);
      data.controlMoveMs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveM.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveM());
        }
        return _results;
      }).call(this);
      data.controlMoveCs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveC());
        }
        return _results;
      }).call(this);
      data.controlMoveMCs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveMC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveMC());
        }
        return _results;
      }).call(this);
      data.controls = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.control.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControl());
        }
        return _results;
      }).call(this);
      data.frames = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.frame.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFrame());
        }
        return _results;
      }).call(this);
      data.movieClipEvents = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movieClipEvent.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieClipEvent());
        }
        return _results;
      }).call(this);
      data.movies = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movie.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovie());
        }
        return _results;
      }).call(this);
      data.movieLinkages = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movieLinkage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieLinkage());
        }
        return _results;
      }).call(this);
      stringDatas = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.stringData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadString());
        }
        return _results;
      }).call(this);
      data.animations = [];
      for (_i = 0, _len = animations.length; _i < _len; _i++) {
        a = animations[_i];
        o = a.animationOffset;
        data.animations.push(this.readAnimation(animationBytes.slice(o, o + a.animationLength)));
      }
      data.strings = [];
      stringMap = data.stringMap;
      for (_j = 0, _len1 = stringDatas.length; _j < _len1; _j++) {
        a = stringDatas[_j];
        o = a.stringOffset;
        s = stringBytes.slice(o, o + a.stringLength);
        str = "";
        i = 0;
        while (i < s.length) {
          c = s.charCodeAt(i);
          if (c < 128) {
            str += String.fromCharCode(c);
            ++i;
          } else if (c > 191 && c < 224) {
            c2 = s.charCodeAt(i + 1);
            str += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
          } else {
            c2 = s.charCodeAt(i + 1);
            c3 = s.charCodeAt(i + 2);
            code = ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
            str += String.fromCharCode(code);
            i += 3;
          }
        }
        stringMap[str] = data.strings.length;
        data.strings.push(str);
      }
      instanceNameMap = data.instanceNameMap;
      for (i = _k = 0, _ref = data.instanceNames.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
        instanceNameMap[data.instanceNames[i].stringId] = i;
      }
      eventMap = data.eventMap;
      for (i = _l = 0, _ref1 = data.events.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
        eventMap[data.events[i].stringId] = i;
      }
      movieLinkageMap = data.movieLinkageMap;
      for (i = _m = 0, _ref2 = data.movieLinkages.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
        movieLinkageMap[data.movieLinkages[i].stringId] = i;
      }
      movieLinkageNameMap = data.movieLinkageNameMap;
      for (i = _n = 0, _ref3 = data.movieLinkages.length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; i = 0 <= _ref3 ? ++_n : --_n) {
        movieLinkageNameMap[data.movieLinkages[i].movieId] = data.movieLinkages[i].stringId;
      }
      programObjectMap = data.programObjectMap;
      _ref4 = data.programObjects;
      for (i in _ref4) {
        o = _ref4[i];
        programObjectMap[o.stringId] = i;
      }
      labelMap = data.labelMap;
      _ref5 = data.movies;
      for (_o = 0, _len2 = _ref5.length; _o < _len2; _o++) {
        m = _ref5[_o];
        o = m.labelOffset;
        map = {};
        _ref6 = data.labels.slice(o, o + m.labels);
        for (_p = 0, _len3 = _ref6.length; _p < _len3; _p++) {
          l = _ref6[_p];
          map[l.stringId] = l.frameNo;
        }
        labelMap.push(map);
      }
      _ref7 = data.textures;
      for (_q = 0, _len4 = _ref7.length; _q < _len4; _q++) {
        t = _ref7[_q];
        t.setFilename(data);
      }
      _ref8 = data.textureFragments;
      for (_r = 0, _len5 = _ref8.length; _r < _len5; _r++) {
        t = _ref8[_r];
        t.setFilename(data);
      }
      return data;
    };

    LWFLoader.prototype.readByteFromBytes = function(bytes, index) {
      var b;
      b = bytes.charCodeAt(index++) & 0xff;
      return [index, b];
    };

    LWFLoader.prototype.readInt32FromBytes = function(bytes, index) {
      var b0, b1, b2, b3, i, _ref, _ref1, _ref2, _ref3;
      _ref = this.readByteFromBytes(bytes, index), index = _ref[0], b0 = _ref[1];
      _ref1 = this.readByteFromBytes(bytes, index), index = _ref1[0], b1 = _ref1[1];
      _ref2 = this.readByteFromBytes(bytes, index), index = _ref2[0], b2 = _ref2[1];
      _ref3 = this.readByteFromBytes(bytes, index), index = _ref3[0], b3 = _ref3[1];
      i = (b0 << 0) + (b1 << 8) + (b2 << 16) + (b3 << 24);
      return [index, i];
    };

    LWFLoader.prototype.readAnimation = function(bytes) {
      var array, code, count, i, index, target, _i, _ref, _ref1, _ref2, _ref3;
      array = [];
      index = 0;
      while (true) {
        _ref = this.readByteFromBytes(bytes, index), index = _ref[0], code = _ref[1];
        array.push(code);
        switch (code) {
          case Animation.GOTOFRAME:
          case Animation.GOTOLABEL:
          case Animation.EVENT:
          case Animation.CALL:
            _ref1 = this.readInt32FromBytes(bytes, index), index = _ref1[0], i = _ref1[1];
            array.push(i);
            break;
          case Animation.SETTARGET:
            _ref2 = this.readInt32FromBytes(bytes, index), index = _ref2[0], count = _ref2[1];
            array.push(count);
            for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
              _ref3 = this.readInt32FromBytes(bytes, index), index = _ref3[0], target = _ref3[1];
              array.push(target);
            }
            break;
          case Animation.END:
            return array;
        }
      }
    };

    return LWFLoader;

  })();

  LWFLoaderWithArray = (function(_super) {

    __extends(LWFLoaderWithArray, _super);

    function LWFLoaderWithArray() {
      return LWFLoaderWithArray.__super__.constructor.apply(this, arguments);
    }

    LWFLoaderWithArray.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArray.prototype.readBytes = function(length) {
      var bytes, i, _i;
      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    return LWFLoaderWithArray;

  })(LWFLoader);

  LWFLoaderWithArrayBuffer = (function(_super) {

    __extends(LWFLoaderWithArrayBuffer, _super);

    function LWFLoaderWithArrayBuffer() {
      this.int32Array = new Int32Array();
      this.float32Array = new Float32Array();
    }

    LWFLoaderWithArrayBuffer.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArrayBuffer.prototype.readBytes = function(length) {
      var bytes, i, _i;
      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    LWFLoaderWithArrayBuffer.prototype.readInt32 = function() {
      var i;
      i = this.dInt32[this.index / 4];
      this.index += 4;
      return i;
    };

    LWFLoaderWithArrayBuffer.prototype.readSingle = function() {
      var f;
      f = this.dFloat32[this.index / 4];
      this.index += 4;
      return f;
    };

    LWFLoaderWithArrayBuffer.prototype.load = function(d) {
      this.d = new Uint8Array(d);
      this.dInt32 = new Int32Array(d);
      this.dFloat32 = new Float32Array(d);
      return LWFLoaderWithArrayBuffer.__super__.load.call(this, this.d);
    };

    return LWFLoaderWithArrayBuffer;

  })(LWFLoader);

  Loader = (function() {

    function Loader() {}

    Loader.load = function(d) {
      var lwfLoader;
      if (!(d != null) || typeof d !== "string") {
        return;
      }
      lwfLoader = new LWFLoader;
      return lwfLoader.load(d);
    };

    Loader.loadArray = function(d) {
      var lwfLoader;
      if (!(d != null)) {
        return;
      }
      lwfLoader = new LWFLoaderWithArray;
      return lwfLoader.load(d);
    };

    Loader.loadArrayBuffer = function(d) {
      var lwfLoader;
      if (!(d != null)) {
        return;
      }
      lwfLoader = new LWFLoaderWithArrayBuffer;
      return lwfLoader.load(d);
    };

    return Loader;

  })();

  Utility = (function() {

    function Utility() {}

    Utility.calcMatrixToPoint = function(sx, sy, m) {
      var dx, dy;
      dx = m.scaleX * sx + m.skew0 * sy + m.translateX;
      dy = m.skew1 * sx + m.scaleY * sy + m.translateY;
      return [dx, dy];
    };

    Utility.getMatrixDeterminant = function(matrix) {
      return matrix.scaleX * matrix.scaleY - matrix.skew0 * matrix.skew1 < 0;
    };

    Utility.syncMatrix = function(movie) {
      var matrix, matrixId, md, rotation, scaleX, scaleY, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        scaleX = 1;
        scaleY = 1;
        rotation = 0;
        matrix = {
          scaleX: scaleX,
          scaleY: scaleY,
          skew0: 0,
          skew1: 0,
          translateX: translate.translateX,
          translateY: translate.translateY
        };
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        scaleX = Math.sqrt(matrix.scaleX * matrix.scaleX + matrix.skew1 * matrix.skew1);
        if (md) {
          scaleX = -scaleX;
        }
        scaleY = Math.sqrt(matrix.scaleY * matrix.scaleY + matrix.skew0 * matrix.skew0);
        if (md) {
          rotation = Math.atan2(matrix.skew1, -matrix.scaleX);
        } else {
          rotation = Math.atan2(matrix.skew1, matrix.scaleX);
        }
        rotation = rotation / Math.PI * 180;
      }
      movie.property.setMatrix(matrix, scaleX, scaleY, rotation);
    };

    Utility.getX = function(movie) {
      var matrix, matrixId, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate.translateX;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix.translateX;
      }
    };

    Utility.getY = function(movie) {
      var matrix, matrixId, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate.translateY;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix.translateY;
      }
    };

    Utility.getScaleX = function(movie) {
      var matrix, matrixId, md, scaleX, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        scaleX = Math.sqrt(matrix.scaleX * matrix.scaleX + matrix.skew1 * matrix.skew1);
        if (md) {
          scaleX = -scaleX;
        }
        return scaleX;
      }
    };

    Utility.getScaleY = function(movie) {
      var matrix, matrixId, scaleY, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        scaleY = Math.sqrt(matrix.scaleY * matrix.scaleY + matrix.skew0 * matrix.skew0);
        return scaleY;
      }
    };

    Utility.getRotation = function(movie) {
      var matrix, matrixId, md, rotation, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 0;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        if (md) {
          rotation = Math.atan2(matrix.skew1, -matrix.scaleX);
        } else {
          rotation = Math.atan2(matrix.skew1, matrix.scaleX);
        }
        rotation = rotation / Math.PI * 180;
        return rotation;
      }
    };

    Utility.syncColorTransform = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref;
      colorTransformId = (_ref = movie.colorTransformId) != null ? _ref : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        colorTransform = {
          multi: {
            red: 1,
            green: 1,
            blue: 1,
            alpha: alphaTransform.alpha
          }
        };
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
      }
      movie.property.setColorTransform(colorTransform);
    };

    Utility.getAlpha = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref;
      colorTransformId = (_ref = movie.colorTransformId) != null ? _ref : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        return alphaTransform.alpha;
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
        return colorTransform.alpha;
      }
    };

    Utility.calcMatrixId = function(lwf, dst, src0, src1Id) {
      var matrixId, src1, translate;
      if (src1Id === 0) {
        dst.set(src0);
      } else if ((src1Id & Constant.MATRIX_FLAG) === 0) {
        translate = lwf.data.translates[src1Id];
        dst.scaleX = src0.scaleX;
        dst.skew0 = src0.skew0;
        dst.translateX = src0.scaleX * translate.translateX + src0.skew0 * translate.translateY + src0.translateX;
        dst.skew1 = src0.skew1;
        dst.scaleY = src0.scaleY;
        dst.translateY = src0.skew1 * translate.translateX + src0.scaleY * translate.translateY + src0.translateY;
      } else {
        matrixId = src1Id & ~Constant.MATRIX_FLAG;
        src1 = lwf.data.matrices[matrixId];
        this.calcMatrix(dst, src0, src1);
      }
      return dst;
    };

    Utility.calcMatrix = function(dst, src0, src1) {
      dst.scaleX = src0.scaleX * src1.scaleX + src0.skew0 * src1.skew1;
      dst.skew0 = src0.scaleX * src1.skew0 + src0.skew0 * src1.scaleY;
      dst.translateX = src0.scaleX * src1.translateX + src0.skew0 * src1.translateY + src0.translateX;
      dst.skew1 = src0.skew1 * src1.scaleX + src0.scaleY * src1.skew1;
      dst.scaleY = src0.skew1 * src1.skew0 + src0.scaleY * src1.scaleY;
      dst.translateY = src0.skew1 * src1.translateX + src0.scaleY * src1.translateY + src0.translateY;
      return dst;
    };

    Utility.rotateMatrix = function(dst, src, scale, offsetX, offsetY) {
      offsetX *= scale;
      offsetY *= scale;
      dst.scaleX = -src.skew0 * scale;
      dst.skew0 = src.scaleX * scale;
      dst.translateX = src.scaleX * offsetX + src.skew0 * offsetY + src.translateX;
      dst.skew1 = -src.scaleY * scale;
      dst.scaleY = src.skew1 * scale;
      dst.translateY = src.skew1 * offsetX + src.scaleY * offsetY + src.translateY;
      return dst;
    };

    Utility.scaleMatrix = function(dst, src, scale, offsetX, offsetY) {
      offsetX *= scale;
      offsetY *= scale;
      dst.scaleX = src.scaleX * scale;
      dst.skew0 = src.skew0 * scale;
      dst.translateX = src.scaleX * offsetX + src.skew0 * offsetY + src.translateX;
      dst.skew1 = src.skew1 * scale;
      dst.scaleY = src.scaleY * scale;
      dst.translateY = src.skew1 * offsetX + src.scaleY * offsetY + src.translateY;
      return dst;
    };

    Utility.fitForHeight = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageHeight / lwf.height;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
      lwf.property.move((stageWidth - lwf.width * scale) / 2, 0);
    };

    Utility.fitForWidth = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageWidth / lwf.width;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
      lwf.property.move(0, (stageHeight - lwf.height * scale) / 2, 0);
    };

    Utility.scaleForHeight = function(lwf, stageHeight) {
      var scale;
      scale = stageHeight / lwf.height;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
    };

    Utility.scaleForWidth = function(lwf, stageWidth) {
      var scale;
      scale = stageWidth / lwf.width;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
    };

    Utility.copyMatrix = function(dst, src) {
      if (src !== null) {
        dst.set(src);
      } else {
        dst.clear();
      }
      return dst;
    };

    Utility.invertMatrix = function(dst, src) {
      var dt;
      dt = src.scaleX * src.scaleY - src.skew0 * src.skew1;
      if (dt !== 0) {
        dst.scaleX = src.scaleY / dt;
        dst.skew0 = -src.skew0 / dt;
        dst.translateX = (src.skew0 * src.translateY - src.translateX * src.scaleY) / dt;
        dst.skew1 = -src.skew1 / dt;
        dst.scaleY = src.scaleX / dt;
        dst.translateY = (src.translateX * src.skew1 - src.scaleX * src.translateY) / dt;
      } else {
        dst.clear();
      }
    };

    Utility.calcColorTransformId = function(lwf, dst, src0, src1Id) {
      var alphaTransform, colorTransformId, src1;
      if (src1Id === 0) {
        dst.set(src0);
      } else if ((src1Id & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = lwf.data.alphaTransforms[src1Id];
        dst.multi.red = src0.multi.red;
        dst.multi.green = src0.multi.green;
        dst.multi.blue = src0.multi.blue;
        dst.multi.alpha = src0.multi.alpha * alphaTransform.alpha;
      } else {
        colorTransformId = src1Id & ~Constant.COLORTRANSFORM_FLAG;
        src1 = lwf.data.colorTransforms[colorTransformId];
        this.calcColorTransform(dst, src0, src1);
      }
      return dst;
    };

    Utility.calcColorTransform = function(dst, src0, src1) {
      dst.multi.red = src0.multi.red * src1.multi.red;
      dst.multi.green = src0.multi.green * src1.multi.green;
      dst.multi.blue = src0.multi.blue * src1.multi.blue;
      dst.multi.alpha = src0.multi.alpha * src1.multi.alpha;
      return dst;
    };

    Utility.copyColorTransform = function(dst, src) {
      if (src !== null) {
        dst.set(src);
      } else {
        dst.clear();
      }
      return dst;
    };

    Utility.calcColor = function(dst, c, t) {
      dst.red = c.red * t.multi.red;
      dst.green = c.green * t.multi.green;
      dst.blue = c.blue * t.multi.blue;
      dst.alpha = c.alpha * t.multi.alpha;
    };

    return Utility;

  })();

  NullRendererFactory = (function() {

    function NullRendererFactory() {}

    NullRendererFactory.prototype.constructBitmap = function(lwf, objId, bitmap) {
      return null;
    };

    NullRendererFactory.prototype.constructBitmapEx = function(lwf, objId, bitmapEx) {
      return null;
    };

    NullRendererFactory.prototype.constructText = function(lwf, objId, text) {
      return null;
    };

    NullRendererFactory.prototype.constructParticle = function(lwf, objId, particle) {
      return null;
    };

    NullRendererFactory.prototype.init = function(lwf) {};

    NullRendererFactory.prototype.beginRender = function(lwf) {};

    NullRendererFactory.prototype.endRender = function(lwf) {};

    NullRendererFactory.prototype.destruct = function() {};

    return NullRendererFactory;

  })();

  LObject = (function() {

    function LObject(lwf, parent, type, objectId) {
      this.lwf = lwf;
      this.parent = parent;
      this.type = type;
      this.objectId = objectId;
      this.matrixId = null;
      this.colorTransformId = null;
      this.matrixIdChanged = true;
      this.colorTransformIdChanged = true;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.colorTransform = new ColorTransform(0, 0, 0, 0);
      this.execCount = 0;
      this.updated = false;
      this.isButton = this.type === Type.BUTTON;
      this.isMovie = this.type === Type.MOVIE || this.type === Type.ATTACHEDMOVIE;
      this.isParticle = this.type === Type.PARTICLE;
      this.isProgramObject = this.type === Type.PROGRAMOBJECT;
      this.isText = this.type === Type.TEXT;
    }

    LObject.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      this.matrixIdChanged = this.matrixId !== matrixId;
      this.matrixId = matrixId;
      this.colorTransformIdChanged = this.colorTransformId !== colorTransformId;
      this.colorTransformId = colorTransformId;
    };

    LObject.prototype.update = function(m, c) {
      this.updated = true;
      if (m !== null) {
        Utility.calcMatrixId(this.lwf, this.matrix, m, this.dataMatrixId);
      }
      if (c !== null) {
        Utility.copyColorTransform(this.colorTransform, c);
      }
      this.lwf.renderObject();
    };

    LObject.prototype.render = function(v, rOffset) {
      var rCount, rIndex, rIndexOffsetted;
      if (this.renderer != null) {
        rIndex = this.lwf.renderingIndex;
        rIndexOffsetted = this.lwf.renderingIndexOffsetted;
        rCount = this.lwf.renderingCount;
        if (rOffset !== Number.MIN_VALUE) {
          rIndex = rIndexOffsetted - rOffset + rCount;
        }
        this.renderer.render(this.matrix, this.colorTransform, rIndex, rCount, v);
      }
      this.lwf.renderObject();
    };

    LObject.prototype.inspect = function(inspector, hierarchy, depth, rOffset) {
      var rCount, rIndex, rIndexOffsetted;
      rIndex = this.lwf.renderingIndex;
      rIndexOffsetted = this.lwf.renderingIndexOffsetted;
      rCount = this.lwf.renderingCount;
      if (rOffset !== Number.MIN_VALUE) {
        rIndex = rIndexOffsetted + rOffset + rCount;
      }
      inspector(this, hierarchy, depth, rIndex);
      this.lwf.renderObject();
    };

    LObject.prototype.destroy = function() {
      if (this.renderer) {
        this.renderer.destruct();
        this.renderer = null;
      }
      this.parent = null;
      this.lwf = null;
    };

    return LObject;

  })();

  Graphic = (function(_super) {

    __extends(Graphic, _super);

    function Graphic(lwf, parent, objId) {
      var data, gobj, graphicObjectId, graphicObjects, i, n, obj, _i;
      Graphic.__super__.constructor.call(this, lwf, parent, Type.GRAPHIC, objId);
      data = lwf.data.graphics[objId];
      n = data.graphicObjects;
      this.displayList = [];
      graphicObjects = lwf.data.graphicObjects;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        gobj = graphicObjects[data.graphicObjectId + i];
        graphicObjectId = gobj.graphicObjectId;
        if (graphicObjectId === -1) {
          continue;
        }
        switch (gobj.graphicObjectType) {
          case GObjType.BITMAP:
            obj = new Bitmap(lwf, parent, graphicObjectId);
            break;
          case GObjType.BITMAPEX:
            obj = new BitmapEx(lwf, parent, graphicObjectId);
            break;
          case GObjType.TEXT:
            obj = new Text(lwf, parent, graphicObjectId);
        }
        obj.exec();
        this.displayList[i] = obj;
      }
    }

    Graphic.prototype.update = function(m, c) {
      var obj, _i, _len, _ref;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.update(m, c);
      }
    };

    Graphic.prototype.render = function(v, rOffset) {
      var obj, _i, _len, _ref;
      if (!v) {
        return;
      }
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.render(v, rOffset);
      }
    };

    Graphic.prototype.destroy = function() {
      var obj, _i, _len, _ref;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.destroy();
      }
      this.displayList = null;
    };

    return Graphic;

  })(LObject);

  Bitmap = (function(_super) {

    __extends(Bitmap, _super);

    function Bitmap(lwf, parent, objId) {
      Bitmap.__super__.constructor.call(this, lwf, parent, Type.BITMAP, objId);
      this.dataMatrixId = lwf.data.bitmaps[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmap(lwf, objId, this);
    }

    return Bitmap;

  })(LObject);

  BitmapEx = (function(_super) {

    __extends(BitmapEx, _super);

    function BitmapEx(lwf, parent, objId) {
      BitmapEx.__super__.constructor.call(this, lwf, parent, Type.BITMAPEX, objId);
      this.dataMatrixId = lwf.data.bitmapExs[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmapEx(lwf, objId, this);
    }

    return BitmapEx;

  })(LObject);

  Text = (function(_super) {

    __extends(Text, _super);

    function Text(lwf, parent, objId) {
      Text.__super__.constructor.call(this, lwf, parent, Type.TEXT, objId);
      this.dataMatrixId = lwf.data.texts[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructText(lwf, objId, this);
    }

    return Text;

  })(LObject);

  Particle = (function(_super) {

    __extends(Particle, _super);

    function Particle(lwf, parent, objId) {
      Particle.__super__.constructor.call(this, lwf, parent, Type.PARTICLE, objId);
      this.dataMatrixId = lwf.data.particles[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructParticle(lwf, objId, this);
    }

    Particle.prototype.update = function(m, c) {
      Particle.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return Particle;

  })(LObject);

  ProgramObject = (function(_super) {

    __extends(ProgramObject, _super);

    function ProgramObject(lwf, parent, objId) {
      var ctor, data;
      ProgramObject.__super__.constructor.call(this, lwf, parent, Type.PROGRAMOBJECT, objId);
      data = lwf.data.programObjects[objId];
      this.dataMatrixId = data.matrixId;
      ctor = lwf.getProgramObjectConstructor(objId);
      if (ctor != null) {
        this.renderer = ctor(this, objId, data.width, data.height);
      }
    }

    ProgramObject.prototype.update = function(m, c) {
      ProgramObject.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return ProgramObject;

  })(LObject);

  IObject = (function(_super) {

    __extends(IObject, _super);

    function IObject(lwf, parent, type, objId, instId) {
      var head, stringId;
      IObject.__super__.constructor.call(this, lwf, parent, type, objId);
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      this.instanceId = instId >= lwf.data.instanceNames.length ? -1 : instId;
      if (this.instanceId >= 0) {
        stringId = lwf.getInstanceNameStringId(this.instanceId);
        if (stringId !== -1) {
          this.name = lwf.data.strings[stringId];
          if (parent != null) {
            parent[this.name] = this;
          }
        }
        head = this.lwf.getInstance(this.instanceId);
        if (head != null) {
          head.prevInstance = this;
        }
        this.nextInstance = head;
        this.lwf.setInstance(this.instanceId, this);
      }
    }

    IObject.prototype.destroy = function() {
      var head;
      if (this.type !== Type.ATTACHEDMOVIE && this.instanceId >= 0) {
        head = this.lwf.getInstance(this.instanceId);
        if (head === this) {
          this.lwf.setInstance(this.instanceId, this.nextInstance);
        }
        if (this.nextInstance != null) {
          this.nextInstance.prevInstance = this.prevInstance;
        }
        if (this.prevInstance != null) {
          this.prevInstance.nextInstance = this.nextInstance;
        }
      }
      if ((this.name != null) && (typeof parent !== "undefined" && parent !== null)) {
        delete parent[this.name];
      }
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      return IObject.__super__.destroy.apply(this, arguments);
    };

    IObject.prototype.linkButton = function() {};

    IObject.prototype.getFullName = function() {
      var fullPath, o, splitter;
      fullPath = "";
      splitter = "";
      o = this;
      while (o != null) {
        if (o.name == null) {
          return null;
        }
        fullPath = o.name + splitter + fullPath;
        splitter = ".";
        o = o.parent;
      }
      return fullPath;
    };

    return IObject;

  })(LObject);

  Button = (function(_super) {

    __extends(Button, _super);

    function Button(lwf, parent, objId, instId, matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      Button.__super__.constructor.call(this, lwf, parent, Type.BUTTON, objId, instId);
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.invert = new Matrix();
      this.hitX = Number.MIN_VALUE;
      this.hitY = Number.MIN_VALUE;
      if (objId >= 0) {
        this.data = lwf.data.buttons[objId];
        this.dataMatrixId = this.data.matrixId;
        this.width = this.data.width;
        this.height = this.data.height;
      } else {
        this.width = 0;
        this.height = 0;
      }
      this.handler = lwf.getButtonEventHandlers(this);
      if (this.handler != null) {
        this.handler.call("load", this);
      }
    }

    Button.prototype.setHandlers = function(handler) {
      this.handler = handler;
    };

    Button.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      Button.__super__.exec.call(this, matrixId, colorTransformId);
      this.enterFrame();
    };

    Button.prototype.update = function(m, c) {
      Button.__super__.update.call(this, m, c);
      if (this.handler != null) {
        this.handler.call("update", this);
      }
    };

    Button.prototype.render = function(v, rOffset) {
      if (this.handler != null) {
        this.handler.call("render", this);
      }
    };

    Button.prototype.destroy = function() {
      this.lwf.clearFocus(this);
      if (this.handler != null) {
        this.handler.call("unload", this);
      }
      Button.__super__.destroy.apply(this, arguments);
    };

    Button.prototype.linkButton = function() {
      this.buttonLink = this.lwf.buttonHead;
      this.lwf.buttonHead = this;
    };

    Button.prototype.checkHit = function(px, py) {
      var x, y, _ref;
      Utility.invertMatrix(this.invert, this.matrix);
      _ref = Utility.calcMatrixToPoint(px, py, this.invert), x = _ref[0], y = _ref[1];
      if (x >= 0 && x < this.data.width && y >= 0 && y < this.data.height) {
        this.hitX = x;
        this.hitY = y;
        return true;
      } else {
        this.hitX = Number.MIN_VALUE;
        this.hitY = Number.MIN_VALUE;
        return false;
      }
    };

    Button.prototype.enterFrame = function() {
      if (this.handler != null) {
        this.handler.call("enterFrame", this);
      }
    };

    Button.prototype.rollOver = function() {
      if (this.handler != null) {
        this.handler.call("rollOver", this);
      }
      this.playAnimation(Condition.ROLLOVER);
    };

    Button.prototype.rollOut = function() {
      if (this.handler != null) {
        this.handler.call("rollOut", this);
      }
      this.playAnimation(Condition.ROLLOUT);
    };

    Button.prototype.press = function() {
      if (this.handler != null) {
        this.handler.call("press", this);
      }
      this.playAnimation(Condition.PRESS);
    };

    Button.prototype.release = function() {
      if (this.handler != null) {
        this.handler.call("release", this);
      }
      this.playAnimation(Condition.RELEASE);
    };

    Button.prototype.keyPress = function() {
      if (this.handler != null) {
        this.handler.call("keyPress", this);
      }
      this.playAnimation(Condition.KEYPRESS, code);
    };

    Button.prototype.playAnimation = function(condition, code) {
      var c, conditions, i, _i, _ref;
      if (code == null) {
        code = 0;
      }
      conditions = this.lwf.data.buttonConditions;
      for (i = _i = 0, _ref = this.data.conditions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = conditions[this.data.conditionId + i];
        if ((c.condition & condition) !== 0 && (condition !== Condition.KEYPRESS || c.keyCode === code)) {
          this.lwf.playAnimation(c.animationId, this.parent, this);
        }
      }
    };

    return Button;

  })(IObject);

  LWFContainer = (function(_super) {

    __extends(LWFContainer, _super);

    function LWFContainer(parent, child) {
      this.parent = parent;
      this.child = child;
      this.lwf = this.parent.lwf;
    }

    LWFContainer.prototype.checkHit = function(px, py) {
      var button;
      button = this.child.inputPoint(px, py);
      if (button !== null) {
        return true;
      } else {
        return false;
      }
    };

    LWFContainer.prototype.rollOver = function() {};

    LWFContainer.prototype.rollOut = function() {
      if (this.child.focus != null) {
        this.child.focus.rollOut();
        this.child.clearFocus(this.child.focus);
      }
    };

    LWFContainer.prototype.press = function() {
      this.child.inputPress();
    };

    LWFContainer.prototype.release = function() {
      this.child.inputRelease();
    };

    LWFContainer.prototype.keyPress = function(code) {
      this.child.inputKeyPress(code);
    };

    return LWFContainer;

  })(Button);

  Property = (function() {

    function Property(lwf) {
      this.lwf = lwf;
      this.matrix = new Matrix;
      this.colorTransform = new ColorTransform;
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    }

    Property.prototype.clear = function() {
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.matrix.clear();
      this.colorTransform.clear();
      if (this.hasMatrix || this.hasColorTransform) {
        this.lwf.setPropertyDirty();
      }
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    };

    Property.prototype.move = function(x, y) {
      this.matrix.translateX += x;
      this.matrix.translateY += y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.moveTo = function(x, y) {
      this.matrix.translateX = x;
      this.matrix.translateY = y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.rotate = function(degree) {
      this.rotateTo(this.rotation + degree);
    };

    Property.prototype.rotateTo = function(degree) {
      this.rotation = degree;
      this.setScaleAndRotation();
    };

    Property.prototype.scale = function(x, y) {
      this.scaleX *= x;
      this.scaleY *= y;
      this.setScaleAndRotation();
    };

    Property.prototype.scaleTo = function(x, y) {
      this.scaleX = x;
      this.scaleY = y;
      this.setScaleAndRotation();
    };

    Property.prototype.setScaleAndRotation = function() {
      var c, radian, s;
      radian = this.rotation * Math.PI / 180;
      c = Math.cos(radian);
      s = Math.sin(radian);
      this.matrix.scaleX = this.scaleX * c;
      this.matrix.skew0 = this.scaleY * -s;
      this.matrix.skew1 = this.scaleX * s;
      this.matrix.scaleY = this.scaleY * c;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      this.scaleX = scaleX != null ? scaleX : 1;
      this.scaleY = scaleY != null ? scaleY : 1;
      this.rotation = rotation != null ? rotation : 0;
      this.matrix.set(m);
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setAlpha = function(alpha) {
      this.colorTransform.multi.alpha = alpha;
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setColorTransform = function(c) {
      this.colorTransform.set(c);
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setRenderingOffset = function(rOffset) {
      this.renderingOffset = rOffset;
      this.hasRenderingOffset = true;
    };

    Property.prototype.clearRenderingOffset = function() {
      this.renderingOffset = Number.MIN_VALUE;
      this.hasRenderingOffset = false;
    };

    return Property;

  })();

  Movie = (function(_super) {

    __extends(Movie, _super);

    function Movie(lwf, parent, objId, instId, matrixId, colorTransformId, attached, handler) {
      var func, type, _ref;
      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      if (attached == null) {
        attached = false;
      }
      if (handler == null) {
        handler = null;
      }
      type = attached ? Type.ATTACHEDMOVIE : Type.MOVIE;
      Movie.__super__.constructor.call(this, lwf, parent, type, objId, instId);
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.data = lwf.data.movies[objId];
      this.totalFrames = this.data.frames;
      this.instanceHead = null;
      this.instanceTail = null;
      this.currentFrameInternal = -1;
      this.execedFrame = -1;
      this.animationPlayedFrame = -1;
      this.lastControlOffset = -1;
      this.lastControls = -1;
      this.lastHasButton = false;
      this.lastControlAnimationOffset = -1;
      this.skipped = false;
      this.postLoaded = false;
      this.active = true;
      this.visible = true;
      this.playing = true;
      this.jumped = false;
      this.overriding = false;
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      this.movieExecCount = -1;
      this.postExecCount = -1;
      this.property = new Property(lwf);
      if (typeof this.__defineGetter__ !== "undefined") {
        this.__defineGetter__("x", function() {
          return this.getX();
        });
        this.__defineSetter__("x", function(v) {
          return this.setX(v);
        });
        this.__defineGetter__("y", function() {
          return this.getY();
        });
        this.__defineSetter__("y", function(v) {
          return this.setY(v);
        });
        this.__defineGetter__("scaleX", function() {
          return this.getScaleX();
        });
        this.__defineSetter__("scaleX", function(v) {
          return this.setScaleX(v);
        });
        this.__defineGetter__("scaleY", function() {
          return this.getScaleY();
        });
        this.__defineSetter__("scaleY", function(v) {
          return this.setScaleY(v);
        });
        this.__defineGetter__("rotation", function() {
          return this.getRotation();
        });
        this.__defineSetter__("rotation", function(v) {
          return this.setRotation(v);
        });
        this.__defineGetter__("alpha", function() {
          return this.getAlphaProperty();
        });
        this.__defineSetter__("alpha", function(v) {
          return this.setAlphaProperty(v);
        });
        this.__defineGetter__("currentFrame", function() {
          return this.currentFrameInternal + 1;
        });
      } else if (typeof Object.defineProperty !== "undefined") {
        Object.defineProperty(this, "x", {
          get: function() {
            return this.getX();
          },
          set: function(v) {
            return this.setX(v);
          }
        });
        Object.defineProperty(this, "y", {
          get: function() {
            return this.getY();
          },
          set: function(v) {
            return this.setY(v);
          }
        });
        Object.defineProperty(this, "scaleX", {
          get: function() {
            return this.getScaleX();
          },
          set: function(v) {
            return this.setScaleX(v);
          }
        });
        Object.defineProperty(this, "scaleY", {
          get: function() {
            return this.getScaleY();
          },
          set: function(v) {
            return this.setScaleY(v);
          }
        });
        Object.defineProperty(this, "rotation", {
          get: function() {
            return this.getRotation();
          },
          set: function(v) {
            return this.setRotation(v);
          }
        });
        Object.defineProperty(this, "alpha", {
          get: function() {
            return this.getAlphaProperty();
          },
          set: function(v) {
            return this.setAlphaProperty(v);
          }
        });
        Object.defineProperty(this, "currentFrame", {
          get: function() {
            return this.currentFrameInternal + 1;
          }
        });
      }
      this.matrix0 = new Matrix;
      this.matrix1 = new Matrix;
      this.colorTransform0 = new ColorTransform;
      this.colorTransform1 = new ColorTransform;
      this.displayList = [];
      this.attachName = null;
      this.depth = null;
      this.hasButton = false;
      this.getMovieFunctions();
      if (objId === this.lwf.data.header.rootMovieId) {
        func = (_ref = this.lwf.functions) != null ? _ref['init'] : void 0;
        if (func != null) {
          func.call(this);
        }
      }
      if (this.loadFunc != null) {
        this.loadFunc.call(this);
      }
      this.playAnimation(ClipEvent.LOAD);
      this.handler = handler != null ? handler : lwf.getMovieEventHandlers(this);
      if (this.handler != null) {
        this.handler.call("load", this);
      }
      lwf.execMovieCommand();
    }

    Movie.prototype.getMovieFunctions = function() {
      var _ref;
      _ref = this.lwf.getMovieFunctions(this.objectId), this.loadFunc = _ref[0], this.postLoadFunc = _ref[1], this.unloadFunc = _ref[2], this.enterFrameFunc = _ref[3];
    };

    Movie.prototype.setHandlers = function(handler) {
      this.handler = handler;
    };

    Movie.prototype.play = function() {
      this.playing = true;
      return this;
    };

    Movie.prototype.stop = function() {
      this.playing = false;
      return this;
    };

    Movie.prototype.gotoNextFrame = function() {
      this.jumped = true;
      this.stop();
      ++this.currentFrameInternal;
      return this;
    };

    Movie.prototype.gotoPrevFrame = function() {
      this.jumped = true;
      this.stop();
      --this.currentFrameInternal;
      return this;
    };

    Movie.prototype.gotoFrame = function(frameNo) {
      return this.gotoFrameInternal(frameNo - 1);
    };

    Movie.prototype.gotoFrameInternal = function(frameNo) {
      this.jumped = true;
      this.stop();
      this.currentFrameInternal = frameNo;
      return this;
    };

    Movie.prototype.setVisible = function(visible) {
      this.visible = visible;
      return this;
    };

    Movie.prototype.globalToLocal = function(point) {
      var invert, x, y, _ref;
      invert = new Matrix();
      Utility.invertMatrix(invert, this.matrix);
      _ref = Utility.calcMatrixToPoint(point.x, point.y, invert), x = _ref[0], y = _ref[1];
      return new Point(x, y);
    };

    Movie.prototype.localToGlobal = function(point) {
      var x, y, _ref;
      _ref = Utility.calcMatrixToPoint(point.x, point.y, this.matrix), x = _ref[0], y = _ref[1];
      return new Point(x, y);
    };

    Movie.prototype.shrinkList = function(list) {
      var i, _i, _ref;
      for (i = _i = _ref = list.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        if (list[i] != null) {
          if (i === list.length - 1) {
            return list;
          } else {
            return list.slice(0, +i + 1 || 9e9);
          }
        }
      }
      return [];
    };

    Movie.prototype.reorderList = function(reorder, list, index, object, op) {
      var i, _results;
      if (!reorder || index >= list.length) {
        list[index] = object;
      } else {
        list.splice(index, 0, object);
      }
      if (reorder) {
        i = 0;
        _results = [];
        while (i < list.length) {
          if (list[i] != null) {
            op(list[i], i);
            _results.push(i += 1);
          } else {
            _results.push(list.splice(i, 1));
          }
        }
        return _results;
      }
    };

    Movie.prototype.deleteAttachedMovie = function(parent, movie, destroy, deleteFromDetachedMovies) {
      var attachName, depth;
      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedMovies == null) {
        deleteFromDetachedMovies = true;
      }
      attachName = movie.attachName;
      depth = movie.depth;
      delete parent.attachedMovies[attachName];
      delete parent.attachedMovieList[depth];
      if (deleteFromDetachedMovies) {
        delete parent.detachedMovies[attachName];
      }
      delete parent[attachName];
      parent.attachedMovieList = this.shrinkList(parent.attachedMovieList);
      if (destroy) {
        return movie.destroy();
      }
    };

    Movie.prototype.attachMovie = function(linkageName, attachName, options) {
      var attachedMovie, depth, enterFrame, handlers, load, movie, movieId, postLoad, render, reorder, unload, update, _ref;
      if (options == null) {
        options = null;
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref = options["reorder"]) != null ? _ref : false;
      load = options["load"];
      postLoad = options["postLoad"];
      unload = options["unload"];
      enterFrame = options["enterFrame"];
      update = options["update"];
      render = options["render"];
      if (linkageName instanceof Movie && linkageName.lwf === this.lwf) {
        movie = linkageName;
        this.deleteAttachedMovie(movie.parent, movie, false);
      } else if (typeof linkageName === "string") {
        movieId = this.lwf.searchMovieLinkage(this.lwf.getStringId(linkageName));
        if (movieId === -1) {
          return null;
        }
      } else {
        return null;
      }
      if (this.attachedMovies == null) {
        this.attachedMovies = {};
        this.detachedMovies = {};
        this.attachedMovieList = [];
      }
      attachedMovie = this.attachedMovies[attachName];
      if (attachedMovie != null) {
        this.deleteAttachedMovie(this, attachedMovie);
      }
      if (!reorder) {
        attachedMovie = this.attachedMovieList[depth];
        if (attachedMovie != null) {
          this.deleteAttachedMovie(this, attachedMovie);
        }
      }
      handlers = new MovieEventHandlers(load, postLoad, unload, enterFrame, update, render);
      if (movie != null) {
        movie.setHandlers(handler);
      } else {
        movie = new Movie(this.lwf, this, movieId, -1, 0, 0, true, handlers);
        if (this.attachMovieExeced) {
          movie.exec();
        }
        if (this.attachMoviePostExeced) {
          movie.postExec(true);
        }
      }
      movie.attachName = attachName;
      movie.depth = depth != null ? depth : this.attachedMovieList.length;
      movie.name = attachName;
      this.attachedMovies[attachName] = movie;
      this.reorderList(reorder, this.attachedMovieList, movie.depth, movie, function(o, i) {
        return o.depth = i;
      });
      this[attachName] = movie;
      return movie;
    };

    Movie.prototype.swapAttachedMovieDepth = function(depth0, depth1) {
      var attachedMovie0, attachedMovie1;
      if (this.attachedMovies == null) {
        return;
      }
      attachedMovie0 = this.attachedMovieList[depth0];
      attachedMovie1 = this.attachedMovieList[depth1];
      if (attachedMovie0 != null) {
        attachedMovie0.depth = depth1;
      }
      if (attachedMovie1 != null) {
        attachedMovie1.depth = depth0;
      }
      this.attachedMovieList[depth0] = attachedMovie1;
      this.attachedMovieList[depth1] = attachedMovie0;
    };

    Movie.prototype.getAttachedMovie = function(attachName) {
      var depth;
      if (this.attachedMovies == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return this.attachedMovies[attachName];
        case "number":
          depth = attachName;
          return this.attachedMovieList[depth];
      }
    };

    Movie.prototype.searchAttachedMovie = function(attachName, recursive) {
      var i, instance, movie;
      if (recursive == null) {
        recursive = true;
      }
      movie = this.getAttachedMovie(attachName);
      if (movie != null) {
        return movie;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedMovie(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachMovie = function(arg) {
      var attachedMovie, _ref;
      if (this.detachedMovies != null) {
        switch (typeof arg) {
          case "string":
            this.detachedMovies[arg] = true;
            break;
          case "number":
            attachedMovie = (_ref = this.attachedMovieList) != null ? _ref[arg] : void 0;
            if ((attachedMovie != null ? attachedMovie.attachName : void 0) != null) {
              this.detachedMovies[attachedMovie.attachName] = true;
            }
            break;
          case typeof Movie:
            if ((arg != null ? arg.attachName : void 0) != null) {
              this.detachedMovies[arg.attachName] = true;
            }
        }
      }
    };

    Movie.prototype.detachFromParent = function() {
      if (this.type !== Type.ATTACHEDMOVIE) {
        return;
      }
      this.active = false;
      if (this.parent != null) {
        this.parent.detachMovie(this);
      }
    };

    Movie.prototype.execDetachHandler = function(lwfContainer) {
      var lwf;
      lwf = lwfContainer.child;
      if (lwf.detachHandler != null) {
        if (lwf.detachHandler(lwf)) {
          lwf.destroy();
        }
      } else {
        lwf.destroy();
      }
      lwf.parent = null;
      lwf.detachHandler = null;
      lwf.attachName = null;
    };

    Movie.prototype.deleteAttachedLWF = function(parent, lwfContainer, destroy, deleteFromDetachedLWFs) {
      var attachName, depth;
      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedLWFs == null) {
        deleteFromDetachedLWFs = true;
      }
      attachName = lwfContainer.child.attachName;
      depth = lwfContainer.child.depth;
      delete parent.attachedLWFs[attachName];
      delete parent.attachedLWFList[depth];
      if (deleteFromDetachedLWFs) {
        delete parent.detachedLWFs[attachName];
      }
      delete parent[attachName];
      parent.attachedLWFList = this.shrinkList(parent.attachedLWFList);
      if (destroy) {
        return this.execDetachHandler(lwfContainer);
      }
    };

    Movie.prototype.attachLWF = function(attachLWF, attachName, options) {
      var depth, detachHandler, lwfContainer, reorder, _ref;
      if (options == null) {
        options = null;
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref = options["reorder"]) != null ? _ref : false;
      detachHandler = options["detach"];
      if (this.attachedLWFs == null) {
        this.attachedLWFs = {};
        this.detachedLWFs = {};
        this.attachedLWFList = [];
      }
      if (attachLWF.parent != null) {
        lwfContainer = attachLWF.parent.attachedLWFs[attachLWF.attachName];
        this.deleteAttachedLWF(attachLWF.parent, lwfContainer, false);
      }
      lwfContainer = this.attachedLWFs[attachName];
      if (lwfContainer != null) {
        this.deleteAttachedLWF(this, lwfContainer);
      }
      if (!reorder) {
        lwfContainer = this.attachedLWFList[depth];
        if (lwfContainer != null) {
          this.deleteAttachedLWF(this, lwfContainer);
        }
      }
      lwfContainer = new LWFContainer(this, attachLWF);
      if (attachLWF.interactive) {
        this.lwf.interactive = true;
      }
      attachLWF.parent = this;
      attachLWF.detachHandler = detachHandler;
      attachLWF.attachName = attachName;
      attachLWF.depth = depth != null ? depth : this.attachedLWFList.length;
      this.attachedLWFs[attachName] = lwfContainer;
      this.reorderList(reorder, this.attachedLWFList, attachLWF.depth, lwfContainer, function(o, i) {
        return o.child.depth = i;
      });
      this[attachName] = attachLWF.rootMovie;
      this.lwf.isLWFAttached = true;
    };

    Movie.prototype.swapAttachedLWFDepth = function(depth0, depth1) {
      var attachedLWF0, attachedLWF1;
      if (this.attachedLWFs == null) {
        return;
      }
      attachedLWF0 = this.attachedLWFList[depth0];
      attachedLWF1 = this.attachedLWFList[depth1];
      if (attachedLWF0 != null) {
        attachedLWF0.child.depth = depth1;
      }
      if (attachedLWF1 != null) {
        attachedLWF1.child.depth = depth0;
      }
      this.attachedLWFList[depth0] = attachedLWF1;
      this.attachedLWFList[depth1] = attachedLWF0;
    };

    Movie.prototype.getAttachedLWF = function(attachName) {
      var depth, _ref, _ref1;
      if (this.attachedLWFs == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return (_ref = this.attachedLWFs[attachName]) != null ? _ref.child : void 0;
        case "number":
          depth = attachName;
          return (_ref1 = this.attachedLWFList[depth]) != null ? _ref1.child : void 0;
      }
    };

    Movie.prototype.searchAttachedLWF = function(attachName, recursive) {
      var attachedLWF, i, instance;
      if (recursive == null) {
        recursive = true;
      }
      attachedLWF = this.getAttachedLWF(attachName);
      if (attachedLWF != null) {
        return attachedLWF;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedLWF(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachLWF = function(arg) {
      var attachedLWF, _ref, _ref1;
      if (this.detachedLWFs != null) {
        switch (typeof arg) {
          case "string":
            this.detachedLWFs[arg] = true;
            break;
          case "number":
            attachedLWF = (_ref = this.attachedLWFList) != null ? _ref[arg] : void 0;
            if ((attachedLWF != null ? (_ref1 = attachedLWF.child) != null ? _ref1.attachName : void 0 : void 0) != null) {
              this.detachedLWFs[attachedLWF.child.attachName] = true;
            }
            break;
          case typeof LWF:
            if ((arg != null ? arg.attachName : void 0) != null) {
              this.detachedLWFs[arg.attachName] = true;
            }
        }
      }
    };

    Movie.prototype.detachAllLWFs = function() {
      var k, lwfContainer, _ref;
      if (this.detachedLWFs != null) {
        _ref = this.attachedLWFs;
        for (k in _ref) {
          lwfContainer = _ref[k];
          this.detachedLWFs[lwfContainer.child.attachName] = true;
        }
      }
    };

    Movie.prototype.execObject = function(depth, objId, matrixId, colorTransformId, instId) {
      var data, dataObject, dataObjectId, obj;
      if (objId === -1) {
        return;
      }
      data = this.lwf.data;
      dataObject = data.objects[objId];
      dataObjectId = dataObject.objectId;
      obj = this.displayList[depth];
      if ((obj != null) && (obj.type !== dataObject.objectType || obj.objectId !== dataObjectId || (obj.isMovie && obj.instanceId !== instId))) {
        obj.destroy();
        obj = null;
      }
      if (obj == null) {
        switch (dataObject.objectType) {
          case Type.BUTTON:
            obj = new Button(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            break;
          case Type.GRAPHIC:
            obj = new Graphic(this.lwf, this, dataObjectId);
            break;
          case Type.MOVIE:
            obj = new Movie(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            break;
          case Type.BITMAP:
            obj = new Bitmap(this.lwf, this, dataObjectId);
            break;
          case Type.BITMAPEX:
            obj = new BitmapEx(this.lwf, this, dataObjectId);
            break;
          case Type.TEXT:
            obj = new Text(this.lwf, this, dataObjectId);
            break;
          case Type.PARTICLE:
            obj = new Particle(this.lwf, this, dataObjectId);
            break;
          case Type.PROGRAMOBJECT:
            obj = new ProgramObject(this.lwf, this, dataObjectId);
        }
      }
      if (obj.isMovie || obj.isButton) {
        obj.linkInstance = null;
        if (this.instanceHead === null) {
          this.instanceHead = obj;
        } else {
          this.instanceTail.linkInstance = obj;
        }
        this.instanceTail = obj;
        if (obj.isButton) {
          this.hasButton = true;
        }
      }
      this.displayList[depth] = obj;
      obj.execCount = this.movieExecCount;
      obj.exec(matrixId, colorTransformId);
    };

    Movie.prototype.override = function(m, c) {
      this.overriding = true;
      Utility.copyMatrix(this.matrix, m);
      Utility.copyColorTransform(this.colorTransform, c);
      this.lwf.isPropertyDirty = true;
    };

    Movie.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      Movie.__super__.exec.call(this, matrixId, colorTransformId);
    };

    Movie.prototype.postExec = function(progressing) {
      var animationPlayed, attachName, control, controlAnimationOffset, ctrl, data, depth, frame, i, instance, movie, obj, p, postExeced, v, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this.hasButton = false;
      if (!this.active) {
        return;
      }
      this.execedFrame = -1;
      postExeced = this.postExecCount === this.lwf.execCount;
      if (progressing && this.playing && !this.jumped && !postExeced) {
        ++this.currentFrameInternal;
      }
      while (true) {
        if (this.currentFrameInternal < 0 || this.currentFrameInternal >= this.totalFrames) {
          this.currentFrameInternal = 0;
        }
        if (this.currentFrameInternal === this.execedFrame) {
          break;
        }
        this.currentFrameCurrent = this.currentFrameInternal;
        this.execedFrame = this.currentFrameCurrent;
        data = this.lwf.data;
        frame = data.frames[this.data.frameOffset + this.currentFrameCurrent];
        if (this.lastControlOffset === frame.controlOffset && this.lastControls === frame.controls) {
          controlAnimationOffset = this.lastControlAnimationOffset;
          if (this.skipped) {
            instance = this.instanceHead;
            while (instance !== null) {
              if (instance.isMovie) {
                instance.attachMovieExeced = false;
                instance.attachMoviePostExeced = false;
              } else if (instance.isButton) {
                instance.enterFrame();
              }
              instance = instance.linkInstance;
            }
            this.hasButton = this.lastHasButton;
          } else {
            for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
              obj = this.displayList[depth];
              if (obj != null) {
                if (!postExeced) {
                  obj.matrixIdChanged = false;
                  obj.colorTransformIdChanged = false;
                }
                if (obj.isMovie) {
                  obj.attachMovieExeced = false;
                  obj.attachMoviePostExeced = false;
                } else if (obj.isButton) {
                  obj.enterFrame();
                  this.hasButton = true;
                }
              }
            }
            this.lastHasButton = this.hasButton;
            this.skipped = true;
          }
        } else {
          ++this.movieExecCount;
          this.instanceHead = null;
          this.instanceTail = null;
          this.lastControlOffset = frame.controlOffset;
          this.lastControls = frame.controls;
          controlAnimationOffset = -1;
          for (i = _j = 0, _ref1 = frame.controls; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            control = data.controls[frame.controlOffset + i];
            switch (control.controlType) {
              case ControlType.MOVE:
                p = data.places[control.controlId];
                this.execObject(p.depth, p.objectId, p.matrixId, 0, p.instanceId);
                break;
              case ControlType.MOVEM:
                ctrl = data.controlMoveMs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, 0, p.instanceId);
                break;
              case ControlType.MOVEC:
                ctrl = data.controlMoveCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, p.matrixId, ctrl.colorTransformId, p.instanceId);
                break;
              case ControlType.MOVEMC:
                ctrl = data.controlMoveMCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, ctrl.colorTransformId, p.instanceId);
                break;
              case ControlType.ANIMATION:
                if (controlAnimationOffset === -1) {
                  controlAnimationOffset = i;
                }
            }
          }
          this.lastControlAnimationOffset = controlAnimationOffset;
          this.lastHasButton = this.hasButton;
          for (depth = _k = 0, _ref2 = this.data.depths; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; depth = 0 <= _ref2 ? ++_k : --_k) {
            obj = this.displayList[depth];
            if ((obj != null) && obj.execCount !== this.movieExecCount) {
              obj.destroy();
              this.displayList[depth] = null;
            }
          }
        }
        this.attachMovieExeced = true;
        if (this.attachedMovies != null) {
          _ref3 = this.attachedMovieList;
          for (_l = 0, _len = _ref3.length; _l < _len; _l++) {
            movie = _ref3[_l];
            if (movie != null) {
              movie.exec();
            }
          }
        }
        instance = this.instanceHead;
        while (instance !== null) {
          if (instance.isMovie) {
            movie = instance;
            movie.postExec(progressing);
            if (!this.hasButton && movie.hasButton) {
              this.hasButton = true;
            }
          }
          instance = instance.linkInstance;
        }
        this.attachMoviePostExeced = true;
        if (this.attachedMovies != null) {
          _ref4 = this.detachedMovies;
          for (attachName in _ref4) {
            v = _ref4[attachName];
            movie = this.attachedMovies[attachName];
            if (movie != null) {
              this.deleteAttachedMovie(this, movie, true, false);
            }
          }
          this.detachedMovies = {};
          _ref5 = this.attachedMovieList;
          for (_m = 0, _len1 = _ref5.length; _m < _len1; _m++) {
            movie = _ref5[_m];
            if (movie != null) {
              movie.postExec(progressing);
              if (!this.hasButton && movie.hasButton) {
                this.hasButton = true;
              }
            }
          }
        }
        if (this.attachedLWFs != null) {
          this.hasButton = true;
        }
        if (!this.postLoaded) {
          this.postLoaded = true;
          if (this.postLoadFunc != null) {
            this.postLoadFunc.call(this);
          }
          if (this.handler != null) {
            this.handler.call("postLoad", this);
          }
        }
        if (controlAnimationOffset !== -1 && this.execedFrame === this.currentFrameInternal) {
          animationPlayed = this.animationPlayedFrame === this.currentFrameCurrent && !this.jumped;
          if (!animationPlayed) {
            for (i = _n = controlAnimationOffset, _ref6 = frame.controls; controlAnimationOffset <= _ref6 ? _n < _ref6 : _n > _ref6; i = controlAnimationOffset <= _ref6 ? ++_n : --_n) {
              control = data.controls[frame.controlOffset + i];
              this.lwf.playAnimation(control.controlId, this);
            }
          }
        }
        this.animationPlayedFrame = this.currentFrameCurrent;
        if (this.currentFrameCurrent === this.currentFrameInternal) {
          this.jumped = false;
        }
      }
      if (this.enterFrameFunc != null) {
        this.enterFrameFunc.call(this);
      }
      this.playAnimation(ClipEvent.ENTERFRAME);
      if (this.handler != null) {
        this.handler.call("enterFrame", this);
      }
      this.postExecCount = this.lwf.execCount;
    };

    Movie.prototype.updateObject = function(obj, m, c, matrixChanged, colorTransformChanged) {
      var objc, objm;
      if (obj.isMovie && obj.property.hasMatrix) {
        objm = m;
      } else if (matrixChanged || !obj.updated || obj.matrixIdChanged) {
        objm = Utility.calcMatrixId(this.lwf, this.matrix1, m, obj.matrixId);
      } else {
        objm = null;
      }
      if (obj.isMovie && obj.property.hasColorTransform) {
        objc = c;
      } else if (colorTransformChanged || !obj.updated || obj.colorTransformIdChanged) {
        objc = Utility.calcColorTransformId(this.lwf, this.colorTransform1, c, obj.colorTransformId);
      } else {
        objc = null;
      }
      return obj.update(objm, objc);
    };

    Movie.prototype.update = function(m, c) {
      var attachName, colorTransformChanged, depth, lwfContainer, matrixChanged, movie, obj, v, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (!this.active) {
        return;
      }
      if (this.overriding) {
        matrixChanged = true;
        colorTransformChanged = true;
      } else {
        matrixChanged = this.matrix.setWithComparing(m);
        colorTransformChanged = this.colorTransform.setWithComparing(c);
      }
      if (this.handler != null) {
        this.handler.call("update", this);
      }
      if (this.property.hasMatrix) {
        matrixChanged = true;
        m = Utility.calcMatrix(this.matrix0, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      if (this.property.hasColorTransform) {
        colorTransformChanged = true;
        c = Utility.calcColorTransform(this.colorTransform0, this.colorTransform, this.property.colorTransform);
      } else {
        c = this.colorTransform;
      }
      for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          this.updateObject(obj, m, c, matrixChanged, colorTransformChanged);
        }
      }
      if ((this.attachedMovies != null) || (this.attachedLWFs != null)) {
        if (this.attachedMovies != null) {
          _ref1 = this.attachedMovieList;
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            movie = _ref1[_j];
            if (movie != null) {
              this.updateObject(movie, m, c, matrixChanged, colorTransformChanged);
            }
          }
        }
        if (this.attachedLWFs != null) {
          _ref2 = this.detachedLWFs;
          for (attachName in _ref2) {
            v = _ref2[attachName];
            lwfContainer = this.attachedLWFs[attachName];
            if (lwfContainer != null) {
              this.deleteAttachedLWF(this, lwfContainer, true, false);
            }
          }
          this.detachedLWFs = {};
          _ref3 = this.attachedLWFList;
          for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
            lwfContainer = _ref3[_k];
            if (lwfContainer != null) {
              this.lwf.renderObject(lwfContainer.child.exec(this.lwf.thisTick, m, c));
            }
          }
        }
      }
    };

    Movie.prototype.linkButton = function() {
      var depth, lwfContainer, movie, obj, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      if (!this.visible || !this.active || !this.hasButton) {
        return;
      }
      if (this.attachedLWFs != null) {
        _ref = this.attachedLWFList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          lwfContainer = _ref[_i];
          if (lwfContainer != null) {
            lwfContainer.linkButton();
          }
        }
      }
      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovieList;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          movie = _ref1[_j];
          if (movie != null ? movie.hasButton : void 0) {
            movie.linkButton();
          }
        }
      }
      for (depth = _k = 0, _ref2 = this.data.depths; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; depth = 0 <= _ref2 ? ++_k : --_k) {
        obj = this.displayList[depth];
        if (obj != null) {
          if (obj.isButton) {
            obj.linkButton();
          } else if (obj.isMovie) {
            if (obj.hasButton) {
              obj.linkButton();
            }
          }
        }
      }
    };

    Movie.prototype.render = function(v, rOffset) {
      var attachedMovie, child, depth, lwfContainer, obj, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      if (!this.visible || !this.active) {
        v = false;
      }
      if (this.handler != null) {
        this.handler.call("render", this);
      }
      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          obj.render(v, rOffset);
        }
      }
      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovieList;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          attachedMovie = _ref1[_j];
          if (attachedMovie != null) {
            attachedMovie.render(v, rOffset);
          }
        }
      }
      if (this.attachedLWFs != null) {
        _ref2 = this.attachedLWFList;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          lwfContainer = _ref2[_k];
          if (lwfContainer != null) {
            child = lwfContainer.child;
            child.setAttachVisible(v);
            this.lwf.renderObject(child.render(this.lwf.renderingIndex, this.lwf.renderingCount, rOffset));
          }
        }
      }
    };

    Movie.prototype.inspect = function(inspector, hierarchy, depth) {
      var attachedMovie, child, d, lwfContainer, obj, rOffset, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      inspector(this, hierarchy, depth, rOffset);
      ++hierarchy;
      for (d = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[d];
        if (obj != null) {
          obj.inspect(inspector, hierarchy, d, rOffset);
        }
      }
      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovieList;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          attachedMovie = _ref1[_j];
          if (attachedMovie != null) {
            attachedMovie.inspect(inspector, hierarchy, d++, rOffset);
          }
        }
      }
      if (this.attachedLWFs != null) {
        _ref2 = this.attachedLWFList;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          lwfContainer = _ref2[_k];
          if (lwfContainer != null) {
            child = lwfContainer.child;
            this.lwf.renderObject(child.inspect(inspector, hierarchy, d++, rOffset));
          }
        }
      }
    };

    Movie.prototype.destroy = function() {
      var k, lwfContainer, movie, obj, _i, _len, _ref, _ref1, _ref2;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj != null) {
          obj.destroy();
        }
      }
      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovies;
        for (k in _ref1) {
          movie = _ref1[k];
          movie.destroy();
        }
        this.attachedMovies = null;
        this.detachedMovies = null;
        this.attachedMovieList = null;
      }
      if (this.attachedLWFs != null) {
        _ref2 = this.attachedLWFs;
        for (k in _ref2) {
          lwfContainer = _ref2[k];
          this.execDetachHandler(lwfContainer);
        }
        this.attachedLWFs = null;
        this.detachedLWFs = null;
        this.attachedLWFList = null;
      }
      if (this.unloadFunc != null) {
        this.unloadFunc.call(this);
      }
      this.playAnimation(ClipEvent.UNLOAD);
      if (this.handler != null) {
        this.handler.call("unload", this);
      }
      this.instanceHead = null;
      this.instanceTail = null;
      this.displayList = null;
      this.property = null;
      Movie.__super__.destroy.apply(this, arguments);
    };

    Movie.prototype.playAnimation = function(clipEvent) {
      var c, clipEvents, i, _i, _ref;
      clipEvents = this.lwf.data.movieClipEvents;
      for (i = _i = 0, _ref = this.data.clipEvents; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = clipEvents[this.data.clipEventId + i];
        if ((c.clipEvent & clipEvent) !== 0) {
          this.lwf.playAnimation(c.animationId, this);
        }
      }
    };

    Movie.prototype.searchFrame = function(label) {
      return this.lwf.searchFrame(this, label);
    };

    Movie.prototype.gotoLabel = function(label) {
      if (typeof label === "string") {
        label = this.lwf.getStringId(label);
      }
      this.gotoFrame(this.lwf.searchFrame(this, label));
      return this;
    };

    Movie.prototype.gotoAndStop = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.stop();
      return this;
    };

    Movie.prototype.gotoAndPlay = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.play();
      return this;
    };

    Movie.prototype.searchMovieInstance = function(stringId, recursive) {
      var i, instance;
      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchMovieInstanceByInstanceId = function(instId, recursive) {
      var i, instance;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstance = function(stringId, recursive) {
      var i, instance;
      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchButtonInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstanceByInstanceId = function(instId, recursive) {
      var i, instance;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.move = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.move(x, y);
      return this;
    };

    Movie.prototype.moveTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(x, y);
      return this;
    };

    Movie.prototype.rotate = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotate(degree);
      return this;
    };

    Movie.prototype.rotateTo = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(degree);
      return this;
    };

    Movie.prototype.scale = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scale(x, y);
      return this;
    };

    Movie.prototype.scaleTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(x, y);
      return this;
    };

    Movie.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      if (scaleX == null) {
        scaleX = 1;
      }
      if (scaleY == null) {
        scaleY = 1;
      }
      if (rotation == null) {
        rotation = 0;
      }
      this.property.setMatrix(m, scalex, scaleY, rotation);
      return this;
    };

    Movie.prototype.setAlpha = function(alpha) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(alpha);
      return this;
    };

    Movie.prototype.setColorTransform = function(c) {
      this.property.setColorTransform(c);
      return this;
    };

    Movie.prototype.setRenderingOffset = function(rOffset) {
      this.property.setRenderingOffset(rOffset);
      return this;
    };

    Movie.prototype.getX = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateX;
      } else {
        return Utility.getX(this);
      }
    };

    Movie.prototype.setX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(v, this.property.matrix.translateY);
    };

    Movie.prototype.getY = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateY;
      } else {
        return Utility.getY(this);
      }
    };

    Movie.prototype.setY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(this.property.matrix.translateX, v);
    };

    Movie.prototype.getScaleX = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleX;
      } else {
        return Utility.getScaleX(this);
      }
    };

    Movie.prototype.setScaleX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(v, this.property.scaleY);
    };

    Movie.prototype.getScaleY = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleY;
      } else {
        return Utility.getScaleY(this);
      }
    };

    Movie.prototype.setScaleY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(this.property.scaleX, v);
    };

    Movie.prototype.getRotation = function() {
      if (this.property.hasMatrix) {
        return this.property.rotation;
      } else {
        return Utility.getRotation(this);
      }
    };

    Movie.prototype.setRotation = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(v);
    };

    Movie.prototype.getAlphaProperty = function() {
      if (this.property.hasColorTransform) {
        return this.property.colorTransform.multi.alpha;
      } else {
        return Utility.getAlpha(this);
      }
    };

    Movie.prototype.setAlphaProperty = function(v) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(v);
    };

    return Movie;

  })(IObject);

  EventHandlers = (function() {

    function EventHandlers() {
      this.clear();
    }

    EventHandlers.prototype.clear = function(type) {
      var _i, _len, _ref;
      if (type == null) {
        type = null;
      }
      if (type != null) {
        if (this[type] != null) {
          this[type] = [];
        }
      } else {
        _ref = this.types;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          type = _ref[_i];
          this[type] = [];
        }
      }
    };

    EventHandlers.prototype.add = function(handlers) {
      var handler, type, _i, _len, _ref;
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        handler = handlers[type];
        if (handler != null) {
          this[type].push(handler);
        }
      }
    };

    EventHandlers.prototype.removeHandler = function(array, handler) {
      var i;
      i = 0;
      while (i < array.length) {
        if (array[i] === handler) {
          array.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    EventHandlers.prototype.remove = function(handlers) {
      var handler, type, _i, _len, _ref;
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        handler = handlers[type];
        if (handler != null) {
          this.removeHandler(this[type], handler);
        }
      }
    };

    EventHandlers.prototype.call = function(type, target) {
      var handler, handlers, _i, _len;
      handlers = this[type];
      if (handlers != null) {
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          handler.call(target);
        }
      }
    };

    return EventHandlers;

  })();

  MovieEventHandlers = (function(_super) {
    var TYPES;

    __extends(MovieEventHandlers, _super);

    TYPES = ["load", "postLoad", "unload", "enterFrame", "update", "render"];

    function MovieEventHandlers() {
      this.types = TYPES;
      MovieEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return MovieEventHandlers;

  })(EventHandlers);

  ButtonEventHandlers = (function(_super) {
    var TYPES;

    __extends(ButtonEventHandlers, _super);

    TYPES = ["load", "unload", "enterFrame", "update", "render", "press", "release", "rollOver", "rollOut", "keyPress"];

    function ButtonEventHandlers() {
      this.types = TYPES;
      ButtonEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return ButtonEventHandlers;

  })(EventHandlers);

  LWF = (function() {
    var ROUND_OFF_TICK_RATE;

    ROUND_OFF_TICK_RATE = 0.05;

    function LWF(lwfData, rendererFactory, embeddedScript, privateData) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (embeddedScript == null) {
        embeddedScript = null;
      }
      this.privateData = privateData != null ? privateData : null;
      this.data = lwfData;
      if (embeddedScript != null) {
        this.functions = embeddedScript();
      }
      this.width = this.data.header.width;
      this.height = this.data.header.height;
      this.backgroundColor = this.data.header.backgroundColor;
      this.name = this.data.strings[this.data.header.nameStringId];
      this.interactive = this.data.buttonConditions.length > 0;
      this.url = null;
      this.frameRate = this.data.header.frameRate;
      this.execLimit = 3;
      this.tick = 1.0 / this.frameRate;
      this.roundOffTick = this.tick * ROUND_OFF_TICK_RATE;
      this.time = 0;
      this.thisTick = 0;
      this.attachVisible = true;
      this.execCount = 0;
      this.isExecDisabled = false;
      this.isPropertyDirty = false;
      this.isLWFAttached = false;
      this.interceptByNotAllowOrDenyButtons = true;
      this.intercepted = false;
      this.scaleByStage = 1;
      this.pointX = Number.MIN_VALUE;
      this.pointY = Number.MIN_VALUE;
      this.pressing = false;
      this.buttonHead = null;
      if (!this.interactive && this.data.frames.length === 1) {
        this.disableExec();
      }
      this.property = new Property(this);
      this.instances = [];
      this.execHandlers = null;
      this.eventHandlers = [];
      this.movieEventHandlers = [];
      this.buttonEventHandlers = [];
      this.movieCommands = {};
      this.programObjectConstructors = [];
      this.parent = null;
      this.attachName = null;
      this.depth = null;
      this.matrix = new Matrix;
      this.matrixIdentity = new Matrix;
      this.colorTransform = new ColorTransform;
      this.colorTransformIdentity = new ColorTransform;
      this.init();
      this.setRendererFactory(rendererFactory);
    }

    LWF.prototype.setRendererFactory = function(rendererFactory) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (rendererFactory == null) {
        rendererFactory = new NullRendererFactory();
      }
      this.rendererFactory = rendererFactory;
      this.rendererFactory.init(this);
    };

    LWF.prototype.setFrameRate = function(frameRate) {
      if (frameRate === 0) {
        return;
      }
      this.frameRate = frameRate;
      this.tick = 1.0 / this.frameRate;
    };

    LWF.prototype.setPreferredFrameRate = function(preferredFrameRate, execLimit) {
      if (execLimit == null) {
        execLimit = 2;
      }
      if (frameRate === 0) {
        return;
      }
      this.execLimit = Math.ceil(this.frameRate / preferredFrameRate) + execLimit;
    };

    LWF.prototype.fitForHeight = function(stageWidth, stageHeight) {
      Utility.fitForHeight(this, stageWidth, stageHeight);
    };

    LWF.prototype.fitForWidth = function(stageWidth, stageHeight) {
      Utility.fitForWidth(this, stageWidth, stageHeight);
    };

    LWF.prototype.scaleForHeight = function(stageHeight) {
      Utility.scaleForHeight(this, stageHeight);
    };

    LWF.prototype.scaleForWidth = function(stageWidth) {
      Utility.scaleForWidth(this, stageWidth);
    };

    LWF.prototype.renderOffset = function() {
      this.renderingIndexOffsetted = 0;
    };

    LWF.prototype.clearRenderOffset = function() {
      this.renderingIndexOffsetted = this.renderingIndex;
    };

    LWF.prototype.renderObject = function(count) {
      if (count == null) {
        count = 1;
      }
      this.renderingIndex += count;
      this.renderingIndexOffsetted += count;
      return this.renderingIndex;
    };

    LWF.prototype.setAttachVisible = function(visible) {
      this.attachVisible = visible;
    };

    LWF.prototype.clearFocus = function(button) {
      if (this.focus === button) {
        this.focus = null;
      }
    };

    LWF.prototype.clearIntercepted = function() {
      this.intercepted = false;
    };

    LWF.prototype.init = function() {
      this.time = 0;
      this.progress = 0;
      this.instances = [];
      this.focus = null;
      this.movieCommands = {};
      this.rootMovieStringId = this.getStringId("_root");
      if (this.rootMovie != null) {
        this.rootMovie.destroy();
      }
      this.rootMovie = new Movie(this, null, this.data.header.rootMovieId, this.searchInstanceId(this.rootMovieStringId));
    };

    LWF.prototype.calcMatrix = function(matrix) {
      var m, p;
      p = this.property;
      if (p.hasMatrix) {
        if (matrix != null) {
          m = Utility.calcMatrix(this.matrix, matrix, p.matrix);
        } else {
          m = p.matrix;
        }
      } else {
        m = matrix != null ? matrix : this.matrixIdentity;
      }
      return m;
    };

    LWF.prototype.calcColorTransform = function(colorTransform) {
      var c, p;
      p = this.property;
      if (p.hasColorTransform) {
        if (colorTransform != null) {
          c = Utility.calcColorTransform(this.colorTransform, colorTransform, p.colorTransform);
        } else {
          c = p.colorTransform;
        }
      } else {
        c = colorTransform != null ? colorTransform : this.colorTransformIdentity;
      }
      return c;
    };

    LWF.prototype.exec = function(tick, matrix, colorTransform) {
      var currentProgress, execLimit, execed, handler, handlers, progressing, _i, _len;
      if (tick == null) {
        tick = 0;
      }
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      execed = false;
      currentProgress = this.progress;
      if (this.isExecDisabled) {
        if (!this.executedForExecDisabled) {
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(true);
          this.executedForExecDisabled = true;
          execed = true;
        }
      } else {
        progressing = true;
        this.thisTick = tick;
        if (tick === 0) {
          this.progress = this.tick;
        } else if (tick < 0) {
          this.progress = this.tick;
          progressing = false;
        } else {
          if (this.time === 0) {
            this.time += this.tick;
            this.progress += this.tick;
          } else {
            this.time += tick;
            this.progress += tick;
          }
        }
        handlers = this.execHandlers;
        if (handlers != null) {
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            handler.call(this);
          }
        }
        execLimit = this.execLimit;
        while (this.progress >= this.tick - this.roundOffTick) {
          if (--execLimit < 0) {
            this.progress = 0;
            break;
          }
          this.progress -= this.tick;
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(progressing);
          execed = true;
        }
        if (this.progress < this.roundOffTick) {
          this.progress = 0;
        }
        this.buttonHead = null;
        if (this.interactive && this.rootMovie.hasButton) {
          this.rootMovie.linkButton();
        }
      }
      if (execed || this.isLWFAttached || this.isPropertyDirty || (matrix != null) || (colorTransform != null)) {
        this.update(matrix, colorTransform);
      }
      if (!this.execDisabled) {
        if (tick < 0) {
          this.progress = currentProgress;
        }
      }
      return this.renderingCount;
    };

    LWF.prototype.forceExec = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(0, matrix, colorTransform);
    };

    LWF.prototype.forceExecWithoutProgress = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(-1, matrix, colorTransform);
    };

    LWF.prototype.update = function(matrix, colorTransform) {
      var c, m;
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      m = this.calcMatrix(matrix);
      c = this.calcColorTransform(colorTransform);
      this.renderingIndex = 0;
      this.renderingIndexOffsetted = 0;
      this.rootMovie.update(m, c);
      this.renderingCount = this.renderingIndex;
      this.thisTick = 0;
      this.isPropertyDirty = false;
    };

    LWF.prototype.render = function(rIndex, rCount, rOffset) {
      var renderingCountBackup;
      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      renderingCountBackup = this.renderingCount;
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rendererFactory.beginRender(this);
      this.rootMovie.render(this.attachVisible, rOffset);
      this.rendererFactory.endRender(this);
      this.renderingCount = renderingCountBackup;
      return this.renderingCount;
    };

    LWF.prototype.inspect = function(inspector, hierarchy, depth, rIndex, rCount, rOffset) {
      var renderingCountBackup;
      if (hierarchy == null) {
        hierarchy = 0;
      }
      if (depth == null) {
        depth = 0;
      }
      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      renderingCountBackup = this.renderingCount;
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rootMovie.inspect(inspector, hierarchy, depth, rOffset);
      this.renderingCount = renderingCountBackup;
      return this.renderingCount;
    };

    LWF.prototype.destroy = function() {
      var func, resourceCache, _ref;
      if (this.stopTweens != null) {
        this.stopTweens();
      }
      this.rootMovie.destroy();
      this.rootMovie = null;
      func = (_ref = this.functions) != null ? _ref['destroy'] : void 0;
      if (func != null) {
        func.call(this);
      }
      this.functions = null;
      if (this.rendererFactory != null) {
        resourceCache = this.rendererFactory.resourceCache;
        if (resourceCache != null) {
          resourceCache.unloadLWF(this);
        }
        this.rendererFactory.destruct();
        this.rendererFactory = null;
      }
      this.property = null;
      this.buttonHead = null;
      this.instances = null;
      this.execHandlers = null;
      this.eventHandlers = null;
      this.movieEventHandlers = null;
      this.buttonEventHandlers = null;
      this.movieCommands = null;
      this.programObjectConstructors = null;
    };

    LWF.prototype.getInstanceNameStringId = function(instId) {
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return -1;
      } else {
        return this.data.instanceNames[instId].stringId;
      }
    };

    LWF.prototype.getStringId = function(str) {
      var i;
      i = this.data.stringMap[str];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchInstanceId = function(stringId) {
      var i;
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.instanceNameMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchFrame = function(movie, stringId) {
      var frameNo;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      frameNo = this.data.labelMap[movie.objectId][stringId];
      if (frameNo != null) {
        return frameNo + 1;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLabels = function(movie) {
      if (movie == null) {
        return null;
      }
      return this.data.labelMap[movie.objectId];
    };

    LWF.prototype.searchMovieLinkage = function(stringId) {
      var i;
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.movieLinkageMap[stringId];
      if (i != null) {
        return this.data.movieLinkages[i].movieId;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLinkageName = function(movieId) {
      var i;
      i = this.data.movieLinkageNameMap[movieId];
      if (i != null) {
        return this.data.strings[i];
      } else {
        return null;
      }
    };

    LWF.prototype.searchMovieInstance = function(stringId) {
      var instanceName, m, name, names, _i, _len;
      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            m = m.searchMovieInstance(name, false);
            if (m == null) {
              return null;
            }
          }
          return m;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchMovieInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchMovieInstanceByInstanceId = function(instId) {
      var obj;
      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isMovie) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchButtonInstance = function(stringId) {
      var i, instanceName, m, names, _i, _ref;
      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (i = _i = 1, _ref = names.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
            if (i === names.length - 1) {
              return m.searchButtonInstance(names[i], false);
            } else {
              m = m.searchButtonInstance(names[i], false);
              if (m == null) {
                return null;
              }
            }
          }
          return null;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchButtonInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchButtonInstanceByInstanceId = function(instId) {
      var obj;
      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isButton) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchEventId = function(stringId) {
      var i;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.eventMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchProgramObjectId = function(stringId) {
      var i;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.programObjectMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.getInstance = function(instId) {
      return this.instances[instId];
    };

    LWF.prototype.setInstance = function(instId, instance) {
      this.instances[instId] = instance;
    };

    LWF.prototype.addExecHandler = function(execHandler) {
      var _ref;
      if ((_ref = this.execHandlers) == null) {
        this.execHandlers = [];
      }
      this.execHandlers.push(execHandler);
    };

    LWF.prototype.removeExecHandler = function(execHandler) {
      var handlers, i;
      handlers = this.execHandlers;
      if (handlers == null) {
        return;
      }
      i = 0;
      while (i < handlers.length) {
        if (handlers[i] === execHandler) {
          handlers.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    LWF.prototype.clearExecHandler = function() {
      this.execHandlers = null;
    };

    LWF.prototype.setExecHandler = function(execHandler) {
      this.clearExecHandler();
      this.addExecHandler(execHandler);
    };

    LWF.prototype.addEventHandler = function(eventId, eventHandler) {
      var _base, _ref;
      if (typeof eventId === "string") {
        eventId = this.searchEventId(eventId);
      }
      if (eventId < 0 || eventId >= this.data.events.length) {
        return;
      }
      if ((_ref = (_base = this.eventHandlers)[eventId]) == null) {
        _base[eventId] = [];
      }
      this.eventHandlers[eventId].push(eventHandler);
    };

    LWF.prototype.removeEventHandler = function(eventId, eventHandler) {
      var handlers, i;
      if (typeof eventId === "string") {
        eventId = this.searchEventId(eventId);
      }
      if (eventId < 0 || eventId >= this.data.events.length) {
        return;
      }
      handlers = this.eventHandlers[eventId];
      if (handlers == null) {
        return;
      }
      i = 0;
      while (i < handlers.length) {
        if (handlers[i] === eventHandler) {
          handlers.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    LWF.prototype.clearEventHandler = function(eventId) {
      if (typeof eventId === "string") {
        eventId = this.searchEventId(eventId);
      }
      if (eventId < 0 || eventId >= this.data.events.length) {
        return;
      }
      this.eventHandlers[eventId] = null;
    };

    LWF.prototype.setEventHandler = function(eventId, eventHandler) {
      this.clearEventHandler(eventId);
      this.addEventHandler(eventId, eventHandler);
    };

    LWF.prototype.getProgramObjectConstructor = function(programObjectId) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return null;
      }
      return this.programObjectConstructors[programObjectId];
    };

    LWF.prototype.setProgramObjectConstructor = function(programObjectId, programObjectConstructor) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return;
      }
      this.programObjectConstructors[programObjectId] = programObjectConstructor;
    };

    LWF.prototype.getMovieEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;
      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.movieEventHandlers[instId];
        } else {
          if (this.movieEventHandlersByFullName == null) {
            return null;
          }
          return this.movieEventHandlersByFullName[instanceName];
        }
      }
      if (this.movieEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.movieEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.movieEventHandlers[m.instanceId];
    };

    LWF.prototype.addMovieEventHandler = function(instanceName, handlers) {
      var h, instId, movie, _ref;
      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.movieEventHandlers[instId];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlers[instId] = h;
        }
        movie = this.searchMovieInstanceByInstanceId(instId);
        if (movie != null) {
          movie.setHandlers(h);
        }
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if ((_ref = this.movieEventHandlersByFullName) == null) {
          this.movieEventHandlersByFullName = [];
        }
        h = this.movieEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlersByFullName[instanceName] = h;
        }
        movie = this.searchMovieInstance(instanceName);
        if (movie != null) {
          movie.setHandlers(h);
        }
      }
      h.add(handlers);
    };

    LWF.prototype.removeMovieEventHandler = function(instanceName, handlers) {
      var h;
      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
    };

    LWF.prototype.clearMovieEventHandler = function(instanceName, type) {
      var h;
      if (type == null) {
        type = null;
      }
      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
    };

    LWF.prototype.setMovieEventHandler = function(instanceName, handlers) {
      this.clearMovieEventHandler(instanceName);
      this.addMovieEventHandler(instanceName, handlers);
    };

    LWF.prototype.getButtonEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;
      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.buttonEventHandlers[instId];
        } else {
          if (this.buttonEventHandlersByFullName == null) {
            return null;
          }
          return this.buttonEventHandlersByFullName[instanceName];
        }
      }
      if (this.buttonEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.buttonEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.buttonEventHandlers[m.instanceId];
    };

    LWF.prototype.addButtonEventHandler = function(instanceName, handlers) {
      var button, h, instId, _ref;
      this.interactive = true;
      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.buttonEventHandlers[instId];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlers[instId] = h;
        }
        button = this.searchButtonInstanceByInstanceId(instId);
        if (button != null) {
          button.setHandlers(h);
        }
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if ((_ref = this.buttonEventHandlersByFullName) == null) {
          this.buttonEventHandlersByFullName = [];
        }
        h = this.buttonEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlersByFullName[instanceName] = h;
        }
        button = this.searchButtonInstance(instanceName);
        if (typeof movie !== "undefined" && movie !== null) {
          button.setHandlers(h);
        }
      }
      h.add(handlers);
    };

    LWF.prototype.removeButtonEventHandler = function(instanceName, handlers) {
      var h;
      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
    };

    LWF.prototype.clearButtonEventHandler = function(instanceName, type) {
      var h;
      if (type == null) {
        type = null;
      }
      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
    };

    LWF.prototype.setButtonEventHandler = function(instanceName, handlers) {
      this.clearButtonEventHandler(instanceName);
      this.addButtonEventHandler(instanceName, handlers);
    };

    LWF.prototype.execMovieCommand = function() {
      var available, deletes, k, movie, name, v, _i, _j, _len, _len1, _ref;
      deletes = [];
      _ref = this.movieCommands;
      for (k in _ref) {
        v = _ref[k];
        available = true;
        movie = this.rootMovie;
        for (_i = 0, _len = k.length; _i < _len; _i++) {
          name = k[_i];
          movie = movie.searchMovieInstance(name);
          if (movie == null) {
            available = false;
            break;
          }
        }
        if (available) {
          v(movie);
          deletes.push(k);
        }
      }
      for (_j = 0, _len1 = deletes.length; _j < _len1; _j++) {
        k = deletes[_j];
        delete this.movieCommands[k];
      }
    };

    LWF.prototype.setMovieCommand = function(instanceNames, cmd) {
      var names;
      names = instanceNames.slice(0);
      this.movieCommands[names] = cmd;
      this.execMovieCommand();
    };

    LWF.prototype.searchAttachedMovie = function(attachName) {
      return this.rootMovie.searchAttachedMovie(attachName);
    };

    LWF.prototype.searchAttachedLWF = function(attachName) {
      return this.rootMovie.searchAttachedLWF(attachName);
    };

    LWF.prototype.addAllowButton = function(buttonName) {
      var instId;
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.allowButtonList == null) {
        this.allowButtonList = {};
      }
      this.allowButtonList[instId] = true;
      return true;
    };

    LWF.prototype.removeAllowButton = function(buttonName) {
      var instId;
      if (this.allowButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.allowButtonList[instId];
      return true;
    };

    LWF.prototype.clearAllowButton = function() {
      this.allowButtonList = null;
    };

    LWF.prototype.addDenyButton = function(buttonName) {
      var instId;
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      this.denyButtonList[instId] = true;
      return true;
    };

    LWF.prototype.denyAllButtons = function() {
      var instId, _i, _ref;
      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      for (instId = _i = 0, _ref = this.data.instanceNames.length; 0 <= _ref ? _i < _ref : _i > _ref; instId = 0 <= _ref ? ++_i : --_i) {
        this.denyButtonList[instId] = true;
      }
    };

    LWF.prototype.removeDenyButton = function(buttonName) {
      var instId;
      if (this.denyButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.denyButtonList[instId];
      return true;
    };

    LWF.prototype.clearDenyButton = function() {
      this.denyButtonList = null;
    };

    LWF.prototype.disableExec = function() {
      this.isExecDisabled = true;
      this.executedForExecDisabled = false;
    };

    LWF.prototype.enableExec = function() {
      this.isExecDisabled = false;
    };

    LWF.prototype.setPropertyDirty = function() {
      this.isPropertyDirty = true;
      if (this.parent != null) {
        this.parent.lwf.setPropertyDirty();
      }
    };

    LWF.prototype.getMovieFunctions = function(movieId) {
      var enterFrameFunc, linkageName, loadFunc, postLoadFunc, unloadFunc, _ref, _ref1, _ref2, _ref3;
      linkageName = this.getMovieLinkageName(movieId);
      loadFunc = (_ref = this.functions) != null ? _ref[linkageName + "_load"] : void 0;
      postLoadFunc = (_ref1 = this.functions) != null ? _ref1[linkageName + "_postLoad"] : void 0;
      unloadFunc = (_ref2 = this.functions) != null ? _ref2[linkageName + "_unload"] : void 0;
      enterFrameFunc = (_ref3 = this.functions) != null ? _ref3[linkageName + "_enterFrame"] : void 0;
      return [loadFunc, postLoadFunc, unloadFunc, enterFrameFunc];
    };

    LWF.prototype.playAnimation = function(animationId, movie, button) {
      var a, animations, count, eventId, func, i, instId, j, stringId, target, _i, _ref;
      i = 0;
      animations = this.data.animations[animationId];
      target = movie;
      while (true) {
        a = animations[i++];
        switch (a) {
          case Animation.END:
            return;
          case Animation.PLAY:
            target.play();
            break;
          case Animation.STOP:
            target.stop();
            break;
          case Animation.GOTONEXTFRAME:
            target.gotoNextFrame();
            break;
          case Animation.GOTOPREVFRAME:
            target.gotoPrevFrame();
            break;
          case Animation.GOTOFRAME:
            target.gotoFrameInternal(animations[i++]);
            break;
          case Animation.GOTOLABEL:
            target.gotoFrame(this.searchFrame(target, animations[i++]));
            break;
          case Animation.SETTARGET:
            target = movie;
            count = animations[i++];
            if (count !== 0) {
              for (j = _i = 0; 0 <= count ? _i < count : _i > count; j = 0 <= count ? ++_i : --_i) {
                instId = animations[i++];
                switch (instId) {
                  case Animation.INSTANCE_TARGET_ROOT:
                    target = this.rootMovie;
                    break;
                  case Animation.INSTANCE_TARGET_PARENT:
                    target = target.parent;
                    if (this.target == null) {
                      target = this.rootMovie;
                    }
                    break;
                  default:
                    target = target.searchMovieInstanceByInstanceId(instId, false);
                    if (target == null) {
                      target = movie;
                    }
                }
              }
            }
            break;
          case Animation.EVENT:
            eventId = animations[i++];
            this.dispatchEvent(eventId, movie, button);
            break;
          case Animation.CALL:
            stringId = animations[i++];
            func = (_ref = this.functions) != null ? _ref[this.data.strings[stringId]] : void 0;
            if (func != null) {
              func.call(movie);
            }
        }
      }
    };

    LWF.prototype.dispatchEvent = function(eventId, movie, button) {
      var handler, handlers, _i, _len;
      if (movie == null) {
        movie = this.rootMovie;
      }
      if (button == null) {
        button = null;
      }
      handlers = this.eventHandlers[eventId];
      if (handlers == null) {
        return false;
      }
      for (_i = 0, _len = handlers.length; _i < _len; _i++) {
        handler = handlers[_i];
        handler(movie, button);
      }
      return true;
    };

    LWF.prototype.inputPoint = function(x, y) {
      var button, found;
      this.intercepted = false;
      if (!this.interactive) {
        return null;
      }
      this.pointX = x;
      this.pointY = y;
      found = false;
      button = this.buttonHead;
      while (button != null) {
        if (button.checkHit(x, y)) {
          if (this.allowButtonList != null) {
            if (this.allowButtonList[button.instanceId] == null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          } else if (this.denyButtonList != null) {
            if (this.denyButtonList[button.instanceId] != null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          }
          found = true;
          if (this.focus !== button) {
            if (this.focus != null) {
              this.focus.rollOut();
            }
            this.focus = button;
            this.focus.rollOver();
          }
          break;
        }
        button = button.buttonLink;
      }
      if (!found && (this.focus != null)) {
        this.focus.rollOut();
        this.focus = null;
      }
      return this.focus;
    };

    LWF.prototype.inputPress = function() {
      if (!this.interactive) {
        return;
      }
      this.pressing = true;
      if (this.focus != null) {
        this.focus.press();
      }
    };

    LWF.prototype.inputRelease = function() {
      if (!this.interactive) {
        return;
      }
      this.pressing = false;
      if (this.focus != null) {
        this.focus.release();
      }
    };

    LWF.prototype.inputKeyPress = function(code) {
      var button;
      if (!this.interactive) {
        return;
      }
      button = this.buttonHead;
      while (button != null) {
        button.keyPress(code);
        button = button.buttonLink;
      }
    };

    return LWF;

  })();

  if (typeof global !== "undefined") {
    if ((_ref = global["LWF"]) == null) {
      global["LWF"] = {};
    }
    global["LWF"]["Color"] = Color;
    global["LWF"]["ColorTransform"] = ColorTransform;
    global["LWF"]["Format"] = Format;
    global["LWF"]["LWF"] = LWF;
    global["LWF"]["Loader"] = Loader;
    global["LWF"]["Matrix"] = Matrix;
    global["LWF"]["Movie"] = Movie;
    global["LWF"]["Point"] = Point;
    global["LWF"]["Property"] = Property;
  }

  LWF.prototype["addAllowButton"] = LWF.prototype.addAllowButton;

  LWF.prototype["addButtonEventHandler"] = LWF.prototype.addButtonEventHandler;

  LWF.prototype["addDenyButton"] = LWF.prototype.addDenyButton;

  LWF.prototype["addEventHandler"] = LWF.prototype.addEventHandler;

  LWF.prototype["addMovieEventHandler"] = LWF.prototype.addMovieEventHandler;

  LWF.prototype["clearAllowButton"] = LWF.prototype.clearAllowButton;

  LWF.prototype["clearButtonEventHandler"] = LWF.prototype.clearButtonEventHandler;

  LWF.prototype["clearDenyButton"] = LWF.prototype.clearDenyButton;

  LWF.prototype["clearEventHandler"] = LWF.prototype.clearEventHandler;

  LWF.prototype["clearMovieEventHandler"] = LWF.prototype.clearMovieEventHandler;

  LWF.prototype["denyAllButtons"] = LWF.prototype.denyAllButtons;

  LWF.prototype["destroy"] = LWF.prototype.destroy;

  LWF.prototype["exec"] = LWF.prototype.exec;

  LWF.prototype["fitForHeight"] = LWF.prototype.fitForHeight;

  LWF.prototype["fitForWidth"] = LWF.prototype.fitForWidth;

  LWF.prototype["forceExec"] = LWF.prototype.forceExec;

  LWF.prototype["forceExecWithoutProgress"] = LWF.prototype.forceExecWithoutProgress;

  LWF.prototype["getStringId"] = LWF.prototype.getStringId;

  LWF.prototype["init"] = LWF.prototype.init;

  LWF.prototype["inputKeyPress"] = LWF.prototype.inputKeyPress;

  LWF.prototype["inputPoint"] = LWF.prototype.inputPoint;

  LWF.prototype["inputPress"] = LWF.prototype.inputPress;

  LWF.prototype["inputRelease"] = LWF.prototype.inputRelease;

  LWF.prototype["inspect"] = LWF.prototype.inspect;

  LWF.prototype["removeAllowButton"] = LWF.prototype.removeAllowButton;

  LWF.prototype["removeButtonEventHandler"] = LWF.prototype.removeButtonEventHandler;

  LWF.prototype["removeDenyButton"] = LWF.prototype.removeDenyButton;

  LWF.prototype["removeEventHandler"] = LWF.prototype.removeEventHandler;

  LWF.prototype["removeMovieEventHandler"] = LWF.prototype.removeMovieEventHandler;

  LWF.prototype["render"] = LWF.prototype.render;

  LWF.prototype["scaleForHeight"] = LWF.prototype.scaleForHeight;

  LWF.prototype["scaleForWidth"] = LWF.prototype.scaleForWidth;

  LWF.prototype["searchAttachedLWF"] = LWF.prototype.searchAttachedLWF;

  LWF.prototype["searchAttachedMovie"] = LWF.prototype.searchAttachedMovie;

  LWF.prototype["searchEventId"] = LWF.prototype.searchEventId;

  LWF.prototype["searchFrame"] = LWF.prototype.searchFrame;

  LWF.prototype["setButtonEventHandler"] = LWF.prototype.setButtonEventHandler;

  LWF.prototype["setEventHandler"] = LWF.prototype.setEventHandler;

  LWF.prototype["setFrameRate"] = LWF.prototype.setFrameRate;

  LWF.prototype["setMovieCommand"] = LWF.prototype.setMovieCommand;

  LWF.prototype["setMovieEventHandler"] = LWF.prototype.setMovieEventHandler;

  LWF.prototype["setProgramObjectConstructor"] = LWF.prototype.setProgramObjectConstructor;

  LWF.prototype["setRendererFactory"] = LWF.prototype.setRendererFactory;

  Loader["load"] = Loader.load;

  Data.prototype["check"] = Data.prototype.check;

  Data.prototype["name"] = Data.prototype.name;

  IObject.prototype["getFullName"] = IObject.prototype.getFullName;

  Movie.prototype["attachLWF"] = Movie.prototype.attachLWF;

  Movie.prototype["attachMovie"] = Movie.prototype.attachMovie;

  Movie.prototype["detachFromParent"] = Movie.prototype.detachFromParent;

  Movie.prototype["detachLWF"] = Movie.prototype.detachLWF;

  Movie.prototype["detachMovie"] = Movie.prototype.detachMovie;

  Movie.prototype["getAttachedLWF"] = Movie.prototype.getAttachedLWF;

  Movie.prototype["getAttachedMovie"] = Movie.prototype.getAttachedMovie;

  Movie.prototype["globalToLocal"] = Movie.prototype.globalToLocal;

  Movie.prototype["gotoAndPlay"] = Movie.prototype.gotoAndPlay;

  Movie.prototype["gotoAndStop"] = Movie.prototype.gotoAndStop;

  Movie.prototype["gotoFrame"] = Movie.prototype.gotoFrame;

  Movie.prototype["gotoLabel"] = Movie.prototype.gotoLabel;

  Movie.prototype["gotoNextFrame"] = Movie.prototype.gotoNextFrame;

  Movie.prototype["gotoPrevFrame"] = Movie.prototype.gotoPrevFrame;

  Movie.prototype["inspect"] = Movie.prototype.inspect;

  Movie.prototype["localToGlobal"] = Movie.prototype.localToGlobal;

  Movie.prototype["move"] = Movie.prototype.move;

  Movie.prototype["moveTo"] = Movie.prototype.moveTo;

  Movie.prototype["override"] = Movie.prototype.override;

  Movie.prototype["play"] = Movie.prototype.play;

  Movie.prototype["rotate"] = Movie.prototype.rotate;

  Movie.prototype["rotateTo"] = Movie.prototype.rotateTo;

  Movie.prototype["scale"] = Movie.prototype.scale;

  Movie.prototype["scaleTo"] = Movie.prototype.scaleTo;

  Movie.prototype["searchAttachedLWF"] = Movie.prototype.searchAttachedLWF;

  Movie.prototype["searchAttachedMovie"] = Movie.prototype.searchAttachedMovie;

  Movie.prototype["searchMovieInstance"] = Movie.prototype.searchMovieInstance;

  Movie.prototype["searchMovieInstanceByInstanceId"] = Movie.prototype.searchMovieInstanceByInstanceId;

  Movie.prototype["setAlpha"] = Movie.prototype.setAlpha;

  Movie.prototype["setColorTransform"] = Movie.prototype.setColorTransform;

  Movie.prototype["setMatrix"] = Movie.prototype.setMatrix;

  Movie.prototype["setRenderingOffset"] = Movie.prototype.setRenderingOffset;

  Movie.prototype["setVisible"] = Movie.prototype.setVisible;

  Movie.prototype["stop"] = Movie.prototype.stop;

  Movie.prototype["swapAttachedLWFDepth"] = Movie.prototype.swapAttachedLWFDepth;

  Movie.prototype["swapAttachedMovieDepth"] = Movie.prototype.swapAttachedMovieDepth;

  Property.prototype["clear"] = Property.prototype.clear;

  Property.prototype["move"] = Property.prototype.move;

  Property.prototype["moveTo"] = Property.prototype.moveTo;

  Property.prototype["rotate"] = Property.prototype.rotate;

  Property.prototype["rotateTo"] = Property.prototype.rotateTo;

  Property.prototype["scale"] = Property.prototype.scale;

  Property.prototype["scaleTo"] = Property.prototype.scaleTo;

  Property.prototype["setAlpha"] = Property.prototype.setAlpha;

  Property.prototype["setColorTransform"] = Property.prototype.setColorTransform;

  Property.prototype["setMatrix"] = Property.prototype.setMatrix;

  Matrix.prototype["clear"] = Matrix.prototype.clear;

  Matrix.prototype["set"] = Matrix.prototype.set;

  Color.prototype["set"] = Color.prototype.set;

  ColorTransform.prototype["clear"] = ColorTransform.prototype.clear;

  ColorTransform.prototype["set"] = ColorTransform.prototype.set;

  WebkitCSSRendererFactory = (function() {

    function WebkitCSSRendererFactory(data, resourceCache, cache, stage, textInSubpixel, use3D) {
      var bitmap, bitmapEx, computedStyle, h, style, text, w, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.use3D = use3D;
      this.bitmapContexts = [];
      _ref1 = data.bitmaps;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bitmap = _ref1[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        this.bitmapContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref2 = data.bitmapExs;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        bitmapEx = _ref2[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref3 = data.texts;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        text = _ref3[_k];
        this.textContexts.push(new WebkitCSSTextContext(this, data, text));
      }
      style = this.stage.style;
      style.display = "block";
      style.position = "absolute";
      style.overflow = "hidden";
      style.webkitUserSelect = "none";
      if (this.use3D) {
        style.webkitTransform = "translateZ(0)";
        style.webkitTransformStyle = "preserve-3d";
      }
      computedStyle = window.getComputedStyle(this.stage, "");
      h = computedStyle.getPropertyValue("height");
      w = computedStyle.getPropertyValue("width");
      if (h === "0px" && w === "0px") {
        style.width = "" + data.header.width + "px";
        style.height = "" + data.header.height + "px";
      }
      this.commands = [];
    }

    WebkitCSSRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      _ref1 = this.bitmapContexts;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        context = _ref1[_i];
        context.destruct();
      }
      _ref2 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        context = _ref2[_j];
        context.destruct();
      }
      _ref3 = this.textContexts;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        context = _ref3[_k];
        context.destruct();
      }
    };

    WebkitCSSRendererFactory.prototype.init = function(lwf) {
      var domName, m, name, progObj, _i, _len, _ref1, _results,
        _this = this;
      lwf.stage = this.stage;
      lwf.resourceCache = this.resourceCache;
      if (this.setupedDomElementConstructor) {
        return;
      }
      this.setupedDomElementConstructor = true;
      _ref1 = lwf.data.programObjects;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        progObj = _ref1[_i];
        name = lwf.data.strings[progObj.stringId];
        m = name.match(/^DOM_(.*)/);
        if (m != null) {
          domName = m[1];
          _results.push((function(domName) {
            return lwf.setProgramObjectConstructor(name, function(lwf_, objId, w, h) {
              var ctor, domElement;
              ctor = _this.resourceCache.domElementConstructor;
              if (ctor == null) {
                return null;
              }
              domElement = ctor(lwf_, domName, w, h);
              if (domElement == null) {
                return null;
              }
              return new WebkitCSSDomElementRenderer(_this, domElement);
            });
          })(domName));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WebkitCSSRendererFactory.prototype.beginRender = function(lwf) {};

    WebkitCSSRendererFactory.prototype.endRender = function(lwf) {
      var c, command, m, renderer, scaleX, scaleY, skew0, skew1, style, translateX, translateY, _i, _len, _ref1;
      _ref1 = this.commands;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        command = _ref1[_i];
        renderer = command.renderer;
        style = renderer.node.style;
        if (!command.isBitmap) {
          c = renderer.color;
          style.color = "rgb(" + c.red + "," + c.green + "," + c.blue + ")";
        }
        style.zIndex = renderer.zIndex;
        style.opacity = renderer.alpha;
        m = command.matrix;
        scaleX = m.scaleX.toFixed(12);
        scaleY = m.scaleY.toFixed(12);
        skew1 = m.skew1.toFixed(12);
        skew0 = m.skew0.toFixed(12);
        translateX = m.translateX.toFixed(12);
        translateY = m.translateY.toFixed(12);
        if (this.use3D) {
          style.webkitTransform = "matrix3d(" + ("" + scaleX + "," + skew1 + ",0,0,") + ("" + skew0 + "," + scaleY + ",0,0,") + "0,0,1,0," + ("" + translateX + "," + translateY + ",0,1)");
        } else {
          style.webkitTransform = "matrix(" + ("" + scaleX + "," + skew1 + "," + skew0 + "," + scaleY + "," + translateX + "," + translateY + ")");
        }
      }
      this.commands = [];
    };

    WebkitCSSRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;
      context = this.bitmapContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;
      context = this.bitmapExContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;
      context = this.textContexts[objectId];
      if (context) {
        return new WebkitCSSTextRenderer(lwf, context, text);
      }
    };

    WebkitCSSRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;
      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    WebkitCSSRendererFactory.prototype.convertColor = function(d, c, t) {
      Utility.calcColor(d, c, t);
      d.red = Math.round(d.red * 255);
      d.green = Math.round(d.green * 255);
      d.blue = Math.round(d.blue * 255);
    };

    WebkitCSSRendererFactory.prototype.convertRGB = function(c) {
      var b, g, r;
      r = Math.round(c.red * 255);
      g = Math.round(c.green * 255);
      b = Math.round(c.blue * 255);
      return "rgb(" + r + "," + g + "," + b + ")";
    };

    WebkitCSSRendererFactory.prototype.getStageSize = function() {
      var computedStyle, h, w;
      computedStyle = window.getComputedStyle(this.stage, "");
      w = parseInt(computedStyle.getPropertyValue("width").replace("px", ""), 10);
      h = parseInt(computedStyle.getPropertyValue("height").replace("px", ""), 10);
      return [w, h];
    };

    WebkitCSSRendererFactory.prototype.fitForHeight = function(lwf) {
      var h, w, _ref1;
      _ref1 = this.getStageSize(), w = _ref1[0], h = _ref1[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.fitForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.fitForWidth = function(lwf) {
      var h, w, _ref1;
      _ref1 = this.getStageSize(), w = _ref1[0], h = _ref1[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.fitForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForHeight = function(lwf) {
      var h, w, _ref1;
      _ref1 = this.getStageSize(), w = _ref1[0], h = _ref1[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.scaleForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForWidth = function(lwf) {
      var h, w, _ref1;
      _ref1 = this.getStageSize(), w = _ref1[0], h = _ref1[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.scaleForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.setBackgroundColor = function(lwf) {
      var b, bgColor, g, r;
      bgColor = lwf.backgroundColor;
      r = (bgColor >> 16) & 0xff;
      g = (bgColor >> 8) & 0xff;
      b = (bgColor >> 0) & 0xff;
      this.stage.style.backgroundColor = "rgb(" + r + "," + g + "," + b + ")";
    };

    return WebkitCSSRendererFactory;

  })();

  WebkitCSSBitmapContext = (function() {

    function WebkitCSSBitmapContext(factory, data, bitmapEx) {
      var bh, bu, bv, bw, h, image, imageScale, sh, su, sv, sw, texture, u, v, w, x, y;
      this.factory = factory;
      this.data = data;
      this.fragment = data.textureFragments[bitmapEx.textureFragmentId];
      texture = data.textures[this.fragment.textureId];
      image = this.factory.cache[texture.filename];
      imageScale = image.width / texture.width;
      this.scale = 1 / (texture.scale * imageScale);
      x = this.fragment.x;
      y = this.fragment.y;
      u = this.fragment.u;
      v = this.fragment.v;
      w = this.fragment.w;
      h = this.fragment.h;
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      this.x = Math.round(x * imageScale);
      this.y = Math.round(y * imageScale);
      su = Math.round(u * imageScale);
      sv = Math.round(v * imageScale);
      if (this.fragment.rotated) {
        sw = Math.round(h * imageScale);
        sh = Math.round(w * imageScale);
      } else {
        sw = Math.round(w * imageScale);
        sh = Math.round(h * imageScale);
      }
      this.h = Math.round(h * imageScale);
      this.node = document.createElement("div");
      if (image.src != null) {
        this.node.style.background = "url(" + image.src + ") transparent";
      } else {
        this.node.style.background = "-webkit-canvas(" + image.name + ") transparent";
      }
      this.node.style.backgroundPosition = "-" + su + "px -" + sv + "px";
      this.node.style.width = "" + sw + "px";
      this.node.style.height = "" + sh + "px";
      this.node.style.display = "block";
      this.node.style.pointerEvents = "none";
      this.node.style.position = "absolute";
      this.node.style.webkitTransformOrigin = "0px 0px";
      this.cache = [];
    }

    WebkitCSSBitmapContext.prototype.destruct = function() {
      var node, _i, _len, _ref1;
      _ref1 = this.cache;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        this.factory.stage.removeChild(node);
      }
    };

    return WebkitCSSBitmapContext;

  })();

  WebkitCSSBitmapRenderer = (function() {

    function WebkitCSSBitmapRenderer(context) {
      var fragment;
      this.context = context;
      if (this.context.cache.length > 0) {
        this.node = this.context.cache.pop();
        this.node.style.visibility = "visible";
      } else {
        this.node = this.context.node.cloneNode(true);
        this.context.factory.stage.appendChild(this.node);
      }
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = true;
      fragment = this.context.fragment;
      if (fragment.rotated || this.context.x !== 0 || this.context.y !== 0 || this.context.scale !== 1) {
        this.matrixForAtlas = new Matrix();
      }
    }

    WebkitCSSBitmapRenderer.prototype.destruct = function() {
      this.node.style.visibility = "hidden";
      this.context.cache.push(this.node);
    };

    WebkitCSSBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var fragment, matrixChanged, scale, x, y;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          this.node.style.visibility = "hidden";
          return;
        } else {
          this.node.style.visibility = "visible";
        }
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (matrixChanged) {
        m = this.matrix;
        fragment = this.context.fragment;
        x = this.context.x;
        y = this.context.y;
        scale = this.context.scale;
        if (fragment.rotated) {
          m = Utility.rotateMatrix(this.matrixForAtlas, m, scale, x, y + this.context.h);
        } else if (scale !== 1 || x !== 0 || y !== 0) {
          m = Utility.scaleMatrix(this.matrixForAtlas, m, scale, x, y);
        }
      } else {
        if (this.matrixForAtlas != null) {
          m = this.matrixForAtlas;
        } else {
          m = this.matrix;
        }
      }
      if (!matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex) {
        return;
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      this.context.factory.commands.push({
        isBitmap: true,
        renderer: this,
        matrix: m
      });
    };

    return WebkitCSSBitmapRenderer;

  })();

  WebkitCSSTextContext = (function() {

    function WebkitCSSTextContext(factory, data, text) {
      var font;
      this.factory = factory;
      this.data = data;
      this.text = text;
      this.str = this.data.strings[text.stringId];
      this.textProperty = this.data.textProperties[text.textPropertyId];
      font = this.data.fonts[this.textProperty.fontId];
      this.fontName = "\"" + this.data.strings[font.stringId] + "\",sans-serif";
      this.textColor = this.data.colors[text.colorId];
      this.name = this.data.strings[text.nameStringId];
      if (this.textProperty.strokeColorId !== -1) {
        this.strokeColor = this.data.colors[this.textProperty.strokeColorId];
      }
      if (this.textProperty.shadowColorId !== -1) {
        this.shadowColor = this.data.colors[this.textProperty.shadowColorId];
      }
      switch (this.textProperty.align & Align.ALIGN_MASK) {
        case Align.RIGHT:
          this.align = "right";
          break;
        case Align.CENTER:
          this.align = "center";
          break;
        default:
          this.align = "left";
      }
    }

    WebkitCSSTextContext.prototype.destruct = function() {};

    return WebkitCSSTextContext;

  })();

  WebkitCSSTextRenderer = (function() {

    function WebkitCSSTextRenderer(lwf, context, textObject) {
      var scale, text, textProperty, width, _ref1;
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      this.str = (_ref1 = this.textObject.parent[this.context.name]) != null ? _ref1 : this.context.str;
      if (this.str != null) {
        this.str = String(this.str);
      }
      this.textNodes = [];
      this.matrixForScale = new Matrix();
      this.color = new Color;
      scale = this.lwf.scaleByStage;
      text = this.context.text;
      textProperty = this.context.textProperty;
      width = (text.width - textProperty.leftMargin - textProperty.rightMargin) * scale;
      this.node = document.createElement('div');
      this.node.style.width = "" + width + "px";
      this.node.style.height = "" + (text.height * scale) + "px";
      this.node.style.position = "absolute";
      this.node.style.textAlign = this.context.align;
      this.node.style.textIndent = "" + (textProperty.indent * scale) + "px";
      this.node.style.lineHeight = "" + ((textProperty.fontHeight + textProperty.leading) * scale) + "pt";
      this.node.style.marginLeft = "" + (textProperty.leftMargin * scale) + "px";
      this.node.style.fontSize = "" + (textProperty.fontHeight * scale) + "px";
      this.node.style.fontFamily = this.context.fontName;
      this.node.style.display = "block";
      this.node.style.pointerEvents = "none";
      this.node.style.webkitTransformOrigin = "0px 0px";
      this.node.style.webkitUserSelect = "none";
      if (this.context.strokeColor != null) {
        this.node.style.webkitTextStrokeColor = this.context.factory.convertRGB(this.context.strokeColor);
        this.node.style.webkitTextStrokeWidth = "" + textProperty.strokeWidth + "px";
      }
      if (this.context.shadowColor != null) {
        this.node.style.textShadow = ("" + textProperty.shadowOffsetX + "px ") + ("" + textProperty.shadowOffsetY + "px ") + ("" + textProperty.shadowBlur + "px ") + this.context.factory.convertRGB(this.context.shadowColor);
      }
      this.context.factory.stage.appendChild(this.node);
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = true;
      this.textRendered = false;
    }

    WebkitCSSTextRenderer.prototype.destruct = function() {
      this.context.factory.stage.removeChild(this.node);
    };

    WebkitCSSTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var matrixChanged, str, strChanged;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          this.node.style.visibility = "hidden";
          return;
        } else {
          this.node.style.visibility = "visible";
        }
      }
      strChanged = false;
      str = this.textObject.parent[this.context.name];
      if (str != null) {
        str = String(str);
      }
      if ((str != null) && str !== this.str) {
        strChanged = true;
        this.str = str;
      }
      if (!this.textRendered || strChanged) {
        this.renderText();
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (!matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex) {
        return;
      }
      m = Utility.scaleMatrix(this.matrixForScale, this.matrix, 1 / this.lwf.scaleByStage, 0, 0);
      if (!this.context.factory.textInSubpixel) {
        m.translateX = Math.round(m.translateX);
        m.translateY = Math.round(m.translateY);
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      this.context.factory.convertColor(this.color, this.context.textColor, c);
      this.context.factory.commands.push({
        isBitmap: false,
        renderer: this,
        matrix: m
      });
    };

    WebkitCSSTextRenderer.prototype.clearTextNodes = function() {
      this.textNodes = [];
      while (this.node.firstChild) {
        this.node.removeChild(this.node.firstChild);
      }
    };

    WebkitCSSTextRenderer.prototype.renderText = function() {
      var fontHeight, h, i, leading, lines, offsetY, property, scale, textNode, _i, _j, _ref1, _ref2;
      this.textRendered = true;
      lines = this.str.split("\n");
      if (lines.length === 0) {
        this.clearTextNodes();
        return;
      }
      if (lines.length === this.textNodes.length) {
        for (i = _i = 0, _ref1 = lines.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          this.textNodes[i].textContent = lines[i];
        }
      } else {
        this.clearTextNodes();
        if (lines.length > 1) {
          for (i = _j = 0, _ref2 = lines.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            if (i > 0) {
              this.node.appendChild(document.createElement('br'));
            }
            textNode = document.createTextNode(lines[i]);
            this.node.appendChild(textNode);
            this.textNodes.push(textNode);
          }
        } else {
          textNode = document.createTextNode(this.str);
          this.node.appendChild(textNode);
          this.textNodes.push(textNode);
        }
      }
      scale = this.lwf.scaleByStage;
      property = this.context.textProperty;
      fontHeight = property.fontHeight * scale;
      leading = property.leading * scale;
      h = fontHeight * lines.length + leading * (lines.length - 1);
      switch (property.align & Align.VERTICAL_MASK) {
        case Align.VERTICAL_BOTTOM:
          offsetY = this.context.text.height - h;
          break;
        case Align.VERTICAL_MIDDLE:
          offsetY = (this.context.text.height - h) / 2;
          break;
        default:
          offsetY = 0;
      }
      this.node.style.marginTop = "" + offsetY + "px";
    };

    return WebkitCSSTextRenderer;

  })();

  WebkitCSSDomElementRenderer = (function() {

    function WebkitCSSDomElementRenderer(factory, node) {
      this.factory = factory;
      this.node = node;
      this.node.style.position = "absolute";
      this.node.style.webkitTransformOrigin = "0px 0px";
      this.node.style.display = "block";
      this.factory.stage.parentNode.appendChild(this.node);
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = true;
    }

    WebkitCSSDomElementRenderer.prototype.destruct = function() {
      this.factory.stage.parentNode.removeChild(this.node);
    };

    WebkitCSSDomElementRenderer.prototype.update = function(m, c) {};

    WebkitCSSDomElementRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var matrixChanged, style;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          this.node.style.visibility = "hidden";
          return;
        } else {
          this.node.style.visibility = "visible";
        }
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (!matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex) {
        return;
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      style = this.node.style;
      style.zIndex = this.zIndex;
      style.opacity = this.alpha;
      m = this.matrix;
      if (this.use3D) {
        style.webkitTransform = "matrix3d(" + ("" + m.scaleX + "," + m.skew1 + ",0,0,") + ("" + m.skew0 + "," + m.scaleY + ",0,0,") + "0,0,1,0," + ("" + m.translateX + "," + m.translateY + ",0,1)");
      } else {
        style.webkitTransform = "matrix(" + ("" + m.scaleX + "," + m.skew1 + "," + m.skew0 + "," + m.scaleY + ",") + ("" + m.translateX + "," + m.translateY + ")");
      }
    };

    return WebkitCSSDomElementRenderer;

  })();

  WebkitCSSResourceCache = (function() {
    var _instance;

    _instance = null;

    WebkitCSSResourceCache.get = function() {
      return _instance != null ? _instance : _instance = new this();
    };

    function WebkitCSSResourceCache() {
      this.cache = {};
    }

    WebkitCSSResourceCache.prototype.clear = function() {
      return this.cache = {};
    };

    WebkitCSSResourceCache.prototype.getTextureURL = function(settings, data, texture) {
      var imageMap, newUrl, prefix, suffix, url, _ref1, _ref2, _ref3;
      prefix = (_ref1 = (_ref2 = settings["imagePrefix"]) != null ? _ref2 : settings["prefix"]) != null ? _ref1 : "";
      suffix = (_ref3 = settings["imageSuffix"]) != null ? _ref3 : "";
      imageMap = settings["imageMap"];
      url = texture.filename;
      if (typeof imageMap === 'function') {
        newUrl = imageMap.call(settings, url);
        if (newUrl != null) {
          url = newUrl;
        }
      } else if (typeof imageMap === 'object') {
        newUrl = imageMap[url];
        if (newUrl != null) {
          url = newUrl;
        }
      }
      if (!url.match(/^\//)) {
        url = prefix + url;
      }
      url = url.replace(/(\.png|\.jpg)/i, suffix + "$1");
      return url;
    };

    WebkitCSSResourceCache.prototype.checkTextures = function(settings, data) {
      var h, m, ma, orig, pm, pngFilename, pngURL, re, rgb, rotated, t, texture, u, url, v, w, x, y, _base, _i, _len, _ref1, _ref2;
      settings._alphaMap = {};
      settings._rgbMap = {};
      settings._textures = [];
      re = new RegExp("_atlas_(.*)_info_" + "([0-9])_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)", "i");
      _ref1 = data.textures;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        texture = _ref1[_i];
        m = texture.filename.match(/^(.*)_rgb_([0-9a-f]{6})(.*)$/i);
        if (m != null) {
          ma = texture.filename.match(re);
          if (ma != null) {
            orig = ma[1];
            rotated = ma[2] === "1" ? true : false;
            u = parseInt(ma[3], 10);
            v = parseInt(ma[4], 10);
            w = parseInt(ma[5], 10);
            h = parseInt(ma[6], 10);
            x = parseInt(ma[7], 10);
            y = parseInt(ma[8], 10);
          } else {
            orig = m[1] + m[3];
            rotated = false;
            u = 0;
            v = 0;
            w = null;
            h = null;
            x = 0;
            y = 0;
          }
          rgb = m[2];
          if ((_ref2 = (_base = settings._rgbMap)[orig]) == null) {
            _base[orig] = [];
          }
          settings._rgbMap[orig].push({
            filename: texture.filename,
            rgb: rgb,
            rotated: rotated,
            u: u,
            v: v,
            w: w,
            h: h,
            x: x,
            y: y
          });
          continue;
        }
        settings._textures.push(texture);
        url = this.getTextureURL(settings, data, texture);
        m = url.match(/^(.*)_withalpha(.*\.)jpg/i);
        if (m != null) {
          pngURL = "" + m[1] + "_alpha" + m[2] + "png";
          pm = pngURL.match(/\/([^\/]+)$/);
          pngFilename = pm != null ? pm[1] : pngURL;
          t = new Format.TextureReplacement(pngFilename);
          t.url = pngURL;
          settings._textures.push(t);
          settings._alphaMap[texture.filename] = [texture, t];
          settings._alphaMap[t.filename] = [texture, t];
        }
      }
    };

    WebkitCSSResourceCache.prototype.onloaddata = function(settings, data, url) {
      var lwfUrl;
      if (!((data != null) && data.check())) {
        settings.error.push({
          url: url,
          reason: "dataError"
        });
        settings["onload"].call(settings, null);
        return;
      }
      settings["name"] = data.name();
      this.checkTextures(settings, data);
      lwfUrl = settings["lwf"];
      this.cache[lwfUrl] = {};
      this.cache[lwfUrl].data = data;
      settings.total = settings._textures.length + 1;
      if (data.useScript) {
        settings.total++;
      }
      settings.loadedCount = 1;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (data.useScript) {
        this.loadJS(settings, data);
      } else {
        this.loadImages(settings, data);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWF = function(settings) {
      var data, lwfUrl, url, _ref1;
      lwfUrl = settings["lwf"];
      url = lwfUrl;
      if (!url.match(/^\//)) {
        url = ((_ref1 = settings["prefix"]) != null ? _ref1 : "") + url;
      }
      settings.error = [];
      if (this.cache[lwfUrl] != null) {
        data = this.cache[lwfUrl].data;
        if (data != null) {
          settings["name"] = data.name();
          this.checkTextures(settings, data);
          settings.total = settings._textures.length + 1;
          settings.loadedCount = 1;
          if (typeof onprogress !== "undefined" && onprogress !== null) {
            onprogress.call(settings, settings.loadedCount, settings.total);
          }
          this.loadImages(settings, data);
          return;
        }
      }
      this.loadLWFData(settings, url);
    };

    WebkitCSSResourceCache.prototype.dispatchOnloaddata = function(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data) {
      var i, m, re, scripts, src, workerJS, _i, _ref1,
        _this = this;
      if (useWorker) {
        workerJS = null;
        scripts = document.getElementsByTagName("script");
        re = new RegExp("(^|.*\/" + __FILE__ + ")$", "i");
        for (i = _i = 0, _ref1 = scripts.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          if (scripts[i].src === "") {
            continue;
          }
          src = scripts[i].src.split('?')[0];
          m = src.match(re);
          if (m != null) {
            workerJS = m[1];
            break;
          }
        }
        if (workerJS != null) {
          (function(workerJS) {
            var worker;
            worker = new Worker(workerJS);
            worker.onmessage = function(e) {
              data = new Data(e.data);
              worker = worker.onmessage = worker.onerror = null;
              return _this.onloaddata(settings, data, url);
            };
            worker.onerror = function(e) {
              settings.error.push({
                url: workerJS,
                reason: "error"
              });
              worker = worker.onmessage = worker.onerror = null;
              return settings["onload"].call(settings, null);
            };
            if (useWorkerWithArrayBuffer && data.type !== "base64") {
              return worker.webkitPostMessage(data.data);
            } else {
              return worker.postMessage(data.data);
            }
          })(workerJS);
        }
      }
      if (workerJS == null) {
        if (data.type === "base64") {
          data = global["LWF"].Base64.atobArray(data.data);
          data = (new global["LWF"].Zlib.Inflate(data)).decompress();
          data = Loader.loadArray(data);
        } else if (useArrayBuffer) {
          data = Loader.loadArrayBuffer(data.data);
        } else {
          data = Loader.load(data.data);
        }
        this.onloaddata(settings, data, url);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFData = function(settings, url) {
      var head, m, name, onload, script, useArrayBuffer, useWorker, useWorkerWithArrayBuffer, xhr,
        _this = this;
      onload = settings["onload"];
      useWorker = false;
      useWorkerWithArrayBuffer = false;
      if (typeof Worker !== 'undefined' && (!(settings["worker"] != null) || settings["worker"])) {
        useWorker = true;
        if (typeof Worker.prototype.webkitPostMessage !== "undefined") {
          useWorkerWithArrayBuffer = true;
        }
      }
      m = url.match(/([^\/]+)\.lwf\.js/i);
      if (m != null) {
        name = m[1].toLowerCase();
        head = document.getElementsByTagName('head')[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.charset = "UTF-8";
        script.onabort = function() {
          settings.error.push({
            url: url,
            reason: "abort"
          });
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
        script.onerror = function() {
          settings.error.push({
            url: url,
            reason: "error"
          });
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
        script.onload = function() {
          var data, str, _ref1, _ref2;
          str = (_ref1 = global["LWF"]) != null ? (_ref2 = _ref1["DataScript"]) != null ? _ref2[name] : void 0 : void 0;
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          if (str != null) {
            data = {
              type: "base64",
              data: str
            };
            return _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
          } else {
            settings.error.push({
              url: url,
              reason: "error"
            });
            return onload.call(settings, null);
          }
        };
        script.src = url;
        head.appendChild(script);
        return;
      }
      xhr = new XMLHttpRequest;
      xhr.open('GET', url, true);
      if (typeof xhr.responseType === 'string' && typeof Uint8Array !== 'undefined' && typeof Int32Array !== 'undefined' && typeof Float32Array !== 'undefined' && (!useWorker || useWorkerWithArrayBuffer)) {
        useArrayBuffer = true;
        xhr.responseType = "arraybuffer";
      } else {
        useArrayBuffer = false;
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
      }
      xhr.onabort = function() {
        settings.error.push({
          url: url,
          reason: "abort"
        });
        xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
        return onload.call(settings, null);
      };
      xhr.onerror = function() {
        settings.error.push({
          url: url,
          reason: "error"
        });
        xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
        return onload.call(settings, null);
      };
      xhr.onreadystatechange = function() {
        var data, _ref1;
        if (xhr.readyState !== 4) {
          return;
        }
        if (!((_ref1 = xhr.status) === 0 || _ref1 === 200)) {
          return;
        }
        if (useArrayBuffer) {
          data = {
            type: "arraybuffer",
            data: xhr.response
          };
        } else {
          data = {
            type: "text",
            data: xhr.responseText
          };
        }
        _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
        return xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
      };
      xhr.send(null);
    };

    WebkitCSSResourceCache.prototype.loadJS = function(settings, data) {
      var head, lwfUrl, onload, onprogress, script, url, _ref1, _ref2,
        _this = this;
      lwfUrl = settings["lwf"];
      url = (_ref1 = settings["js"]) != null ? _ref1 : lwfUrl.replace(/\.lwf(\.js)?/i, ".js");
      if (!url.match(/^\//)) {
        url = ((_ref2 = settings["prefix"]) != null ? _ref2 : "") + url;
      }
      onload = settings["onload"];
      onprogress = settings["onprogress"];
      script = document.createElement("script");
      script.type = "text/javascript";
      script.charset = "UTF-8";
      script.onabort = function() {
        delete _this.cache[lwfUrl];
        settings.error.push({
          url: url,
          reason: "abort"
        });
        script = script.onload = script.onabort = script.onerror = null;
        return onload.call(settings, null);
      };
      script.onerror = function() {
        delete _this.cache[lwfUrl];
        settings.error.push({
          url: url,
          reason: "error"
        });
        script = script.onload = script.onabort = script.onerror = null;
        return onload.call(settings, null);
      };
      script.onload = function() {
        settings.loadedCount++;
        if (onprogress != null) {
          onprogress.call(settings, settings.loadedCount, settings.total);
        }
        _this.cache[lwfUrl].script = script;
        script = script.onload = script.onabort = script.onerror = null;
        return _this.loadImages(settings, data);
      };
      script.src = url;
      head = document.getElementsByTagName('head')[0];
      head.appendChild(script);
    };

    WebkitCSSResourceCache.prototype.loadImagesCallback = function(settings, imageCache, data) {
      settings.loadedCount++;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (settings.loadedCount === settings.total) {
        delete settings._alphaMap;
        delete settings._rgbMap;
        delete settings._textures;
        if (settings.error.length > 0) {
          delete this.cache[settings["lwf"]];
          settings["onload"].call(settings, null);
        } else {
          this.newLWF(settings, imageCache, data);
        }
      }
    };

    WebkitCSSResourceCache.prototype.generateImages = function(settings, imageCache, texture, image) {
      var canvas, ctx, d, h, m, name, o, w, _i, _len, _ref1, _ref2;
      d = settings._rgbMap[texture.filename];
      if (d != null) {
        for (_i = 0, _len = d.length; _i < _len; _i++) {
          o = d[_i];
          w = (_ref1 = o.w) != null ? _ref1 : image.width;
          h = (_ref2 = o.h) != null ? _ref2 : image.height;
          if (this.constructor === WebkitCSSResourceCache) {
            name = "canvas_" + o.filename.replace(/[\.-]/g, "_");
            ctx = document.getCSSCanvasContext("2d", name, w, h);
            canvas = ctx.canvas;
            canvas.name = name;
          } else {
            canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            ctx = canvas.getContext('2d');
          }
          ctx.fillStyle = "#" + o.rgb;
          ctx.fillRect(0, 0, w, h);
          ctx.globalCompositeOperation = 'destination-in';
          if (o.rotated) {
            m = new Matrix();
            Utility.rotateMatrix(m, new Matrix(), 1, o.x, o.y + h);
            ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
          } else if (o.x !== 0 || o.y !== 0) {
            m = new Matrix();
            Utility.scaleMatrix(m, new Matrix(), 1, o.x, o.yy);
            ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
          }
          ctx.drawImage(image, o.u, o.v, w, h, 0, 0, w, h);
          imageCache[o.filename] = canvas;
        }
      }
    };

    WebkitCSSResourceCache.prototype.loadImages = function(settings, data) {
      var imageCache, texture, url, _fn, _i, _len, _ref1,
        _this = this;
      imageCache = {};
      if (data.textures.length === 0) {
        this.newLWF(settings, imageCache, data);
        return;
      }
      _ref1 = settings._textures;
      _fn = function(texture, url) {
        var image;
        image = new Image();
        image.onabort = function() {
          settings.error.push({
            url: url,
            reason: "abort"
          });
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        image.onerror = function() {
          settings.error.push({
            url: url,
            reason: "error"
          });
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        image.onload = function() {
          var alpha, alphaImg, canvas, ctx, d, jpg, jpgImg, name;
          imageCache[texture.filename] = image;
          d = settings._alphaMap[texture.filename];
          if (d != null) {
            jpg = d[0];
            alpha = d[1];
            jpgImg = imageCache[jpg.filename];
            alphaImg = imageCache[alpha.filename];
            if ((jpgImg != null) && (alphaImg != null)) {
              if (_this.constructor === WebkitCSSResourceCache) {
                name = "canvas_" + jpg.filename.replace(/[\.-]/g, "_");
                ctx = document.getCSSCanvasContext("2d", name, jpgImg.width, jpgImg.height);
                canvas = ctx.canvas;
                canvas.name = name;
              } else {
                canvas = document.createElement('canvas');
                canvas.width = jpgImg.width;
                canvas.height = jpgImg.height;
                ctx = canvas.getContext('2d');
              }
              ctx.drawImage(jpgImg, 0, 0, jpgImg.width, jpgImg.height);
              ctx.globalCompositeOperation = 'destination-in';
              ctx.drawImage(alphaImg, 0, 0, jpgImg.width, jpgImg.height);
              delete imageCache[jpg.filename];
              delete imageCache[alpha.filename];
              imageCache[jpg.filename] = canvas;
              _this.generateImages(settings, imageCache, jpg, canvas);
            }
          } else {
            _this.generateImages(settings, imageCache, texture, image);
          }
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        return image.src = url;
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        texture = _ref1[_i];
        if (texture.url != null) {
          url = texture.url;
        } else {
          url = this.getTextureURL(settings, data, texture);
        }
        _fn(texture, url);
      }
    };

    WebkitCSSResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref1, _ref2;
      return new WebkitCSSRendererFactory(data, this, cache, settings["stage"], (_ref1 = settings["textInSubpixel"]) != null ? _ref1 : false, (_ref2 = settings["use3D"]) != null ? _ref2 : true);
    };

    WebkitCSSResourceCache.prototype.onloadLWF = function(settings, lwf) {
      var factory;
      factory = lwf.rendererFactory;
      if (settings["useBackgroundColor"]) {
        factory.setBackgroundColor(lwf);
      }
      if (settings["fitForHeight"]) {
        factory.fitForHeight(lwf);
      } else if (settings["fitForWidth"]) {
        factory.fitForWidth(lwf);
      }
      settings["onload"].call(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.newLWF = function(settings, imageCache, data) {
      var cache, embeddedScript, factory, lwf, lwfUrl, _ref1, _ref2, _ref3;
      lwfUrl = settings["lwf"];
      cache = this.cache[lwfUrl];
      if ((_ref1 = cache.instances) == null) {
        cache.instances = 0;
      }
      cache.instances++;
      factory = this.newFactory(settings, imageCache, data);
      if (data.useScript) {
        embeddedScript = (_ref2 = global["LWF"]) != null ? (_ref3 = _ref2["Script"]) != null ? _ref3[data.name()] : void 0 : void 0;
      }
      lwf = new LWF(data, factory, embeddedScript, settings["privateData"]);
      lwf.url = settings["lwf"];
      if (settings["preferredFrameRate"] != null) {
        if (settings["execLimit"] != null) {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"], settings["execLimit"]);
        } else {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"]);
        }
      }
      this.onloadLWF(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.unloadLWF = function(lwf) {
      var cache, head;
      cache = this.cache[lwf.url];
      if ((cache != null) && --cache.instances <= 0) {
        head = document.getElementsByTagName('head')[0];
        head.removeChild(cache.script);
        delete this.cache[lwf.url];
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFs = function(settingsArray, onloadall) {
      var errors, loadTotal, loadedCount, onload, settings, _fn, _i, _len, _results,
        _this = this;
      loadTotal = settingsArray.length;
      loadedCount = 0;
      errors = null;
      _fn = function(onload) {
        return settings["onload"] = function(lwf) {
          if (onload != null) {
            onload(lwf);
          }
          if (settings.error.length > 0) {
            if (errors == null) {
              errors = [];
            }
            errors = errors.concat(settings.error);
          }
          ++loadedCount;
          if (loadTotal === loadedCount) {
            return onloadall(errors);
          }
        };
      };
      _results = [];
      for (_i = 0, _len = settingsArray.length; _i < _len; _i++) {
        settings = settingsArray[_i];
        onload = settings["onload"];
        _fn(onload);
        _results.push(this.loadLWF(settings));
      }
      return _results;
    };

    WebkitCSSResourceCache.prototype.getCache = function() {
      return this.cache;
    };

    WebkitCSSResourceCache.prototype.setParticleConstructor = function(ctor) {
      this.particleConstructor = ctor;
    };

    WebkitCSSResourceCache.prototype.setDOMElementConstructor = function(ctor) {
      this.domElementConstructor = ctor;
    };

    return WebkitCSSResourceCache;

  })();

  if (typeof global !== "undefined") {
    global["LWF"]["WebkitCSSRendererFactory"] = WebkitCSSRendererFactory;
    global["LWF"]["WebkitCSSResourceCache"] = WebkitCSSResourceCache;
    global["LWF"]["useWebkitCSSRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = WebkitCSSResourceCache;
    };
  }

  WebkitCSSRendererFactory.prototype["convertColor"] = WebkitCSSRendererFactory.prototype.convertColor;

  WebkitCSSRendererFactory.prototype["fitForHeight"] = WebkitCSSRendererFactory.prototype.fitForHeight;

  WebkitCSSRendererFactory.prototype["fitForWidth"] = WebkitCSSRendererFactory.prototype.fitForWidth;

  WebkitCSSRendererFactory.prototype["scaleForHeight"] = WebkitCSSRendererFactory.prototype.scaleForHeight;

  WebkitCSSRendererFactory.prototype["scaleForWidth"] = WebkitCSSRendererFactory.prototype.scaleForWidth;

  WebkitCSSRendererFactory.prototype["setBackgroundColor"] = WebkitCSSRendererFactory.prototype.setBackgroundColor;

  WebkitCSSResourceCache.prototype["clear"] = WebkitCSSResourceCache.prototype.clear;

  WebkitCSSResourceCache.prototype["getCache"] = WebkitCSSResourceCache.prototype.getCache;

  WebkitCSSResourceCache.prototype["loadLWF"] = WebkitCSSResourceCache.prototype.loadLWF;

  WebkitCSSResourceCache.prototype["loadLWFs"] = WebkitCSSResourceCache.prototype.loadLWFs;

  WebkitCSSResourceCache.prototype["unloadLWF"] = WebkitCSSResourceCache.prototype.unloadLWF;

  WebkitCSSResourceCache.prototype["setParticleConstructor"] = WebkitCSSResourceCache.prototype.setParticleConstructor;

  WebkitCSSResourceCache.prototype["setDOMElementConstructor"] = WebkitCSSResourceCache.prototype.setDOMElementConstructor;

  if (!(typeof window !== "undefined" && window !== null) && (typeof self !== "undefined" && self !== null)) {
    self.onmessage = function(event) {
      var data;
      if (typeof self.webkitPostMessage !== "undefined" && typeof event.data === "object") {
        data = Loader.loadArrayBuffer(event.data);
        self.webkitPostMessage(data);
      } else {
        data = event.data;
        if (data[0] === 'L' && data[1] === 'W' && data[2] === 'F') {
          data = Loader.load(data);
        } else {
          data = global["LWF"].Base64.atobArray(data);
          data = (new global["LWF"].Zlib.Inflate(data)).decompress();
          data = Loader.loadArray(data);
        }
        if (typeof self.webkitPostMessage !== "undefined") {
          self.webkitPostMessage(data);
        } else {
          self.postMessage(data);
        }
      }
      return self.close();
    };
  }

  CanvasRendererFactory = (function(_super) {

    __extends(CanvasRendererFactory, _super);

    function CanvasRendererFactory(data, resourceCache, cache, stage, textInSubpixel, needsClear) {
      var bitmap, bitmapEx, text, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.needsClear = needsClear;
      this.bitmapContexts = [];
      _ref1 = data.bitmaps;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bitmap = _ref1[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        this.bitmapContexts.push(new CanvasBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref2 = data.bitmapExs;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        bitmapEx = _ref2[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new CanvasBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref3 = data.texts;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        text = _ref3[_k];
        this.textContexts.push(new CanvasTextContext(this, data, text));
      }
      this.stage.style.webkitUserSelect = "none";
      this.stage.style.webkitTransform = "translateZ(0)";
      this.stageContext = this.stage.getContext("2d");
      if (this.stage.width === 0 && this.stage.height === 0) {
        this.stage.width = data.header.width;
        this.stage.height = data.header.height;
      }
      this.commands = {};
    }

    CanvasRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3;
      _ref1 = this.bitmapContexts;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        context = _ref1[_i];
        context.destruct();
      }
      _ref2 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        context = _ref2[_j];
        context.destruct();
      }
      _ref3 = this.textContexts;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        context = _ref3[_k];
        context.destruct();
      }
    };

    CanvasRendererFactory.prototype.beginRender = function(lwf) {};

    CanvasRendererFactory.prototype.endRender = function(lwf) {
      var cmd, commands, ctx, h, m, rIndex, u, v, w, _ref1, _ref2;
      ctx = this.stageContext;
      if (lwf.parent != null) {
        commands = lwf.parent.lwf.rendererFactory.commands;
        _ref1 = this.commands;
        for (rIndex in _ref1) {
          cmd = _ref1[rIndex];
          commands[rIndex] = cmd;
        }
        this.commands = {};
        return;
      }
      if (this.needsClear) {
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (this.clearColor != null) {
          ctx.fillStyle = this.clearColor;
          ctx.fillRect(0, 0, this.stage.width, this.stage.height);
        } else {
          ctx.clearRect(0, 0, this.stage.width, this.stage.height);
        }
      }
      _ref2 = this.commands;
      for (rIndex in _ref2) {
        cmd = _ref2[rIndex];
        ctx.globalAlpha = cmd.alpha;
        m = cmd.matrix;
        ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
        u = cmd.u;
        v = cmd.v;
        w = cmd.w;
        h = cmd.h;
        ctx.drawImage(cmd.image, u, v, w, h, 0, 0, w, h);
      }
      this.commands = {};
    };

    CanvasRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;
      context = this.bitmapContexts[objectId];
      if (context) {
        return new CanvasBitmapRenderer(context);
      }
    };

    CanvasRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;
      context = this.bitmapExContexts[objectId];
      if (context) {
        return new CanvasBitmapRenderer(context);
      }
    };

    CanvasRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;
      context = this.textContexts[objectId];
      if (context) {
        return new CanvasTextRenderer(lwf, context, text);
      }
    };

    CanvasRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;
      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    CanvasRendererFactory.prototype.getStageSize = function() {
      return [this.stage.width, this.stage.height];
    };

    CanvasRendererFactory.prototype.setBackgroundColor = function(lwf) {
      var b, bgColor, g, r;
      bgColor = lwf.data.header.backgroundColor;
      r = (bgColor >> 16) & 0xff;
      g = (bgColor >> 8) & 0xff;
      b = (bgColor >> 0) & 0xff;
      this.clearColor = "rgb(" + r + ", " + g + ", " + b + ")";
    };

    return CanvasRendererFactory;

  })(WebkitCSSRendererFactory);

  CanvasBitmapContext = (function() {

    function CanvasBitmapContext(factory, data, bitmapEx) {
      var bh, bu, bv, bw, h, imageScale, imageWidth, texture, u, v, w, withPadding, x, y;
      this.factory = factory;
      this.data = data;
      this.fragment = this.data.textureFragments[bitmapEx.textureFragmentId];
      texture = this.data.textures[this.fragment.textureId];
      this.image = this.factory.cache[texture.filename];
      imageWidth = this.image.width;
      withPadding = texture.filename.match(/_withpadding/) ? true : false;
      if (withPadding) {
        imageWidth -= 2;
      }
      imageScale = imageWidth / texture.width;
      this.scale = 1 / (texture.scale * imageScale);
      x = this.fragment.x;
      y = this.fragment.y;
      u = this.fragment.u;
      v = this.fragment.v;
      w = this.fragment.w;
      h = this.fragment.h;
      if (withPadding) {
        x -= 1;
        y -= 1;
        w += 2;
        h += 2;
      }
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      this.x = Math.round(x * imageScale);
      this.y = Math.round(y * imageScale);
      this.u = Math.round(u * imageScale);
      this.v = Math.round(v * imageScale);
      if (this.fragment.rotated) {
        this.w = Math.round(h * imageScale);
        this.h = Math.round(w * imageScale);
        if (this.w > this.image.width) {
          this.w = this.image.width;
        }
        if (this.h > this.image.height) {
          this.h = this.image.height;
        }
      } else {
        this.w = Math.round(w * imageScale);
        this.h = Math.round(h * imageScale);
        if (this.w > this.image.width) {
          this.w = this.image.width;
        }
        if (this.h > this.image.height) {
          this.h = this.image.height;
        }
      }
      this.imageHeight = h * imageScale;
    }

    CanvasBitmapContext.prototype.destruct = function() {};

    return CanvasBitmapContext;

  })();

  CanvasBitmapRenderer = (function() {

    function CanvasBitmapRenderer(context) {
      var fragment;
      this.context = context;
      fragment = this.context.fragment;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      if (fragment.rotated || this.context.x !== 0 || this.context.y !== 0 || this.context.scale !== 1) {
        this.matrixForAtlas = new Matrix();
      }
    }

    CanvasBitmapRenderer.prototype.destruct = function() {};

    CanvasBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var fragment, scale, x, y;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      if (this.matrix.setWithComparing(m)) {
        m = this.matrix;
        fragment = this.context.fragment;
        x = this.context.x;
        y = this.context.y;
        scale = this.context.scale;
        if (fragment.rotated) {
          m = Utility.rotateMatrix(this.matrixForAtlas, m, scale, x, y + this.context.imageHeight);
        } else if (scale !== 1 || x !== 0 || y !== 0) {
          m = Utility.scaleMatrix(this.matrixForAtlas, m, scale, x, y);
        }
      } else {
        if (this.matrixForAtlas != null) {
          m = this.matrixForAtlas;
        }
      }
      this.alpha = c.multi.alpha;
      fragment = this.context.fragment;
      this.context.factory.commands[renderingIndex] = {
        alpha: this.alpha,
        matrix: m,
        image: this.context.image,
        u: this.context.u,
        v: this.context.v,
        w: this.context.w,
        h: this.context.h
      };
    };

    return CanvasBitmapRenderer;

  })();

  CanvasTextContext = (function() {

    function CanvasTextContext(factory, data, text) {
      var font;
      this.factory = factory;
      this.data = data;
      this.text = text;
      this.str = this.data.strings[this.text.stringId];
      this.textProperty = this.data.textProperties[this.text.textPropertyId];
      font = this.data.fonts[this.textProperty.fontId];
      this.textColor = this.data.colors[this.text.colorId];
      this.name = this.data.strings[this.text.nameStringId];
      if (this.textProperty.strokeColorId !== -1) {
        this.strokeColor = this.data.colors[this.textProperty.strokeColorId];
      }
      if (this.textProperty.shadowColorId !== -1) {
        this.shadowColor = this.data.colors[this.textProperty.shadowColorId];
      }
      this.fontName = "\"" + this.data.strings[font.stringId] + "\",sans-serif";
      switch (this.textProperty.align & Align.ALIGN_MASK) {
        case Align.RIGHT:
          this.align = "right";
          this.offsetX = this.text.width;
          break;
        case Align.CENTER:
          this.align = "center";
          this.offsetX = this.text.width / 2;
          break;
        default:
          this.align = "left";
          this.offsetX = 0;
      }
    }

    CanvasTextContext.prototype.destruct = function() {};

    return CanvasTextContext;

  })();

  CanvasTextRenderer = (function() {

    function CanvasTextRenderer(lwf, context, textObject) {
      var canvas, ctx, fontHeight, scale, _ref1;
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      this.str = (_ref1 = this.textObject.parent[this.context.name]) != null ? _ref1 : this.context.str;
      if (this.str != null) {
        this.str = String(this.str);
      }
      this.matrixForScale = new Matrix();
      this.color = new Color;
      scale = this.lwf.scaleByStage;
      canvas = document.createElement("canvas");
      canvas.width = this.context.text.width * scale;
      canvas.height = this.context.text.height * scale;
      ctx = canvas.getContext("2d");
      fontHeight = this.context.textProperty.fontHeight * scale;
      ctx.font = "" + fontHeight + "px " + this.context.fontName;
      ctx.textAlign = this.context.align;
      this.canvas = canvas;
      this.canvasContext = ctx;
      this.textRendered = false;
    }

    CanvasTextRenderer.prototype.destruct = function() {};

    CanvasTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var blue, colorChanged, green, red, str, strChanged;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      m = Utility.scaleMatrix(this.matrixForScale, m, 1 / this.lwf.scaleByStage, 0, 0);
      if (!this.context.factory.textInSubpixel) {
        m.translateX = Math.round(m.translateX);
        m.translateY = Math.round(m.translateY);
      }
      red = this.color.red;
      green = this.color.green;
      blue = this.color.blue;
      this.context.factory.convertColor(this.color, this.context.textColor, c);
      c = this.color;
      colorChanged = false;
      if (red !== c.red || green !== c.green || blue !== c.blue) {
        colorChanged = true;
      }
      strChanged = false;
      str = this.textObject.parent[this.context.name];
      if (str != null) {
        str = String(str);
      }
      if ((str != null) && str !== this.str) {
        strChanged = true;
        this.str = str;
      }
      if (!this.textRendered || colorChanged || strChanged) {
        this.renderText(c);
      }
      this.context.factory.commands[renderingIndex] = {
        alpha: c.alpha,
        matrix: m,
        image: this.canvas,
        u: 0,
        v: 0,
        w: this.canvas.width,
        h: this.canvas.height
      };
    };

    CanvasTextRenderer.prototype.renderText = function(c) {
      var canvas, ctx, fontHeight, h, i, leading, line, lines, offsetY, property, scale, shadowColor, useStroke, x, y, _i, _ref1;
      this.textRendered = true;
      canvas = this.canvas;
      ctx = this.canvasContext;
      lines = this.str.split("\n");
      scale = this.lwf.scaleByStage;
      property = this.context.textProperty;
      fontHeight = property.fontHeight * scale;
      leading = property.leading * scale;
      h = (fontHeight * lines.length + leading * (lines.length - 1)) * 96 / 72;
      switch (property.align & Align.VERTICAL_MASK) {
        case Align.VERTICAL_BOTTOM:
          offsetY = canvas.height - h;
          break;
        case Align.VERTICAL_MIDDLE:
          offsetY = (canvas.height - h) / 2;
          break;
        default:
          offsetY = 0;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "rgb(" + c.red + "," + c.green + "," + c.blue + ")";
      useStroke = false;
      if (this.context.strokeColor != null) {
        ctx.strokeStyle = this.context.factory.convertRGB(this.context.strokeColor);
        ctx.lineWidth = property.strokeWidth;
        useStroke = true;
      }
      if (this.context.shadowColor != null) {
        shadowColor = this.context.factory.convertRGB(this.context.shadowColor);
        ctx.shadowOffsetX = property.shadowOffsetX;
        ctx.shadowOffsetY = property.shadowOffsetY;
        ctx.shadowBlur = property.shadowBlur;
      }
      for (i = _i = 0, _ref1 = lines.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        line = lines[i];
        x = this.context.offsetX * scale;
        y = fontHeight + offsetY;
        if (i > 0) {
          y += (fontHeight + leading) * i * 96 / 72;
        }
        if (this.context.shadowColor != null) {
          ctx.shadowColor = shadowColor;
        }
        ctx.fillText(line, x, y);
        if (useStroke) {
          if (this.context.shadowColor != null) {
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
          }
          ctx.strokeText(line, x, y);
        }
      }
    };

    return CanvasTextRenderer;

  })();

  CanvasResourceCache = (function(_super) {

    __extends(CanvasResourceCache, _super);

    function CanvasResourceCache() {
      return CanvasResourceCache.__super__.constructor.apply(this, arguments);
    }

    CanvasResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref1, _ref2;
      return new CanvasRendererFactory(data, this, cache, settings.stage, (_ref1 = settings.textInSubpixel) != null ? _ref1 : false, (_ref2 = settings.canvasNeedsClear) != null ? _ref2 : true);
    };

    CanvasResourceCache.prototype.generateImages = function(settings, imageCache, texture, image) {
      var canvas, ctx, h, m, name, w;
      m = texture.filename.match(/_withpadding/);
      if (m != null) {
        w = image.width + 2;
        h = image.height + 2;
        if (this.constructor === WebkitCSSResourceCache) {
          name = "canvas_" + texture.filename.replace(/[\.-]/g, "_");
          ctx = document.getCSSCanvasContext("2d", name, w, h);
          canvas = ctx.canvas;
          canvas.name = name;
        } else {
          canvas = document.createElement('canvas');
          canvas.width = w;
          canvas.height = h;
          ctx = canvas.getContext('2d');
        }
        canvas.withPadding = true;
        ctx.drawImage(image, 1, 1, image.width, image.height);
        imageCache[texture.filename] = canvas;
      }
      CanvasResourceCache.__super__.generateImages.apply(this, arguments);
    };

    return CanvasResourceCache;

  })(WebkitCSSResourceCache);

  if (typeof global !== "undefined") {
    global["LWF"]["CanvasRendererFactory"] = CanvasRendererFactory;
    global["LWF"]["CanvasResourceCache"] = CanvasResourceCache;
    global["LWF"]["useCanvasRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = CanvasResourceCache;
    };
  }

  CanvasRendererFactory.prototype["convertColor"] = CanvasRendererFactory.prototype.convertColor;

  CanvasRendererFactory.prototype["fitForHeight"] = CanvasRendererFactory.prototype.fitForHeight;

  CanvasRendererFactory.prototype["fitForWidth"] = CanvasRendererFactory.prototype.fitForWidth;

  CanvasRendererFactory.prototype["scaleForHeight"] = CanvasRendererFactory.prototype.scaleForHeight;

  CanvasRendererFactory.prototype["scaleForWidth"] = CanvasRendererFactory.prototype.scaleForWidth;

  CanvasRendererFactory.prototype["setBackgroundColor"] = CanvasRendererFactory.prototype.setBackgroundColor;

  CanvasResourceCache.prototype["clear"] = CanvasResourceCache.prototype.clear;

  CanvasResourceCache.prototype["getCache"] = CanvasResourceCache.prototype.getCache;

  CanvasResourceCache.prototype["loadLWF"] = CanvasResourceCache.prototype.loadLWF;

  CanvasResourceCache.prototype["loadLWFs"] = CanvasResourceCache.prototype.loadLWFs;

  CanvasResourceCache.prototype["unloadLWF"] = CanvasResourceCache.prototype.unloadLWF;

  CanvasResourceCache.prototype["setParticleConstructor"] = CanvasResourceCache.prototype.setParticleConstructor;

  CanvasResourceCache.prototype["setDOMElementConstructor"] = CanvasResourceCache.prototype.setDOMElementConstructor;

}).call(this);
/**
 * @author sole / http://soledadpenades.com
 * @author mrdoob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 * @author GREE, Inc.
 *
 * The MIT License
 *
 * Copyright (c) 2010-2012 Tween.js authors.
 * Copyright (c) 2012 GREE, Inc.
 *
 * Easing equations
 *   Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function() {

var TWEENLWF = {};

TWEENLWF.Tween = function ( movie ) {

	this.lwf = movie.lwf;
	this.object = movie;
	this.valuesStart = {};
	this.valuesEnd = {};
	this.duration = 1;
	this.delayTime = 0;
	this.startTime = null;
	this.easingFunction = TWEENLWF.Easing.Linear.None;
	this.interpolationFunction = TWEENLWF.Interpolation.Linear;
	this.chainedTweens = [];
	this.onStartCallback = null;
	this.onStartCallbackFired = false;
	this.onUpdateCallback = null;
	this.onCompleteCallback = null;

	if ( typeof this.lwf._tweens === "undefined" ) {

		this.lwf._tweens = [];

		if ( this.lwf._tweenMode === "lwf" ) {

			this.lwf.addExecHandler( TWEENLWF._tweenExecHandler );

		} else {

			this.lwf.addMovieEventHandler( "_root", {

				"enterFrame": TWEENLWF._tweenMovieHandler

			});

		}

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			this.duration = duration * this.lwf.tick;

		}

		this.valuesEnd = properties;

		return this;

	};

	this.start = function () {

		this.lwf._tweens.push( this );

		this.onStartCallbackFired = false;

		this.startTime = this.lwf.time;
		this.startTime += this.delayTime;

		for ( var property in this.valuesEnd ) {

			// This prevents the engine from interpolating null values
			if ( this.object[ property ] === null ) {

				continue;

			}

			// check if an Array was provided as property value
			if ( this.valuesEnd[ property ] instanceof Array ) {

				if ( this.valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				this.valuesEnd[ property ] = [ this.object[ property ] ].concat( this.valuesEnd[ property ] );

			}

			this.valuesStart[ property ] = this.object[ property ];

		}

		return this;

	};

	this.stop = function () {

		var i = this.lwf._tweens.indexOf( this );

		if ( i !== -1 ) {

			this.lwf._tweens.splice( i, 1 );

			if ( this.lwf._tweens.length == 0 ) {

				this.stopTweens();

			}

		}

		return this;

	};

	this.delay = function ( amount ) {

		this.delayTime = amount * this.lwf.tick;
		return this;

	};

	this.easing = function ( easing ) {

		this.easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		this.interpolationFunction = interpolation;
		return this;

	};

	this.chain = function ( chainedTween ) {

		if ( typeof chainedTween !== "undefined" && chainedTween !== null ) {

			this.chainedTweens.push( chainedTween );
			return this;

		} else {

			chainedTween = new TWEENLWF.Tween( this.object );
			this.chainedTweens.push( chainedTween );
			return chainedTween;

		}

	};

	this.onStart = function ( callback ) {

		this.onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		this.onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		this.onCompleteCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		if ( time < this.startTime ) {

			return true;

		}

		if ( this.onStartCallbackFired === false ) {

			if ( this.onStartCallback !== null ) {

				this.onStartCallback.call( this.object );

			}

			this.onStartCallbackFired = true;

		}

		var elapsed = ( time - this.startTime ) / this.duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = this.easingFunction( elapsed );

		for ( var property in this.valuesStart ) {

			var start = this.valuesStart[ property ];
			var end = this.valuesEnd[ property ];

			if ( end instanceof Array ) {

				this.object[ property ] = this.interpolationFunction( end, value );

			} else {

				this.object[ property ] = start + ( end - start ) * value;

			}

		}

		if ( this.onUpdateCallback !== null ) {

			this.onUpdateCallback.call( this.object, value );

		}

		if ( elapsed == 1 ) {

			if ( this.onCompleteCallback !== null ) {

				this.onCompleteCallback.call( this.object );

			}

			for ( var i = 0, l = this.chainedTweens.length; i < l; i ++ ) {

				this.chainedTweens[ i ].start( time );

			}

			return false;

		}

		return true;

	};

	this[ "to" ] = this.to;
	this[ "start" ] = this.start;
	this[ "stop" ] = this.stop;
	this[ "delay" ] = this.delay;
	this[ "easing" ] = this.easing;
	this[ "interpolation" ] = this.interpolation;
	this[ "chain" ] = this.chain;
	this[ "onStart" ] = this.onStart;
	this[ "onUpdate" ] = this.onUpdate;
	this[ "onComplete" ] = this.onComplete;
	this[ "update" ] = this.update;

};

TWEENLWF.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEENLWF.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEENLWF.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEENLWF.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEENLWF.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEENLWF.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEENLWF.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

var lwfPrototype = global[ "LWF" ][ "LWF" ].prototype;

lwfPrototype[ "setTweenMode" ] = function( mode ) {

	this._tweenMode = mode;

};

lwfPrototype.stopTweens = function() {

	if ( typeof this._tweens !== "undefined" ) {

		this._tweens = undefined;

		this.removeExecHandler( TWEENLWF._tweenExecHandler );
		this.removeMovieEventHandler( "_root", {
			
			"enterFrame": TWEENLWF._tweenMovieHandler

		});

	}

};

lwfPrototype[ "stopTweens" ] = lwfPrototype.stopTweens;

TWEENLWF._tweenUpdater = function() {

	var i = 0;
	var num_tweens = this._tweens.length;
	var time = this.time;

	while ( i < num_tweens ) {

		if ( this._tweens[ i ].update( time ) ) {

			i ++;

		} else {

			this._tweens.splice( i, 1 );
			num_tweens --;

		}

	}

	if ( this._tweens.length == 0 ) {

		this.stopTweens();

	}

};

TWEENLWF._tweenExecHandler = function() {

	TWEENLWF._tweenUpdater();

};

TWEENLWF._tweenMovieHandler = function() {

	TWEENLWF._tweenUpdater.call( this.lwf );

};

var moviePrototype = global[ "LWF" ][ "Movie" ].prototype;

moviePrototype[ "addTween" ] = function() {

	var tween = new TWEENLWF.Tween( this );

	return tween;

};

moviePrototype[ "stopTweens" ] = function() {

	if ( typeof this.lwf === "undefined" || this.lwf === null ||
			typeof this.lwf._tweens === "undefined" ||
				this.lwf._tweens === null ) {

		return this;

	}

	var tweens = this.lwf._tweens;

	var i = 0;
	var num_tweens = tweens.length;

	while ( i < num_tweens ) {

		if ( tweens[ i ]._object === this ) {

			tweens.splice( i, 1 );
			num_tweens --;

		} else {

			i ++;

		}

	}

	if ( tweens.length == 0 ) {

		this.lwf.stopTweens();

	}

	return this;

};

global[ "LWF" ][ "Tween" ] = TWEENLWF.Tween;
global[ "LWF" ][ "Tween" ][ "Easing" ] = TWEENLWF.Easing;
var e = global[ "LWF" ][ "Tween" ][ "Easing" ];
e[ "Linear" ] = TWEENLWF.Easing.Linear;
e[ "Linear" ][ "None" ] = TWEENLWF.Easing.Linear.None;
e[ "Quadratic" ] = TWEENLWF.Easing.Quadratic;
e[ "Quadratic" ][ "In" ] = TWEENLWF.Easing.Quadratic.In;
e[ "Quadratic" ][ "Out" ] = TWEENLWF.Easing.Quadratic.Out;
e[ "Quadratic" ][ "InOut" ] = TWEENLWF.Easing.Quadratic.InOut;
e[ "Cubic" ] = TWEENLWF.Easing.Cubic;
e[ "Cubic" ][ "In" ] = TWEENLWF.Easing.Cubic.In;
e[ "Cubic" ][ "Out" ] = TWEENLWF.Easing.Cubic.Out;
e[ "Cubic" ][ "InOut" ] = TWEENLWF.Easing.Cubic.InOut;
e[ "Quartic" ] = TWEENLWF.Easing.Quartic;
e[ "Quartic" ][ "In" ] = TWEENLWF.Easing.Quartic.In;
e[ "Quartic" ][ "Out" ] = TWEENLWF.Easing.Quartic.Out;
e[ "Quartic" ][ "InOut" ] = TWEENLWF.Easing.Quartic.InOut;
e[ "Quintic" ] = TWEENLWF.Easing.Quintic;
e[ "Quintic" ][ "In" ] = TWEENLWF.Easing.Quintic.In;
e[ "Quintic" ][ "Out" ] = TWEENLWF.Easing.Quintic.Out;
e[ "Quintic" ][ "InOut" ] = TWEENLWF.Easing.Quintic.InOut;
e[ "Sinusoidal" ] = TWEENLWF.Easing.Sinusoidal;
e[ "Sinusoidal" ][ "In" ] = TWEENLWF.Easing.Sinusoidal.In;
e[ "Sinusoidal" ][ "Out" ] = TWEENLWF.Easing.Sinusoidal.Out;
e[ "Sinusoidal" ][ "InOut" ] = TWEENLWF.Easing.Sinusoidal.InOut;
e[ "Exponential" ] = TWEENLWF.Easing.Exponential;
e[ "Exponential" ][ "In" ] = TWEENLWF.Easing.Exponential.In;
e[ "Exponential" ][ "Out" ] = TWEENLWF.Easing.Exponential.Out;
e[ "Exponential" ][ "InOut" ] = TWEENLWF.Easing.Exponential.InOut;
e[ "Circular" ] = TWEENLWF.Easing.Circular;
e[ "Circular" ][ "In" ] = TWEENLWF.Easing.Circular.In;
e[ "Circular" ][ "Out" ] = TWEENLWF.Easing.Circular.Out;
e[ "Circular" ][ "InOut" ] = TWEENLWF.Easing.Circular.InOut;
e[ "Elastic" ] = TWEENLWF.Easing.Elastic;
e[ "Elastic" ][ "In" ] = TWEENLWF.Easing.Elastic.In;
e[ "Elastic" ][ "Out" ] = TWEENLWF.Easing.Elastic.Out;
e[ "Elastic" ][ "InOut" ] = TWEENLWF.Easing.Elastic.InOut;
e[ "Back" ] = TWEENLWF.Easing.Back;
e[ "Back" ][ "In" ] = TWEENLWF.Easing.Back.In;
e[ "Back" ][ "Out" ] = TWEENLWF.Easing.Back.Out;
e[ "Back" ][ "InOut" ] = TWEENLWF.Easing.Back.InOut;
e[ "Bounce" ] = TWEENLWF.Easing.Bounce;
e[ "Bounce" ][ "In" ] = TWEENLWF.Easing.Bounce.In;
e[ "Bounce" ][ "Out" ] = TWEENLWF.Easing.Bounce.Out;
e[ "Bounce" ][ "InOut" ] = TWEENLWF.Easing.Bounce.InOut;

global[ "LWF" ][ "Tween" ][ "Interpolation" ] = TWEENLWF.Interpolation;
var i = global[ "LWF" ][ "Tween" ][ "Interpolation" ];
i[ "Linear" ] = TWEENLWF.Interpolation.Linear;
i[ "Bezier" ] = TWEENLWF.Interpolation.Bezier;
i[ "CatmullRom" ] = TWEENLWF.Interpolation.CatmullRom;
i[ "Utils" ] = TWEENLWF.Interpolation.Utils;
i[ "Utils" ][ "Linear" ] = TWEENLWF.Interpolation.Utils.Linear;
i[ "Utils" ][ "Bernstein" ] = TWEENLWF.Interpolation.Utils.Bernstein;
i[ "Utils" ][ "Factorial" ] = TWEENLWF.Interpolation.Utils.Factorial;
i[ "Utils" ][ "CatmullRom" ] = TWEENLWF.Interpolation.Utils.CatmullRom;

}).call(this);
(function() {

var Base64 = {};

/**
 * @const
 * @type {string}
 */
Base64.Character =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

/**
 * @const
 * @type {string}
 */
Base64.RangeError = "INVALID_CHARACTER_ERR";

Base64.btoaArray = {};

/**
 * @const
 * @type {(Uint8Array|Array.<number>)}
 */
Base64.btoaArray.CharacterTable = (
/**
 * @param {string} chars
 * @return {(Uint8Array|Array.<number>)}
 */
function(chars) {
  /** @type {(Uint8Array|Array.<number>)} */
  var array =
    new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(chars.length);
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = array.length; i < il; ++i) {
    array[i] = chars.charCodeAt(i);
  }

  return array;
})(Base64.Character);

/**
 * @param {string} str base64 encoded string.
 * @return {Array.<number>|Uint8Array} decoded byte-array.
 */
Base64.atobArray = function(str) {
  /** @type {number} */
  var buffer = 0;
  /** @type {number} */
  var pos = 0;
  /** @type {number} */
  var length = str.length;
  /** @type {(Uint8Array|Array.<number>)} */
  var out;
  /** @type {number} */
  var outpos = 0;
  /** @type {number} */
  var bitlen = 0;
  /** @type {Array.<number>|Int16Array} */
  var decode = Base64.atobArray.DecodeTable;
  /** @type {number} */
  var decoded;
  /** @type {number} */
  var tmp;
  /** @type {number} */
  var mod;

  // remove padding
  while (str.charAt(length-1) === '=') {
    --length;
  }
  mod = length % 4;

  // create output buffer
  out = new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(
    ((length + 3) / 4 | 0) * 3 - [0, 0, 2, 1][mod]
  );

  // check range
  if (length % 4 === 1 || (str.length > 0 && length === 0)) {
    throw new Error(Base64.RangeError);
  }

  while (pos < length) {
    tmp = str.charCodeAt(pos++);
    decoded = tmp < 256 ? decode[tmp] : -1;

    // check character range
    if (decoded === -1) {
      throw new Error(Base64.RangeError);
    }

    // add buffer (6bit)
    buffer = (buffer << 6) + decoded;
    bitlen += 6;

    // decode byte
    if (bitlen >= 8) {
      bitlen -= 8;

      // extract byte
      tmp = buffer >> bitlen;

      // decode character
      out[outpos++] = tmp;

      // remove character bits
      buffer ^= tmp << bitlen;
    }
  }

  return out;
};

/**
 * @const
 * @type {(Array.<number>|Int16Array)}
 */
Base64.atobArray.DecodeTable = (
/**
 * @param {Uint8Array|Array.<number>} encodeTable character table.
 * @return {Int16Array|Array.<number>} decode table.
 */
function(encodeTable) {
  /** @type {(Int16Array|Array.<number>)} */
  var table = new (typeof Int16Array !== 'undefined' ? Int16Array : Array)(256);
  /** @type {number} */
  var i;
  /** @type {Array.<number>} */
  var array = encodeTable instanceof Array ?
    encodeTable : Array.prototype.slice.call(encodeTable);

  for (i = 0; i < 0xff; ++i) {
    table[i] = array.indexOf(i);
  }

  return table;
})(Base64.btoaArray.CharacterTable);

global["LWF"].Base64 = Base64;

}).call(this);
(function() {

var Zlib = {};

var USE_TYPEDARRAY = false;

if (typeof Uint8Array !== 'undefined' &&
		typeof Uint16Array !== 'undefined' &&
		typeof Uint32Array !== 'undefined') {
	USE_TYPEDARRAY = true;
}

/**
 * zlib.js
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
 * されている. これは Inflate との共存を考慮している為.
 */


/**
 * Compression Method
 * @enum {number}
 */
Zlib.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};


/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * zlib.adler32.js
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Adler32 checksum 実装.
 */



/**
 * Adler32 ハッシュ値の作成
 * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32 = function(array) {
  if (typeof(array) === 'string') {
    array = Zlib.Util.stringToByteArray(array);
  }
  return Zlib.Adler32.update(1, array);
};

/**
 * Adler32 ハッシュ値の更新
 * @param {number} adler 現在のハッシュ値.
 * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32.update = function(adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib.Adler32.OptimizationParameter ?
      Zlib.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
 * Adler32 最適化パラメータ
 * 現状では 1024 程度が最適.
 * @see http://jsperf.com/adler-32-simple-vs-optimized/3
 * @const
 * @type {number}
 */
Zlib.Adler32.OptimizationParameter = 1024;


/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Zlib.Huffman = {};

/**
 * build huffman table from length list.
 * @param {!(Array.<number>|Uint8Array)} lengths length list.
 * @return {!Array} huffman table.
 */
Zlib.Huffman.buildHuffmanTable = function(lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limit. */
  var jl;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        for (j = reversed; j < size; j += skip) {
          table[j] = (bitLength << 16) | i;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};



/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
 * @constructor
 * @param {!(Uint8Array|Array.<number>)} input input buffer.
 * @param {Object} opt_params option parameter.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
 *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
 */
Zlib.RawInflate = function(input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array.<(Array.<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;
  /** @type {!(Uint8Array|Array.<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      this.op = Zlib.RawInflate.MaxBackwardLength;
      this.output =
        new (USE_TYPEDARRAY ? Uint8Array : Array)(
          Zlib.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib.RawInflate.MaxCopyLength
        );
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
      this.expandBuffer = this.expandBufferAdaptive;
      this.concatBuffer = this.concatBufferDynamic;
      this.decodeHuffman = this.decodeHuffmanAdaptive;
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
 * @enum {number}
 */
Zlib.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
 * decompress.
 * @return {!(Uint8Array|Array.<number>)} inflated buffer.
 */
Zlib.RawInflate.prototype.decompress = function() {
  while (!this.bfinal) {
    this.parseBlock();
  }

  return this.concatBuffer();
};

/**
 * @const
 * @type {number} max backward length for LZ77.
 */
Zlib.RawInflate.MaxBackwardLength = 32768;

/**
 * @const
 * @type {number} max copy length for LZ77.
 */
Zlib.RawInflate.MaxCopyLength = 258;

/**
 * huffman order
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.Order = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
 * huffman length code table.
 * @const
 * @type {!(Array.<number>|Uint16Array)}
 */
Zlib.RawInflate.LengthCodeTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
 * huffman length extra-bits table.
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.LengthExtraTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
 * huffman dist code table.
 * @const
 * @type {!(Array.<number>|Uint16Array)}
 */
Zlib.RawInflate.DistCodeTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
 * huffman dist extra-bits table.
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.DistExtraTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
 * fixed huffman length code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedLiteralLengthTable = (function(table) {
  return table;
})((function() {
  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
      (i <= 255) ? 9 :
      (i <= 279) ? 7 :
      8;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * fixed huffman distance code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedDistanceTable = (function(table) {
  return table;
})((function() {
  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * parse deflated block.
 */
Zlib.RawInflate.prototype.parseBlock = function() {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
 * read inflate bits
 * @param {number} length bits length.
 * @return {number} read bits.
 */
Zlib.RawInflate.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    octet = input[ip++];
    if (octet === void 0) {
      throw new Error('input buffer is broken');
    }

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
 * read huffman code using table
 * @param {Array} table huffman code table.
 * @return {number} huffman code.
 */
Zlib.RawInflate.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array.<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    octet = input[ip++];
    if (octet === void 0) {
      throw new Error('input buffer is broken');
    }
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
 * parse uncompressed block.
 */
Zlib.RawInflate.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} input byte. */
  var octet;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len (1st)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: LEN (first byte)');
  }
  len = octet;

  // len (2nd)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: LEN (second byte)');
  }
  len |= octet << 8;

  // nlen (1st)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: NLEN (first byte)');
  }
  nlen = octet;

  // nlen (2nd)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: NLEN (second byte)');
  }
  nlen |= octet << 8;

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        if (USE_TYPEDARRAY) {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        } else {
          while (preCopy--) {
            output[op++] = input[ip++];
          }
        }
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBuffer({fixRatio: 2});
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  if (USE_TYPEDARRAY) {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  } else {
    while (len--) {
      output[op++] = input[ip++];
    }
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
 * parse fixed huffman block.
 */
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {
  this.decodeHuffman(
    Zlib.RawInflate.FixedLiteralLengthTable,
    Zlib.RawInflate.FixedDistanceTable
  );
};

/**
 * parse dynamic huffman block.
 */
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array.<number>)} code lengths. */
  var codeLengths =
    new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array.<number>)} literal and length code lengths. */
  var litlenLengths;
  /** @type {!(Uint8Array|Array.<number>)} distance code lengths. */
  var distLengths;
  /** @type {number} loop counter. */
  var i;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
  }
  codeLengthsTable = buildHuffmanTable(codeLengths);

  /**
   * decode function
   * @param {number} num number of lengths.
   * @param {!Array} table code lengths table.
   * @param {!(Uint8Array|Array.<number>)} lengths code lengths buffer.
   * @return {!(Uint8Array|Array.<number>)} code lengths buffer.
   */
  function decode(num, table, lengths) {
    /** @type {number} */
    var code;
    /** @type {number} */
    var prev;
    /** @type {number} */
    var repeat;
    /** @type {number} */
    var i;

    for (i = 0; i < num;) {
      code = this.readCodeByTable(table);
      switch (code) {
        case 16:
          repeat = 3 + this.readBits(2);
          while (repeat--) { lengths[i++] = prev; }
          break;
        case 17:
          repeat = 3 + this.readBits(3);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        case 18:
          repeat = 11 + this.readBits(7);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        default:
          lengths[i++] = code;
          prev = code;
          break;
      }
    }

    return lengths;
  }

  // literal and length code
  litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);

  // distance code
  distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);

  //return;
  this.decodeHuffman(
    buildHuffmanTable(decode.call(this, hlit, codeLengthsTable, litlenLengths)),
    buildHuffmanTable(decode.call(this, hdist, codeLengthsTable, distLengths))
  );
};

/**
 * decode huffman code
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffman = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBuffer();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * decode huffman code (adaptive)
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBuffer();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * expand output buffer.
 * @param {Object=} opt_param option parameters.
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.expandBuffer = function(opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer =
    new (USE_TYPEDARRAY ? Uint8Array : Array)(
        this.op - Zlib.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
  /** @type {number} copy index. */
  var i;
  /** @type {number} copy limit */
  var il;

  var output = this.output;

  // copy to output buffer
  if (USE_TYPEDARRAY) {
    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
  } else {
    for (i = 0, il = buffer.length; i < il; ++i) {
      buffer[i] = output[i + Zlib.RawInflate.MaxBackwardLength];
    }
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  if (USE_TYPEDARRAY) {
    output.set(
      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)
    );
  } else {
    for (i = 0; i < Zlib.RawInflate.MaxBackwardLength; ++i) {
      output[i] = output[backward + i];
    }
  }

  this.op = Zlib.RawInflate.MaxBackwardLength;

  return output;
};

/**
 * expand output buffer. (adaptive)
 * @param {Object=} opt_param option parameters.
 * @return {!(Array.<number>|Uint8Array)} output buffer pointer.
 */
Zlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  if (USE_TYPEDARRAY) {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  } else {
    buffer = output;
  }

  this.output = buffer;

  return this.output;
};

/**
 * concat output buffer.
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBuffer = function() {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return USE_TYPEDARRAY ?
      this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) :
      this.output.slice(Zlib.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
 * concat output buffer. (dynamic)
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBufferDynamic = function() {
  /** @type {Array.<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  if (USE_TYPEDARRAY) {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  } else {
    if (this.output.length > op) {
      this.output.length = op;
    }
    buffer = this.output;
  }

  this.buffer = buffer;

  return this.buffer;
};




/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @constructor
 * @param {!(Uint8Array|Array)} input deflated buffer.
 * @param {Object=} opt_params option parameters.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
 *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
 *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
 */
Zlib.Inflate = function(input, opt_params) {
  /** @type {number} */
  var bufferSize;
  /** @type {Zlib.Inflate.BufferType} */
  var bufferType;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
}

/**
 * @enum {number}
 */
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;

/**
 * decompress.
 * @return {!(Uint8Array|Array)} inflated buffer.
 */
Zlib.Inflate.prototype.decompress = function() {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};




/* vim:set expandtab ts=2 sw=2 tw=80: */

	global["LWF"].Zlib = Zlib;

}).call(this);
