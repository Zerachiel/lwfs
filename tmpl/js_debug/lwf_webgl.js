// Copyright (c) 2012-2013 GREE, Inc - http://git.io/uvS3hQ
// Copyright (c) 2010-2012 Tween.js authors - http://git.io/tiDrNw
// Copyright (c) 2001 Robert Penner - http://goo.gl/Qjqc0
// Copyright (c) 2012 imaya - http://git.io/SKEzIQ http://git.io/cC8gDw
if (typeof global === "undefined" && typeof window !== "undefined") {
	/* Browsers */
	global = window;
} else if (typeof window === "undefined" && typeof self !== "undefined") {
	/* Workers */
	global = self;
}
// Generated by CoffeeScript 1.6.2
(function() { var __FILE__ = 'lwf_webgl.js';
  var Align, AlphaTransform, Animation, Bitmap, BitmapEx, Button, ButtonEventHandlers, ClipEvent, Color, ColorTransform, Condition, Constant, ControlType, Data, EventHandlers, Format, GObjType, Graphic, HTML5TextContext, HTML5TextRenderer, IObject, LObject, LWF, LWFContainer, LWFLoader, LWFLoaderWithArray, LWFLoaderWithArrayBuffer, Loader, Matrix, Movie, MovieEventHandlers, NullRendererFactory, Particle, Point, ProgramObject, Property, Text, Translate, Type, Utility, WebGLBitmapContext, WebGLBitmapRenderer, WebGLRendererFactory, WebGLResourceCache, WebGLTextContext, WebGLTextRenderer, WebkitCSSDomElementRenderer, WebkitCSSRendererFactory, WebkitCSSResourceCache, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Point = (function() {
    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    return Point;

  })();

  Translate = (function() {
    function Translate(translateX, translateY) {
      this.translateX = translateX != null ? translateX : 0;
      this.translateY = translateY != null ? translateY : 0;
    }

    return Translate;

  })();

  Matrix = (function() {
    function Matrix(scaleX, scaleY, skew0, skew1, translateX, translateY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.skew0 = skew0;
      this.skew1 = skew1;
      this.translateX = translateX;
      this.translateY = translateY;
      if (this.scaleX == null) {
        this.clear();
      }
    }

    Matrix.prototype.clear = function() {
      this.scaleX = 1;
      this.scaleY = 1;
      this.skew0 = 0;
      this.skew1 = 0;
      this.translateX = 0;
      this.translateY = 0;
    };

    Matrix.prototype.set = function(m) {
      this.scaleX = m.scaleX;
      this.scaleY = m.scaleY;
      this.skew0 = m.skew0;
      this.skew1 = m.skew1;
      this.translateX = m.translateX;
      this.translateY = m.translateY;
      return this;
    };

    Matrix.prototype.setWithComparing = function(m) {
      var changed, scaleX, scaleY, skew0, skew1, translateX, translateY;

      if (m === null) {
        return false;
      }
      scaleX = m.scaleX;
      scaleY = m.scaleY;
      skew0 = m.skew0;
      skew1 = m.skew1;
      translateX = m.translateX;
      translateY = m.translateY;
      changed = false;
      if (this.scaleX !== scaleX) {
        this.scaleX = scaleX;
        changed = true;
      }
      if (this.scaleY !== scaleY) {
        this.scaleY = scaleY;
        changed = true;
      }
      if (this.skew0 !== skew0) {
        this.skew0 = skew0;
        changed = true;
      }
      if (this.skew1 !== skew1) {
        this.skew1 = skew1;
        changed = true;
      }
      if (this.translateX !== translateX) {
        this.translateX = translateX;
        changed = true;
      }
      if (this.translateY !== translateY) {
        this.translateY = translateY;
        changed = true;
      }
      return changed;
    };

    return Matrix;

  })();

  Color = (function() {
    function Color(red, green, blue, alpha) {
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = alpha;
      if (this.red == null) {
        this.red = 0;
        this.green = 0;
        this.blue = 0;
        this.alpha = 0;
      }
    }

    Color.prototype.set = function(r, g, b, a) {
      var c;

      if (typeof r === "object") {
        c = r;
        this.red = c.red;
        this.green = c.green;
        this.blue = c.blue;
        this.alpha = c.alpha;
      } else {
        this.red = r;
        this.green = g;
        this.blue = b;
        this.alpha = a;
      }
    };

    return Color;

  })();

  AlphaTransform = (function() {
    function AlphaTransform(alpha) {
      this.alpha = alpha;
    }

    return AlphaTransform;

  })();

  ColorTransform = (function() {
    function ColorTransform(mr, mg, mb, ma, ar, ag, ab, aa) {
      this.multi = new Color(mr, mg, mb, ma);
      if (mr == null) {
        this.clear();
      }
    }

    ColorTransform.prototype.clear = function() {
      this.multi.set(1, 1, 1, 1);
    };

    ColorTransform.prototype.set = function(c) {
      this.multi.set(c.multi);
      return this;
    };

    ColorTransform.prototype.setWithComparing = function(c) {
      var alpha, blue, changed, cm, green, m, red;

      if (c === null) {
        return false;
      }
      cm = c.multi;
      red = cm.red;
      green = cm.green;
      blue = cm.blue;
      alpha = cm.alpha;
      changed = false;
      m = this.multi;
      if (m.red !== red) {
        m.red = red;
        changed = true;
      }
      if (m.green !== green) {
        m.green = green;
        changed = true;
      }
      if (m.blue !== blue) {
        m.blue = blue;
        changed = true;
      }
      if (m.alpha !== alpha) {
        m.alpha = alpha;
        changed = true;
      }
      return changed;
    };

    return ColorTransform;

  })();

  Format = (function() {
    function Format() {}

    Format.Constant = (function() {
      function Constant() {}

      Constant.HEADER_SIZE = 324;

      Constant.FORMAT_VERSION_0 = 0x12;

      Constant.FORMAT_VERSION_1 = 0x10;

      Constant.FORMAT_VERSION_2 = 0x10;

      Constant.FORMAT_TYPE = 0;

      Constant.OPTION_USE_SCRIPT = 1 << 0;

      Constant.OPTION_USE_TEXTUREATLAS = 1 << 1;

      Constant.MATRIX_FLAG = 1 << 31;

      Constant.COLORTRANSFORM_FLAG = 1 << 31;

      Constant.TEXTUREFORMAT_NORMAL = 0;

      Constant.TEXTUREFORMAT_PREMULTIPLIEDALPHA = 1;

      return Constant;

    })();

    Format.StringBase = (function() {
      function StringBase(stringId) {
        this.stringId = stringId;
      }

      return StringBase;

    })();

    Format.Texture = (function() {
      function Texture(stringId, format, width, height, scale) {
        this.stringId = stringId;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      Texture.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return Texture;

    })();

    Format.TextureReplacement = (function() {
      function TextureReplacement(filename, format, width, height, scale) {
        this.filename = filename;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      return TextureReplacement;

    })();

    Format.TextureFragment = (function() {
      function TextureFragment(stringId, textureId, rotated, x, y, u, v, w, h) {
        this.stringId = stringId;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      TextureFragment.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return TextureFragment;

    })();

    Format.TextureFragmentReplacement = (function() {
      function TextureFragmentReplacement(filename, textureId, rotated, x, y, u, v, w, h) {
        this.filename = filename;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      return TextureFragmentReplacement;

    })();

    Format.Bitmap = (function() {
      function Bitmap(matrixId, textureFragmentId) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
      }

      return Bitmap;

    })();

    Format.BitmapEx = (function() {
      BitmapEx.Attribute = (function() {
        function Attribute() {}

        Attribute.REPEAT_S = 1 << 0;

        Attribute.REPEAT_T = 1 << 1;

        return Attribute;

      })();

      function BitmapEx(matrixId, textureFragmentId, attribute, u, v, w, h) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
        this.attribute = attribute;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      return BitmapEx;

    }).call(this);

    Format.Font = (function() {
      function Font(stringId, letterSpacing) {
        this.stringId = stringId;
        this.letterSpacing = letterSpacing;
      }

      return Font;

    })();

    Format.TextProperty = (function() {
      TextProperty.Align = (function() {
        function Align() {}

        Align.LEFT = 0;

        Align.RIGHT = 1;

        Align.CENTER = 2;

        Align.ALIGN_MASK = 0x3;

        Align.VERTICAL_BOTTOM = 1 << 2;

        Align.VERTICAL_MIDDLE = 2 << 2;

        Align.VERTICAL_MASK = 0xc;

        return Align;

      })();

      function TextProperty(maxLength, fontId, fontHeight, align, leftMargin, rightMargin, letterSpacing, leading, strokeColorId, strokeWidth, shadowColorId, shadowOffsetX, shadowOffsetY, shadowBlur) {
        this.maxLength = maxLength;
        this.fontId = fontId;
        this.fontHeight = fontHeight;
        this.align = align;
        this.leftMargin = leftMargin;
        this.rightMargin = rightMargin;
        this.letterSpacing = letterSpacing;
        this.leading = leading;
        this.strokeColorId = strokeColorId;
        this.strokeWidth = strokeWidth;
        this.shadowColorId = shadowColorId;
        this.shadowOffsetX = shadowOffsetX;
        this.shadowOffsetY = shadowOffsetY;
        this.shadowBlur = shadowBlur;
      }

      return TextProperty;

    }).call(this);

    Format.Text = (function() {
      function Text(matrixId, nameStringId, textPropertyId, stringId, colorId, width, height) {
        this.matrixId = matrixId;
        this.nameStringId = nameStringId;
        this.textPropertyId = textPropertyId;
        this.stringId = stringId;
        this.colorId = colorId;
        this.width = width;
        this.height = height;
      }

      return Text;

    })();

    Format.ParticleData = (function() {
      function ParticleData(stringId) {
        this.stringId = stringId;
      }

      return ParticleData;

    })();

    Format.Particle = (function() {
      function Particle(matrixId, colorTransformId, particleDataId) {
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.particleDataId = particleDataId;
      }

      return Particle;

    })();

    Format.ProgramObject = (function(_super) {
      __extends(ProgramObject, _super);

      function ProgramObject(stringId, width, height, matrixId, colorTransformId) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        ProgramObject.__super__.constructor.call(this, stringId);
      }

      return ProgramObject;

    })(Format.StringBase);

    Format.GraphicObject = (function() {
      GraphicObject.Type = (function() {
        function Type() {}

        Type.BITMAP = 0;

        Type.BITMAPEX = 1;

        Type.TEXT = 2;

        Type.GRAPHIC_OBJECT_MAX = 3;

        return Type;

      })();

      function GraphicObject(graphicObjectType, graphicObjectId) {
        this.graphicObjectType = graphicObjectType;
        this.graphicObjectId = graphicObjectId;
      }

      return GraphicObject;

    }).call(this);

    Format.Graphic = (function() {
      function Graphic(graphicObjectId, graphicObjects) {
        this.graphicObjectId = graphicObjectId;
        this.graphicObjects = graphicObjects;
      }

      return Graphic;

    })();

    Format.LObject = (function() {
      LObject.Type = (function() {
        function Type() {}

        Type.BUTTON = 0;

        Type.GRAPHIC = 1;

        Type.MOVIE = 2;

        Type.BITMAP = 3;

        Type.BITMAPEX = 4;

        Type.TEXT = 5;

        Type.PARTICLE = 6;

        Type.PROGRAMOBJECT = 7;

        Type.ATTACHEDMOVIE = 8;

        Type.OBJECT_MAX = 9;

        return Type;

      })();

      function LObject(objectType, objectId) {
        this.objectType = objectType;
        this.objectId = objectId;
      }

      return LObject;

    }).call(this);

    Format.Animation = (function() {
      function Animation(animationOffset, animationLength) {
        this.animationOffset = animationOffset;
        this.animationLength = animationLength;
      }

      return Animation;

    })();

    Format.ButtonCondition = (function() {
      ButtonCondition.Condition = (function() {
        function Condition() {}

        Condition.ROLLOVER = 1 << 0;

        Condition.ROLLOUT = 1 << 1;

        Condition.PRESS = 1 << 2;

        Condition.RELEASE = 1 << 3;

        Condition.DRAGOUT = 1 << 4;

        Condition.DRAGOVER = 1 << 5;

        Condition.RELEASEOUTSIDE = 1 << 6;

        Condition.KEYPRESS = 1 << 7;

        return Condition;

      })();

      function ButtonCondition(condition, keyCode, animationId) {
        this.condition = condition;
        this.keyCode = keyCode;
        this.animationId = animationId;
      }

      return ButtonCondition;

    }).call(this);

    Format.Button = (function() {
      function Button(width, height, matrixId, colorTransformId, conditionId, conditions) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.conditionId = conditionId;
        this.conditions = conditions;
      }

      return Button;

    })();

    Format.Label = (function(_super) {
      __extends(Label, _super);

      function Label(stringId, frameNo) {
        this.frameNo = frameNo;
        Label.__super__.constructor.call(this, stringId);
      }

      return Label;

    })(Format.StringBase);

    Format.InstanceName = (function(_super) {
      __extends(InstanceName, _super);

      function InstanceName(stringId) {
        InstanceName.__super__.constructor.apply(this, arguments);
      }

      return InstanceName;

    })(Format.StringBase);

    Format.Event = (function(_super) {
      __extends(Event, _super);

      function Event(stringId) {
        Event.__super__.constructor.apply(this, arguments);
      }

      return Event;

    })(Format.StringBase);

    Format.String = (function() {
      function String(stringOffset, stringLength) {
        this.stringOffset = stringOffset;
        this.stringLength = stringLength;
      }

      return String;

    })();

    Format.Place = (function() {
      function Place(depth, objectId, instanceId, matrixId) {
        this.depth = depth;
        this.objectId = objectId;
        this.instanceId = instanceId;
        this.matrixId = matrixId;
      }

      return Place;

    })();

    Format.ControlMoveM = (function() {
      function ControlMoveM(placeId, matrixId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
      }

      return ControlMoveM;

    })();

    Format.ControlMoveC = (function() {
      function ControlMoveC(placeId, colorTransformId) {
        this.placeId = placeId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveC;

    })();

    Format.ControlMoveMC = (function() {
      function ControlMoveMC(placeId, matrixId, colorTransformId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveMC;

    })();

    Format.Control = (function() {
      Control.Type = (function() {
        function Type() {}

        Type.MOVE = 0;

        Type.MOVEM = 1;

        Type.MOVEC = 2;

        Type.MOVEMC = 3;

        Type.ANIMATION = 4;

        Type.CONTROL_MAX = 5;

        return Type;

      })();

      function Control(controlType, controlId) {
        this.controlType = controlType;
        this.controlId = controlId;
      }

      return Control;

    }).call(this);

    Format.Frame = (function() {
      function Frame(controlOffset, controls) {
        this.controlOffset = controlOffset;
        this.controls = controls;
      }

      return Frame;

    })();

    Format.MovieClipEvent = (function() {
      MovieClipEvent.ClipEvent = (function() {
        function ClipEvent() {}

        ClipEvent.LOAD = 1 << 0;

        ClipEvent.UNLOAD = 1 << 1;

        ClipEvent.ENTERFRAME = 1 << 2;

        return ClipEvent;

      })();

      function MovieClipEvent(clipEvent, animationId) {
        this.clipEvent = clipEvent;
        this.animationId = animationId;
      }

      return MovieClipEvent;

    }).call(this);

    Format.Movie = (function() {
      function Movie(depths, labelOffset, labels, frameOffset, frames, clipEventId, clipEvents) {
        this.depths = depths;
        this.labelOffset = labelOffset;
        this.labels = labels;
        this.frameOffset = frameOffset;
        this.frames = frames;
        this.clipEventId = clipEventId;
        this.clipEvents = clipEvents;
      }

      return Movie;

    })();

    Format.MovieLinkage = (function(_super) {
      __extends(MovieLinkage, _super);

      function MovieLinkage(stringId, movieId) {
        this.movieId = movieId;
        MovieLinkage.__super__.constructor.call(this, stringId);
      }

      return MovieLinkage;

    })(Format.StringBase);

    Format.ItemArray = (function() {
      function ItemArray(offset, length) {
        this.offset = offset;
        this.length = length;
      }

      return ItemArray;

    })();

    Format.Header = (function() {
      function Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength) {
        this.id0 = id0;
        this.id1 = id1;
        this.id2 = id2;
        this.id3 = id3;
        this.formatVersion0 = formatVersion0;
        this.formatVersion1 = formatVersion1;
        this.formatVersion2 = formatVersion2;
        this.option = option;
        this.width = width;
        this.height = height;
        this.frameRate = frameRate;
        this.rootMovieId = rootMovieId;
        this.nameStringId = nameStringId;
        this.backgroundColor = backgroundColor;
        this.stringBytes = stringBytes;
        this.animationBytes = animationBytes;
        this.translate = translate;
        this.matrix = matrix;
        this.color = color;
        this.alphaTransform = alphaTransform;
        this.colorTransform = colorTransform;
        this.objectData = objectData;
        this.texture = texture;
        this.textureFragment = textureFragment;
        this.bitmap = bitmap;
        this.bitmapEx = bitmapEx;
        this.font = font;
        this.textProperty = textProperty;
        this.text = text;
        this.particleData = particleData;
        this.particle = particle;
        this.programObject = programObject;
        this.graphicObject = graphicObject;
        this.graphic = graphic;
        this.animation = animation;
        this.buttonCondition = buttonCondition;
        this.button = button;
        this.label = label;
        this.instanceName = instanceName;
        this.eventData = eventData;
        this.place = place;
        this.controlMoveM = controlMoveM;
        this.controlMoveC = controlMoveC;
        this.controlMoveMC = controlMoveMC;
        this.control = control;
        this.frame = frame;
        this.movieClipEvent = movieClipEvent;
        this.movie = movie;
        this.movieLinkage = movieLinkage;
        this.stringData = stringData;
        this.lwfLength = lwfLength;
      }

      return Header;

    })();

    return Format;

  }).call(this);

  Align = Format.TextProperty.Align;

  ClipEvent = Format.MovieClipEvent.ClipEvent;

  Condition = Format.ButtonCondition.Condition;

  Constant = Format.Constant;

  Type = Format.LObject.Type;

  ControlType = Format.Control.Type;

  GObjType = Format.GraphicObject.Type;

  Animation = (function() {
    function Animation() {}

    Animation.END = 0;

    Animation.PLAY = 1;

    Animation.STOP = 2;

    Animation.NEXTFRAME = 3;

    Animation.PREVFRAME = 4;

    Animation.GOTOFRAME = 5;

    Animation.GOTOLABEL = 6;

    Animation.SETTARGET = 7;

    Animation.EVENT = 8;

    Animation.CALL = 9;

    Animation.INSTANCE_TARGET_ROOT = -1;

    Animation.INSTANCE_TARGET_PARENT = -2;

    return Animation;

  })();

  Data = (function() {
    function Data(header, translates, matrices, colors, alphaTransforms, colorTransforms, objects, textures, textureFragments, bitmaps, bitmapExs, fonts, textProperties, texts, particleDatas, particles, programObjects, graphicObjects, graphics, animations, buttonConditions, buttons, labels, instanceNames, events, places, controlMoveMs, controlMoveCs, controlMoveMCs, controls, frames, movieClipEvents, movies, movieLinkages, strings) {
      var d;

      this.header = header;
      this.translates = translates;
      this.matrices = matrices;
      this.colors = colors;
      this.alphaTransforms = alphaTransforms;
      this.colorTransforms = colorTransforms;
      this.objects = objects;
      this.textures = textures;
      this.textureFragments = textureFragments;
      this.bitmaps = bitmaps;
      this.bitmapExs = bitmapExs;
      this.fonts = fonts;
      this.textProperties = textProperties;
      this.texts = texts;
      this.particleDatas = particleDatas;
      this.particles = particles;
      this.programObjects = programObjects;
      this.graphicObjects = graphicObjects;
      this.graphics = graphics;
      this.animations = animations;
      this.buttonConditions = buttonConditions;
      this.buttons = buttons;
      this.labels = labels;
      this.instanceNames = instanceNames;
      this.events = events;
      this.places = places;
      this.controlMoveMs = controlMoveMs;
      this.controlMoveCs = controlMoveCs;
      this.controlMoveMCs = controlMoveMCs;
      this.controls = controls;
      this.frames = frames;
      this.movieClipEvents = movieClipEvents;
      this.movies = movies;
      this.movieLinkages = movieLinkages;
      this.strings = strings;
      if (this.header.header != null) {
        d = this.header;
        this.header = d.header;
        this.translates = d.translates;
        this.matrices = d.matrices;
        this.colors = d.colors;
        this.alphaTransforms = d.alphaTransforms;
        this.colorTransforms = d.colorTransforms;
        this.objects = d.objects;
        this.textures = d.textures;
        this.textureFragments = d.textureFragments;
        this.bitmaps = d.bitmaps;
        this.bitmapExs = d.bitmapExs;
        this.fonts = d.fonts;
        this.textProperties = d.textProperties;
        this.texts = d.texts;
        this.particleDatas = d.particleDatas;
        this.particles = d.particles;
        this.programObjects = d.programObjects;
        this.graphicObjects = d.graphicObjects;
        this.graphics = d.graphics;
        this.animations = d.animations;
        this.buttonConditions = d.buttonConditions;
        this.buttons = d.buttons;
        this.labels = d.labels;
        this.instanceNames = d.instanceNames;
        this.events = d.events;
        this.places = d.places;
        this.controlMoveMs = d.controlMoveMs;
        this.controlMoveCs = d.controlMoveCs;
        this.controlMoveMCs = d.controlMoveMCs;
        this.controls = d.controls;
        this.frames = d.frames;
        this.movieClipEvents = d.movieClipEvents;
        this.movies = d.movies;
        this.movieLinkages = d.movieLinkages;
        this.strings = d.strings;
        this.stringMap = d.stringMap;
        this.eventMap = d.eventMap;
        this.instanceNameMap = d.instanceNameMap;
        this.movieLinkageMap = d.movieLinkageMap;
        this.movieLinkageNameMap = d.movieLinkageNameMap;
        this.programObjectMap = d.programObjectMap;
        this.labelMap = d.labelMap;
        this.useScript = d.useScript;
        this.useTextureAtlas = d.useTextureAtlas;
      } else {
        this.stringMap = {};
        this.eventMap = {};
        this.instanceNameMap = {};
        this.movieLinkageMap = {};
        this.movieLinkageNameMap = {};
        this.programObjectMap = {};
        this.labelMap = [];
        if (this.header != null) {
          this.useScript = (this.header.option & Format.Constant.OPTION_USE_SCRIPT) !== 0;
          this.useTextureAtlas = (this.header.option & Format.Constant.OPTION_USE_TEXTUREATLAS) !== 0;
        } else {
          this.useScript = false;
          this.useTextureAtlas = false;
        }
      }
    }

    Data.prototype.check = function() {
      if ((this.header != null) && this.header.id0 === 'L' && this.header.id1 === 'W' && this.header.id2 === 'F' && this.header.formatVersion0 === Format.Constant.FORMAT_VERSION_0 && this.header.formatVersion1 === Format.Constant.FORMAT_VERSION_1 && this.header.formatVersion2 === Format.Constant.FORMAT_VERSION_2) {
        return true;
      } else {
        return false;
      }
    };

    Data.prototype.name = function() {
      return this.strings[this.header.nameStringId];
    };

    Data.prototype.replaceTexture = function(index, textureReplacement) {
      if (index < 0 || index >= textures.length) {
        return false;
      }
      textures[index] = textureReplacement;
      return true;
    };

    Data.prototype.replaceTextureFragment = function(index, textureFragmentReplacement) {
      if (index < 0 || index >= textureFragments.length) {
        return false;
      }
      textureFragments[index] = textureFragmentReplacement;
      return true;
    };

    return Data;

  })();

  LWFLoader = (function() {
    function LWFLoader() {}

    LWFLoader.prototype.readByte = function() {
      return this.d.charCodeAt(this.index++) & 0xff;
    };

    LWFLoader.prototype.readChar = function() {
      return String.fromCharCode(this.readByte());
    };

    LWFLoader.prototype.readBytes = function(length) {
      var bytes;

      bytes = this.d.substr(this.index, length);
      this.index += length;
      return bytes;
    };

    LWFLoader.prototype.readInt32 = function() {
      return (this.readByte() << 0) + (this.readByte() << 8) + (this.readByte() << 16) + (this.readByte() << 24);
    };

    LWFLoader.prototype.readSingle = function() {
      var b0, b1, b2, b3, exp, sig, sign;

      b3 = this.readByte();
      b2 = this.readByte();
      b1 = this.readByte();
      b0 = this.readByte();
      sign = 1 - (2 * (b0 >> 7));
      exp = (((b0 << 1) & 0xff) | (b1 >> 7)) - 127;
      sig = ((b1 & 0x7f) << 16) | (b2 << 8) | b3;
      if (sig === 0 && exp === -127) {
        return 0.0;
      }
      return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
    };

    LWFLoader.prototype.loadTranslate = function() {
      return new Translate(this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadMatrix = function() {
      return new Matrix(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadColor = function() {
      return new Color(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadAlphaTransform = function() {
      return new AlphaTransform(this.readSingle());
    };

    LWFLoader.prototype.loadColorTransform = function() {
      var add, multi;

      multi = this.loadColor();
      add = this.loadColor();
      return new ColorTransform(multi.red, multi.green, multi.blue, multi.alpha);
    };

    LWFLoader.prototype.loadTexture = function() {
      return new Format.Texture(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle());
    };

    LWFLoader.prototype.loadTextureFragment = function() {
      return new Format.TextureFragment(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadBitmap = function() {
      return new Format.Bitmap(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadBitmapEx = function() {
      return new Format.BitmapEx(this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadFont = function() {
      return new Format.Font(this.readInt32(), this.readSingle());
    };

    LWFLoader.prototype.loadTextProperty = function() {
      return new Format.TextProperty(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadText = function() {
      return new Format.Text(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadParticleData = function() {
      return new Format.ParticleData(this.readInt32());
    };

    LWFLoader.prototype.loadParticle = function() {
      return new Format.Particle(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadProgramObject = function() {
      return new Format.ProgramObject(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphicObject = function() {
      return new Format.GraphicObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphic = function() {
      return new Format.Graphic(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadObject = function() {
      return new Format.LObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadAnimation = function() {
      return new Format.Animation(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButtonCondition = function() {
      return new Format.ButtonCondition(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButton = function() {
      return new Format.Button(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadLabel = function() {
      return new Format.Label(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadInstanceName = function() {
      return new Format.InstanceName(this.readInt32());
    };

    LWFLoader.prototype.loadEvent = function() {
      return new Format.Event(this.readInt32());
    };

    LWFLoader.prototype.loadString = function() {
      return new Format.String(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadPlace = function() {
      return new Format.Place(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveM = function() {
      return new Format.ControlMoveM(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveC = function() {
      return new Format.ControlMoveC(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveMC = function() {
      return new Format.ControlMoveMC(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControl = function() {
      return new Format.Control(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadFrame = function() {
      return new Format.Frame(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieClipEvent = function() {
      return new Format.MovieClipEvent(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovie = function() {
      return new Format.Movie(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieLinkage = function() {
      return new Format.MovieLinkage(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadItemArray = function() {
      return new Format.ItemArray(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadHeader = function() {
      var alphaTransform, animation, animationBytes, backgroundColor, bitmap, bitmapEx, button, buttonCondition, color, colorTransform, control, controlMoveC, controlMoveM, controlMoveMC, eventData, font, formatVersion0, formatVersion1, formatVersion2, frame, frameRate, graphic, graphicObject, height, id0, id1, id2, id3, instanceName, label, lwfLength, matrix, movie, movieClipEvent, movieLinkage, nameStringId, objectData, option, particle, particleData, place, programObject, rootMovieId, stringBytes, stringData, text, textProperty, texture, textureFragment, translate, width;

      id0 = this.readChar();
      id1 = this.readChar();
      id2 = this.readChar();
      id3 = this.readChar();
      formatVersion0 = this.readByte();
      formatVersion1 = this.readByte();
      formatVersion2 = this.readByte();
      option = this.readByte();
      width = this.readInt32();
      height = this.readInt32();
      frameRate = this.readInt32();
      rootMovieId = this.readInt32();
      nameStringId = this.readInt32();
      backgroundColor = this.readInt32();
      stringBytes = this.loadItemArray();
      animationBytes = this.loadItemArray();
      translate = this.loadItemArray();
      matrix = this.loadItemArray();
      color = this.loadItemArray();
      alphaTransform = this.loadItemArray();
      colorTransform = this.loadItemArray();
      objectData = this.loadItemArray();
      texture = this.loadItemArray();
      textureFragment = this.loadItemArray();
      bitmap = this.loadItemArray();
      bitmapEx = this.loadItemArray();
      font = this.loadItemArray();
      textProperty = this.loadItemArray();
      text = this.loadItemArray();
      particleData = this.loadItemArray();
      particle = this.loadItemArray();
      programObject = this.loadItemArray();
      graphicObject = this.loadItemArray();
      graphic = this.loadItemArray();
      animation = this.loadItemArray();
      buttonCondition = this.loadItemArray();
      button = this.loadItemArray();
      label = this.loadItemArray();
      instanceName = this.loadItemArray();
      eventData = this.loadItemArray();
      place = this.loadItemArray();
      controlMoveM = this.loadItemArray();
      controlMoveC = this.loadItemArray();
      controlMoveMC = this.loadItemArray();
      control = this.loadItemArray();
      frame = this.loadItemArray();
      movieClipEvent = this.loadItemArray();
      movie = this.loadItemArray();
      movieLinkage = this.loadItemArray();
      stringData = this.loadItemArray();
      lwfLength = this.readInt32();
      return new Format.Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength);
    };

    LWFLoader.prototype.load = function(d) {
      var a, animationBytes, animations, c, c2, c3, code, data, eventMap, header, i, instanceNameMap, l, labelMap, m, map, movieLinkageMap, movieLinkageNameMap, o, programObjectMap, s, str, stringBytes, stringDatas, stringMap, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _s;

      this.d = d;
      this.index = 0;
      header = this.loadHeader();
      data = new Data(header);
      if (!data.check()) {
        return null;
      }
      stringBytes = this.readBytes(header.stringBytes.length);
      animationBytes = this.readBytes(header.animationBytes.length);
      data.translates = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.translate.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTranslate());
        }
        return _results;
      }).call(this);
      data.matrices = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.matrix.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMatrix());
        }
        return _results;
      }).call(this);
      data.colors = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.color.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColor());
        }
        return _results;
      }).call(this);
      data.alphaTransforms = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.alphaTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAlphaTransform());
        }
        return _results;
      }).call(this);
      data.colorTransforms = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.colorTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColorTransform());
        }
        return _results;
      }).call(this);
      data.objects = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.objectData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadObject());
        }
        return _results;
      }).call(this);
      data.textures = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.texture.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTexture());
        }
        return _results;
      }).call(this);
      data.textureFragments = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.textureFragment.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTextureFragment());
        }
        return _results;
      }).call(this);
      data.bitmaps = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.bitmap.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmap());
        }
        return _results;
      }).call(this);
      data.bitmapExs = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.bitmapEx.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmapEx());
        }
        return _results;
      }).call(this);
      data.fonts = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.font.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFont());
        }
        return _results;
      }).call(this);
      data.textProperties = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.textProperty.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTextProperty());
        }
        return _results;
      }).call(this);
      data.texts = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadText());
        }
        return _results;
      }).call(this);
      data.particleDatas = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.particleData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticleData());
        }
        return _results;
      }).call(this);
      data.particles = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.particle.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticle());
        }
        return _results;
      }).call(this);
      data.programObjects = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.programObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadProgramObject());
        }
        return _results;
      }).call(this);
      data.graphicObjects = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.graphicObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphicObject());
        }
        return _results;
      }).call(this);
      data.graphics = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.graphic.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphic());
        }
        return _results;
      }).call(this);
      animations = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.animation.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAnimation());
        }
        return _results;
      }).call(this);
      data.buttonConditions = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.buttonCondition.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButtonCondition());
        }
        return _results;
      }).call(this);
      data.buttons = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.button.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButton());
        }
        return _results;
      }).call(this);
      data.labels = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.label.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadLabel());
        }
        return _results;
      }).call(this);
      data.instanceNames = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.instanceName.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadInstanceName());
        }
        return _results;
      }).call(this);
      data.events = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.eventData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadEvent());
        }
        return _results;
      }).call(this);
      data.places = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.place.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadPlace());
        }
        return _results;
      }).call(this);
      data.controlMoveMs = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.controlMoveM.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveM());
        }
        return _results;
      }).call(this);
      data.controlMoveCs = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.controlMoveC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveC());
        }
        return _results;
      }).call(this);
      data.controlMoveMCs = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.controlMoveMC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveMC());
        }
        return _results;
      }).call(this);
      data.controls = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.control.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControl());
        }
        return _results;
      }).call(this);
      data.frames = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.frame.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFrame());
        }
        return _results;
      }).call(this);
      data.movieClipEvents = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.movieClipEvent.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieClipEvent());
        }
        return _results;
      }).call(this);
      data.movies = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.movie.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovie());
        }
        return _results;
      }).call(this);
      data.movieLinkages = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.movieLinkage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieLinkage());
        }
        return _results;
      }).call(this);
      stringDatas = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = header.stringData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadString());
        }
        return _results;
      }).call(this);
      data.animations = [];
      for (_i = 0, _len = animations.length; _i < _len; _i++) {
        a = animations[_i];
        o = a.animationOffset;
        data.animations.push(this.readAnimation(animationBytes.slice(o, o + a.animationLength)));
      }
      data.strings = [];
      stringMap = data.stringMap;
      for (_j = 0, _len1 = stringDatas.length; _j < _len1; _j++) {
        a = stringDatas[_j];
        o = a.stringOffset;
        s = stringBytes.slice(o, o + a.stringLength);
        str = "";
        i = 0;
        while (i < s.length) {
          c = s.charCodeAt(i);
          if (c < 128) {
            str += String.fromCharCode(c);
            ++i;
          } else if (c > 191 && c < 224) {
            c2 = s.charCodeAt(i + 1);
            str += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
          } else {
            c2 = s.charCodeAt(i + 1);
            c3 = s.charCodeAt(i + 2);
            code = ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
            str += String.fromCharCode(code);
            i += 3;
          }
        }
        stringMap[str] = data.strings.length;
        data.strings.push(str);
      }
      instanceNameMap = data.instanceNameMap;
      for (i = _k = 0, _ref = data.instanceNames.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
        instanceNameMap[data.instanceNames[i].stringId] = i;
      }
      eventMap = data.eventMap;
      for (i = _l = 0, _ref1 = data.events.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
        eventMap[data.events[i].stringId] = i;
      }
      movieLinkageMap = data.movieLinkageMap;
      for (i = _m = 0, _ref2 = data.movieLinkages.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
        movieLinkageMap[data.movieLinkages[i].stringId] = i;
      }
      movieLinkageNameMap = data.movieLinkageNameMap;
      for (i = _n = 0, _ref3 = data.movieLinkages.length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; i = 0 <= _ref3 ? ++_n : --_n) {
        movieLinkageNameMap[data.movieLinkages[i].movieId] = data.movieLinkages[i].stringId;
      }
      programObjectMap = data.programObjectMap;
      for (i = _o = 0, _ref4 = data.programObjects.length; 0 <= _ref4 ? _o < _ref4 : _o > _ref4; i = 0 <= _ref4 ? ++_o : --_o) {
        programObjectMap[data.programObjects[i].stringId] = i;
      }
      labelMap = data.labelMap;
      _ref5 = data.movies;
      for (_p = 0, _len2 = _ref5.length; _p < _len2; _p++) {
        m = _ref5[_p];
        o = m.labelOffset;
        map = {};
        _ref6 = data.labels.slice(o, o + m.labels);
        for (_q = 0, _len3 = _ref6.length; _q < _len3; _q++) {
          l = _ref6[_q];
          map[l.stringId] = l.frameNo;
        }
        labelMap.push(map);
      }
      _ref7 = data.textures;
      for (_r = 0, _len4 = _ref7.length; _r < _len4; _r++) {
        t = _ref7[_r];
        t.setFilename(data);
      }
      _ref8 = data.textureFragments;
      for (_s = 0, _len5 = _ref8.length; _s < _len5; _s++) {
        t = _ref8[_s];
        t.setFilename(data);
      }
      return data;
    };

    LWFLoader.prototype.readByteFromBytes = function(bytes, index) {
      var b;

      b = bytes.charCodeAt(index++) & 0xff;
      return [index, b];
    };

    LWFLoader.prototype.readInt32FromBytes = function(bytes, index) {
      var b0, b1, b2, b3, i, _ref, _ref1, _ref2, _ref3;

      _ref = this.readByteFromBytes(bytes, index), index = _ref[0], b0 = _ref[1];
      _ref1 = this.readByteFromBytes(bytes, index), index = _ref1[0], b1 = _ref1[1];
      _ref2 = this.readByteFromBytes(bytes, index), index = _ref2[0], b2 = _ref2[1];
      _ref3 = this.readByteFromBytes(bytes, index), index = _ref3[0], b3 = _ref3[1];
      i = (b0 << 0) + (b1 << 8) + (b2 << 16) + (b3 << 24);
      return [index, i];
    };

    LWFLoader.prototype.readAnimation = function(bytes) {
      var array, code, count, i, index, target, _i, _ref, _ref1, _ref2, _ref3;

      array = [];
      index = 0;
      while (true) {
        _ref = this.readByteFromBytes(bytes, index), index = _ref[0], code = _ref[1];
        array.push(code);
        switch (code) {
          case Animation.GOTOFRAME:
          case Animation.GOTOLABEL:
          case Animation.EVENT:
          case Animation.CALL:
            _ref1 = this.readInt32FromBytes(bytes, index), index = _ref1[0], i = _ref1[1];
            array.push(i);
            break;
          case Animation.SETTARGET:
            _ref2 = this.readInt32FromBytes(bytes, index), index = _ref2[0], count = _ref2[1];
            array.push(count);
            for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
              _ref3 = this.readInt32FromBytes(bytes, index), index = _ref3[0], target = _ref3[1];
              array.push(target);
            }
            break;
          case Animation.END:
            return array;
        }
      }
    };

    return LWFLoader;

  })();

  LWFLoaderWithArray = (function(_super) {
    __extends(LWFLoaderWithArray, _super);

    function LWFLoaderWithArray() {
      _ref = LWFLoaderWithArray.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    LWFLoaderWithArray.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArray.prototype.readBytes = function(length) {
      var bytes, i, _i;

      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    return LWFLoaderWithArray;

  })(LWFLoader);

  LWFLoaderWithArrayBuffer = (function(_super) {
    __extends(LWFLoaderWithArrayBuffer, _super);

    function LWFLoaderWithArrayBuffer() {
      this.int32Array = new Int32Array();
      this.float32Array = new Float32Array();
    }

    LWFLoaderWithArrayBuffer.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArrayBuffer.prototype.readBytes = function(length) {
      var bytes, i, _i;

      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    LWFLoaderWithArrayBuffer.prototype.readInt32 = function() {
      var i;

      i = this.dInt32[this.index / 4];
      this.index += 4;
      return i;
    };

    LWFLoaderWithArrayBuffer.prototype.readSingle = function() {
      var f;

      f = this.dFloat32[this.index / 4];
      this.index += 4;
      return f;
    };

    LWFLoaderWithArrayBuffer.prototype.load = function(d) {
      this.d = new Uint8Array(d);
      this.dInt32 = new Int32Array(d);
      this.dFloat32 = new Float32Array(d);
      return LWFLoaderWithArrayBuffer.__super__.load.call(this, this.d);
    };

    return LWFLoaderWithArrayBuffer;

  })(LWFLoader);

  Loader = (function() {
    function Loader() {}

    Loader.load = function(d) {
      var lwfLoader;

      if ((d == null) || typeof d !== "string") {
        return;
      }
      lwfLoader = new LWFLoader;
      return lwfLoader.load(d);
    };

    Loader.loadArray = function(d) {
      var lwfLoader;

      if (d == null) {
        return;
      }
      lwfLoader = new LWFLoaderWithArray;
      return lwfLoader.load(d);
    };

    Loader.loadArrayBuffer = function(d) {
      var lwfLoader;

      if (d == null) {
        return;
      }
      lwfLoader = new LWFLoaderWithArrayBuffer;
      return lwfLoader.load(d);
    };

    return Loader;

  })();

  Utility = (function() {
    function Utility() {}

    Utility.calcMatrixToPoint = function(sx, sy, m) {
      var dx, dy;

      dx = m.scaleX * sx + m.skew0 * sy + m.translateX;
      dy = m.skew1 * sx + m.scaleY * sy + m.translateY;
      return [dx, dy];
    };

    Utility.getMatrixDeterminant = function(matrix) {
      return matrix.scaleX * matrix.scaleY - matrix.skew0 * matrix.skew1 < 0;
    };

    Utility.syncMatrix = function(movie) {
      var matrix, matrixId, md, rotation, scaleX, scaleY, translate, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        scaleX = 1;
        scaleY = 1;
        rotation = 0;
        matrix = {
          scaleX: scaleX,
          scaleY: scaleY,
          skew0: 0,
          skew1: 0,
          translateX: translate.translateX,
          translateY: translate.translateY
        };
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        scaleX = Math.sqrt(matrix.scaleX * matrix.scaleX + matrix.skew1 * matrix.skew1);
        if (md) {
          scaleX = -scaleX;
        }
        scaleY = Math.sqrt(matrix.scaleY * matrix.scaleY + matrix.skew0 * matrix.skew0);
        if (md) {
          rotation = Math.atan2(matrix.skew1, -matrix.scaleX);
        } else {
          rotation = Math.atan2(matrix.skew1, matrix.scaleX);
        }
        rotation = rotation / Math.PI * 180;
      }
      movie.property.setMatrix(matrix, scaleX, scaleY, rotation);
    };

    Utility.getX = function(movie) {
      var matrix, matrixId, translate, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate.translateX;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix.translateX;
      }
    };

    Utility.getY = function(movie) {
      var matrix, matrixId, translate, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate.translateY;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix.translateY;
      }
    };

    Utility.getScaleX = function(movie) {
      var matrix, matrixId, md, scaleX, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        scaleX = Math.sqrt(matrix.scaleX * matrix.scaleX + matrix.skew1 * matrix.skew1);
        if (md) {
          scaleX = -scaleX;
        }
        return scaleX;
      }
    };

    Utility.getScaleY = function(movie) {
      var matrix, matrixId, scaleY, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        scaleY = Math.sqrt(matrix.scaleY * matrix.scaleY + matrix.skew0 * matrix.skew0);
        return scaleY;
      }
    };

    Utility.getRotation = function(movie) {
      var matrix, matrixId, md, rotation, _ref1;

      matrixId = (_ref1 = movie.matrixId) != null ? _ref1 : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 0;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        if (md) {
          rotation = Math.atan2(matrix.skew1, -matrix.scaleX);
        } else {
          rotation = Math.atan2(matrix.skew1, matrix.scaleX);
        }
        rotation = rotation / Math.PI * 180;
        return rotation;
      }
    };

    Utility.syncColorTransform = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref1;

      colorTransformId = (_ref1 = movie.colorTransformId) != null ? _ref1 : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        colorTransform = {
          multi: {
            red: 1,
            green: 1,
            blue: 1,
            alpha: alphaTransform.alpha
          }
        };
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
      }
      movie.property.setColorTransform(colorTransform);
    };

    Utility.getAlpha = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref1;

      colorTransformId = (_ref1 = movie.colorTransformId) != null ? _ref1 : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        return alphaTransform.alpha;
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
        return colorTransform.alpha;
      }
    };

    Utility.calcMatrixId = function(lwf, dst, src0, src1Id) {
      var matrixId, src1, translate;

      if (src1Id === 0) {
        dst.set(src0);
      } else if ((src1Id & Constant.MATRIX_FLAG) === 0) {
        translate = lwf.data.translates[src1Id];
        dst.scaleX = src0.scaleX;
        dst.skew0 = src0.skew0;
        dst.translateX = src0.scaleX * translate.translateX + src0.skew0 * translate.translateY + src0.translateX;
        dst.skew1 = src0.skew1;
        dst.scaleY = src0.scaleY;
        dst.translateY = src0.skew1 * translate.translateX + src0.scaleY * translate.translateY + src0.translateY;
      } else {
        matrixId = src1Id & ~Constant.MATRIX_FLAG;
        src1 = lwf.data.matrices[matrixId];
        this.calcMatrix(dst, src0, src1);
      }
      return dst;
    };

    Utility.calcMatrix = function(dst, src0, src1) {
      dst.scaleX = src0.scaleX * src1.scaleX + src0.skew0 * src1.skew1;
      dst.skew0 = src0.scaleX * src1.skew0 + src0.skew0 * src1.scaleY;
      dst.translateX = src0.scaleX * src1.translateX + src0.skew0 * src1.translateY + src0.translateX;
      dst.skew1 = src0.skew1 * src1.scaleX + src0.scaleY * src1.skew1;
      dst.scaleY = src0.skew1 * src1.skew0 + src0.scaleY * src1.scaleY;
      dst.translateY = src0.skew1 * src1.translateX + src0.scaleY * src1.translateY + src0.translateY;
      return dst;
    };

    Utility.rotateMatrix = function(dst, src, scale, offsetX, offsetY) {
      offsetX *= scale;
      offsetY *= scale;
      dst.scaleX = -src.skew0 * scale;
      dst.skew0 = src.scaleX * scale;
      dst.translateX = src.scaleX * offsetX + src.skew0 * offsetY + src.translateX;
      dst.skew1 = -src.scaleY * scale;
      dst.scaleY = src.skew1 * scale;
      dst.translateY = src.skew1 * offsetX + src.scaleY * offsetY + src.translateY;
      return dst;
    };

    Utility.scaleMatrix = function(dst, src, scale, offsetX, offsetY) {
      offsetX *= scale;
      offsetY *= scale;
      dst.scaleX = src.scaleX * scale;
      dst.skew0 = src.skew0 * scale;
      dst.translateX = src.scaleX * offsetX + src.skew0 * offsetY + src.translateX;
      dst.skew1 = src.skew1 * scale;
      dst.scaleY = src.scaleY * scale;
      dst.translateY = src.skew1 * offsetX + src.scaleY * offsetY + src.translateY;
      return dst;
    };

    Utility.fitForHeight = function(lwf, stageWidth, stageHeight) {
      var scale;

      scale = stageHeight / lwf.height;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
      lwf.property.move((stageWidth - lwf.width * scale) / 2, 0);
    };

    Utility.fitForWidth = function(lwf, stageWidth, stageHeight) {
      var scale;

      scale = stageWidth / lwf.width;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
      lwf.property.move(0, (stageHeight - lwf.height * scale) / 2, 0);
    };

    Utility.scaleForHeight = function(lwf, stageHeight) {
      var scale;

      scale = stageHeight / lwf.height;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
    };

    Utility.scaleForWidth = function(lwf, stageWidth) {
      var scale;

      scale = stageWidth / lwf.width;
      lwf.scaleByStage = scale;
      lwf.property.scale(scale, scale);
    };

    Utility.copyMatrix = function(dst, src) {
      if (src !== null) {
        dst.set(src);
      } else {
        dst.clear();
      }
      return dst;
    };

    Utility.invertMatrix = function(dst, src) {
      var dt;

      dt = src.scaleX * src.scaleY - src.skew0 * src.skew1;
      if (dt !== 0) {
        dst.scaleX = src.scaleY / dt;
        dst.skew0 = -src.skew0 / dt;
        dst.translateX = (src.skew0 * src.translateY - src.translateX * src.scaleY) / dt;
        dst.skew1 = -src.skew1 / dt;
        dst.scaleY = src.scaleX / dt;
        dst.translateY = (src.translateX * src.skew1 - src.scaleX * src.translateY) / dt;
      } else {
        dst.clear();
      }
    };

    Utility.calcColorTransformId = function(lwf, dst, src0, src1Id) {
      var alphaTransform, colorTransformId, src1;

      if (src1Id === 0) {
        dst.set(src0);
      } else if ((src1Id & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = lwf.data.alphaTransforms[src1Id];
        dst.multi.red = src0.multi.red;
        dst.multi.green = src0.multi.green;
        dst.multi.blue = src0.multi.blue;
        dst.multi.alpha = src0.multi.alpha * alphaTransform.alpha;
      } else {
        colorTransformId = src1Id & ~Constant.COLORTRANSFORM_FLAG;
        src1 = lwf.data.colorTransforms[colorTransformId];
        this.calcColorTransform(dst, src0, src1);
      }
      return dst;
    };

    Utility.calcColorTransform = function(dst, src0, src1) {
      dst.multi.red = src0.multi.red * src1.multi.red;
      dst.multi.green = src0.multi.green * src1.multi.green;
      dst.multi.blue = src0.multi.blue * src1.multi.blue;
      dst.multi.alpha = src0.multi.alpha * src1.multi.alpha;
      return dst;
    };

    Utility.copyColorTransform = function(dst, src) {
      if (src !== null) {
        dst.set(src);
      } else {
        dst.clear();
      }
      return dst;
    };

    Utility.calcColor = function(dst, c, t) {
      dst.red = c.red * t.multi.red;
      dst.green = c.green * t.multi.green;
      dst.blue = c.blue * t.multi.blue;
      dst.alpha = c.alpha * t.multi.alpha;
    };

    Utility.newIntArray = function() {
      return [];
    };

    Utility.insertIntArray = function(array, v) {
      var i;

      if (array.length === 0 || v > array[array.length - 1]) {
        array.push(v);
        return;
      }
      i = this.locationOfIntArray(array, v, 0, array.length - 1);
      if (array[i] !== v) {
        array.splice(i, 0, v);
      }
    };

    Utility.deleteIntArray = function(array, v) {
      var i;

      i = this.locationOfIntArray(array, v, 0, array.length - 1);
      if (array[i] === v) {
        array.splice(i, 1);
      }
    };

    Utility.locationOfIntArray = function(array, v, first, last) {
      var mid;

      while (first <= last) {
        mid = ((first + last) / 2) >> 0;
        if (v > array[mid]) {
          first = mid + 1;
        } else if (v < array[mid]) {
          last = mid - 1;
        } else {
          return mid;
        }
      }
      return first;
    };

    return Utility;

  })();

  NullRendererFactory = (function() {
    function NullRendererFactory() {}

    NullRendererFactory.prototype.constructBitmap = function(lwf, objId, bitmap) {
      return null;
    };

    NullRendererFactory.prototype.constructBitmapEx = function(lwf, objId, bitmapEx) {
      return null;
    };

    NullRendererFactory.prototype.constructText = function(lwf, objId, text) {
      return null;
    };

    NullRendererFactory.prototype.constructParticle = function(lwf, objId, particle) {
      return null;
    };

    NullRendererFactory.prototype.init = function(lwf) {};

    NullRendererFactory.prototype.beginRender = function(lwf) {};

    NullRendererFactory.prototype.endRender = function(lwf) {};

    NullRendererFactory.prototype.destruct = function() {};

    return NullRendererFactory;

  })();

  LObject = (function() {
    function LObject(lwf, parent, type, objectId) {
      this.lwf = lwf;
      this.parent = parent;
      this.type = type;
      this.objectId = objectId;
      this.matrixId = null;
      this.colorTransformId = null;
      this.matrixIdChanged = true;
      this.colorTransformIdChanged = true;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.colorTransform = new ColorTransform(0, 0, 0, 0);
      this.execCount = 0;
      this.updated = false;
      this.isButton = this.type === Type.BUTTON;
      this.isMovie = this.type === Type.MOVIE || this.type === Type.ATTACHEDMOVIE;
      this.isParticle = this.type === Type.PARTICLE;
      this.isProgramObject = this.type === Type.PROGRAMOBJECT;
      this.isText = this.type === Type.TEXT;
    }

    LObject.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      if (this.matrixId !== matrixId) {
        this.matrixIdChanged = true;
        this.matrixId = matrixId;
      }
      if (this.colorTransformId !== colorTransformId) {
        this.colorTransformIdChanged = true;
        this.colorTransformId = colorTransformId;
      }
    };

    LObject.prototype.update = function(m, c) {
      this.updated = true;
      if (m !== null) {
        Utility.calcMatrixId(this.lwf, this.matrix, m, this.dataMatrixId);
        this.matrixIdChanged = false;
      }
      if (c !== null) {
        Utility.copyColorTransform(this.colorTransform, c);
        this.colorTransformIdChanged = false;
      }
      this.lwf.renderObject();
    };

    LObject.prototype.render = function(v, rOffset) {
      var rCount, rIndex, rIndexOffsetted;

      if (this.renderer != null) {
        rIndex = this.lwf.renderingIndex;
        rIndexOffsetted = this.lwf.renderingIndexOffsetted;
        rCount = this.lwf.renderingCount;
        if (rOffset !== Number.MIN_VALUE) {
          rIndex = rIndexOffsetted - rOffset + rCount;
        }
        this.renderer.render(this.matrix, this.colorTransform, rIndex, rCount, v);
      }
      this.lwf.renderObject();
    };

    LObject.prototype.inspect = function(inspector, hierarchy, depth, rOffset) {
      var rCount, rIndex, rIndexOffsetted;

      rIndex = this.lwf.renderingIndex;
      rIndexOffsetted = this.lwf.renderingIndexOffsetted;
      rCount = this.lwf.renderingCount;
      if (rOffset !== Number.MIN_VALUE) {
        rIndex = rIndexOffsetted + rOffset + rCount;
      }
      inspector(this, hierarchy, depth, rIndex);
      this.lwf.renderObject();
    };

    LObject.prototype.destroy = function() {
      if (this.renderer) {
        this.renderer.destruct();
        this.renderer = null;
      }
      this.parent = null;
      this.lwf = null;
    };

    return LObject;

  })();

  Graphic = (function(_super) {
    __extends(Graphic, _super);

    function Graphic(lwf, parent, objId) {
      var data, gobj, graphicObjectId, graphicObjects, i, n, obj, _i;

      Graphic.__super__.constructor.call(this, lwf, parent, Type.GRAPHIC, objId);
      data = lwf.data.graphics[objId];
      n = data.graphicObjects;
      this.displayList = [];
      graphicObjects = lwf.data.graphicObjects;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        gobj = graphicObjects[data.graphicObjectId + i];
        graphicObjectId = gobj.graphicObjectId;
        if (graphicObjectId === -1) {
          continue;
        }
        switch (gobj.graphicObjectType) {
          case GObjType.BITMAP:
            obj = new Bitmap(lwf, parent, graphicObjectId);
            break;
          case GObjType.BITMAPEX:
            obj = new BitmapEx(lwf, parent, graphicObjectId);
            break;
          case GObjType.TEXT:
            obj = new Text(lwf, parent, graphicObjectId);
        }
        obj.exec();
        this.displayList[i] = obj;
      }
    }

    Graphic.prototype.update = function(m, c) {
      var obj, _i, _len, _ref1;

      _ref1 = this.displayList;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        obj.update(m, c);
      }
    };

    Graphic.prototype.render = function(v, rOffset) {
      var obj, _i, _len, _ref1;

      _ref1 = this.displayList;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        obj.render(v, rOffset);
      }
    };

    Graphic.prototype.destroy = function() {
      var obj, _i, _len, _ref1;

      _ref1 = this.displayList;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        obj.destroy();
      }
      this.displayList = null;
    };

    return Graphic;

  })(LObject);

  Bitmap = (function(_super) {
    __extends(Bitmap, _super);

    function Bitmap(lwf, parent, objId) {
      Bitmap.__super__.constructor.call(this, lwf, parent, Type.BITMAP, objId);
      this.dataMatrixId = lwf.data.bitmaps[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmap(lwf, objId, this);
    }

    return Bitmap;

  })(LObject);

  BitmapEx = (function(_super) {
    __extends(BitmapEx, _super);

    function BitmapEx(lwf, parent, objId) {
      BitmapEx.__super__.constructor.call(this, lwf, parent, Type.BITMAPEX, objId);
      this.dataMatrixId = lwf.data.bitmapExs[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmapEx(lwf, objId, this);
    }

    return BitmapEx;

  })(LObject);

  Text = (function(_super) {
    __extends(Text, _super);

    function Text(lwf, parent, objId) {
      Text.__super__.constructor.call(this, lwf, parent, Type.TEXT, objId);
      this.dataMatrixId = lwf.data.texts[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructText(lwf, objId, this);
    }

    return Text;

  })(LObject);

  Particle = (function(_super) {
    __extends(Particle, _super);

    function Particle(lwf, parent, objId) {
      Particle.__super__.constructor.call(this, lwf, parent, Type.PARTICLE, objId);
      this.dataMatrixId = lwf.data.particles[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructParticle(lwf, objId, this);
    }

    Particle.prototype.update = function(m, c) {
      Particle.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return Particle;

  })(LObject);

  ProgramObject = (function(_super) {
    __extends(ProgramObject, _super);

    function ProgramObject(lwf, parent, objId) {
      var ctor, data;

      ProgramObject.__super__.constructor.call(this, lwf, parent, Type.PROGRAMOBJECT, objId);
      data = lwf.data.programObjects[objId];
      this.dataMatrixId = data.matrixId;
      ctor = lwf.getProgramObjectConstructor(objId);
      if (ctor != null) {
        this.renderer = ctor(this, objId, data.width, data.height);
      }
    }

    ProgramObject.prototype.update = function(m, c) {
      ProgramObject.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return ProgramObject;

  })(LObject);

  IObject = (function(_super) {
    __extends(IObject, _super);

    function IObject(lwf, parent, type, objId, instId) {
      var head, stringId;

      IObject.__super__.constructor.call(this, lwf, parent, type, objId);
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      this.instanceId = instId >= lwf.data.instanceNames.length ? -1 : instId;
      if (this.instanceId >= 0) {
        stringId = lwf.getInstanceNameStringId(this.instanceId);
        if (stringId !== -1) {
          this.name = lwf.data.strings[stringId];
          if (parent != null) {
            parent[this.name] = this;
          }
        }
        head = this.lwf.getInstance(this.instanceId);
        if (head != null) {
          head.prevInstance = this;
        }
        this.nextInstance = head;
        this.lwf.setInstance(this.instanceId, this);
      }
    }

    IObject.prototype.destroy = function() {
      var head;

      if (this.type !== Type.ATTACHEDMOVIE && this.instanceId >= 0) {
        head = this.lwf.getInstance(this.instanceId);
        if (head === this) {
          this.lwf.setInstance(this.instanceId, this.nextInstance);
        }
        if (this.nextInstance != null) {
          this.nextInstance.prevInstance = this.prevInstance;
        }
        if (this.prevInstance != null) {
          this.prevInstance.nextInstance = this.nextInstance;
        }
      }
      if ((this.name != null) && (typeof parent !== "undefined" && parent !== null)) {
        delete parent[this.name];
      }
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      return IObject.__super__.destroy.apply(this, arguments);
    };

    IObject.prototype.linkButton = function() {};

    IObject.prototype.getFullName = function() {
      var fullPath, o, splitter;

      fullPath = "";
      splitter = "";
      o = this;
      while (o != null) {
        if (o.name == null) {
          return null;
        }
        fullPath = o.name + splitter + fullPath;
        splitter = ".";
        o = o.parent;
      }
      return fullPath;
    };

    return IObject;

  })(LObject);

  Button = (function(_super) {
    __extends(Button, _super);

    function Button(lwf, parent, objId, instId, matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      Button.__super__.constructor.call(this, lwf, parent, Type.BUTTON, objId, instId);
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.invert = new Matrix();
      this.hitX = Number.MIN_VALUE;
      this.hitY = Number.MIN_VALUE;
      if (objId >= 0) {
        this.data = lwf.data.buttons[objId];
        this.dataMatrixId = this.data.matrixId;
        this.width = this.data.width;
        this.height = this.data.height;
      } else {
        this.width = 0;
        this.height = 0;
      }
      this.handler = lwf.getButtonEventHandlers(this);
      if (this.handler != null) {
        this.handler.call("load", this);
      }
    }

    Button.prototype.setHandlers = function(handler) {
      if (this.handler != null) {
        this.handler.concat(handler);
      } else {
        this.handler = handler;
      }
    };

    Button.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      Button.__super__.exec.call(this, matrixId, colorTransformId);
      this.enterFrame();
    };

    Button.prototype.update = function(m, c) {
      Button.__super__.update.call(this, m, c);
      if (this.handler != null) {
        this.handler.call("update", this);
      }
    };

    Button.prototype.render = function(v, rOffset) {
      if (this.handler != null) {
        this.handler.call("render", this);
      }
    };

    Button.prototype.destroy = function() {
      this.lwf.clearFocus(this);
      this.lwf.clearPressed(this);
      if (this.handler != null) {
        this.handler.call("unload", this);
      }
      Button.__super__.destroy.apply(this, arguments);
    };

    Button.prototype.linkButton = function() {
      this.buttonLink = this.lwf.buttonHead;
      this.lwf.buttonHead = this;
    };

    Button.prototype.checkHit = function(px, py) {
      var x, y, _ref1;

      Utility.invertMatrix(this.invert, this.matrix);
      _ref1 = Utility.calcMatrixToPoint(px, py, this.invert), x = _ref1[0], y = _ref1[1];
      if (x >= 0 && x < this.data.width && y >= 0 && y < this.data.height) {
        this.hitX = x;
        this.hitY = y;
        return true;
      } else {
        this.hitX = Number.MIN_VALUE;
        this.hitY = Number.MIN_VALUE;
        return false;
      }
    };

    Button.prototype.enterFrame = function() {
      if (this.handler != null) {
        this.handler.call("enterFrame", this);
      }
    };

    Button.prototype.rollOver = function() {
      if (this.handler != null) {
        this.handler.call("rollOver", this);
      }
      this.playAnimation(Condition.ROLLOVER);
    };

    Button.prototype.rollOut = function() {
      if (this.handler != null) {
        this.handler.call("rollOut", this);
      }
      this.playAnimation(Condition.ROLLOUT);
    };

    Button.prototype.press = function() {
      if (this.handler != null) {
        this.handler.call("press", this);
      }
      this.playAnimation(Condition.PRESS);
    };

    Button.prototype.release = function() {
      if (this.handler != null) {
        this.handler.call("release", this);
      }
      this.playAnimation(Condition.RELEASE);
    };

    Button.prototype.keyPress = function(code) {
      if (this.handler != null) {
        this.handler.call("keyPress", this);
      }
      this.playAnimation(Condition.KEYPRESS, code);
    };

    Button.prototype.playAnimation = function(condition, code) {
      var c, conditions, i, _i, _ref1;

      if (code == null) {
        code = 0;
      }
      conditions = this.lwf.data.buttonConditions;
      for (i = _i = 0, _ref1 = this.data.conditions; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        c = conditions[this.data.conditionId + i];
        if ((c.condition & condition) !== 0 && (condition !== Condition.KEYPRESS || c.keyCode === code)) {
          this.lwf.playAnimation(c.animationId, this.parent, this);
        }
      }
    };

    Button.prototype.addEventHandler = function(e, eventHandler) {
      switch (e) {
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          this.lwf.setInteractive();
          this.lwf.enableExec();
          if (this.handler == null) {
            this.setHandlers(new ButtonEventHandlers());
          }
          this.handler.addHandler(e, eventHandler);
      }
    };

    Button.prototype.removeEventHandler = function(e, eventHandler) {
      switch (e) {
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          if (this.handler != null) {
            this.handler.removeHandler(e, eventHandler);
          }
      }
    };

    Button.prototype.clearEventHandler = function(e) {
      if (e == null) {
        e = null;
      }
      switch (e) {
        case null:
          if (this.handler != null) {
            this.handler.clear();
          }
          break;
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          if (this.handler != null) {
            this.handler.clear(e);
          }
      }
    };

    Button.prototype.setEventHandler = function(e, eventHandler) {
      this.clearEventHandler(e);
      this.addEventHandler(e, eventHandler);
    };

    return Button;

  })(IObject);

  LWFContainer = (function(_super) {
    __extends(LWFContainer, _super);

    function LWFContainer(parent, child) {
      this.parent = parent;
      this.child = child;
      this.lwf = this.parent.lwf;
    }

    LWFContainer.prototype.checkHit = function(px, py) {
      var button;

      button = this.child.inputPoint(px, py);
      if (button !== null) {
        return true;
      } else {
        return false;
      }
    };

    LWFContainer.prototype.rollOver = function() {};

    LWFContainer.prototype.rollOut = function() {
      if (this.child.focus != null) {
        this.child.focus.rollOut();
        this.child.clearFocus(this.child.focus);
      }
    };

    LWFContainer.prototype.press = function() {
      this.child.inputPress();
    };

    LWFContainer.prototype.release = function() {
      this.child.inputRelease();
    };

    LWFContainer.prototype.keyPress = function(code) {
      this.child.inputKeyPress(code);
    };

    return LWFContainer;

  })(Button);

  Property = (function() {
    function Property(lwf) {
      this.lwf = lwf;
      this.matrix = new Matrix;
      this.colorTransform = new ColorTransform;
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    }

    Property.prototype.clear = function() {
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.matrix.clear();
      this.colorTransform.clear();
      if (this.hasMatrix || this.hasColorTransform) {
        this.lwf.setPropertyDirty();
      }
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    };

    Property.prototype.move = function(x, y) {
      this.matrix.translateX += x;
      this.matrix.translateY += y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.moveTo = function(x, y) {
      this.matrix.translateX = x;
      this.matrix.translateY = y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.rotate = function(degree) {
      this.rotateTo(this.rotation + degree);
    };

    Property.prototype.rotateTo = function(degree) {
      this.rotation = degree;
      this.setScaleAndRotation();
    };

    Property.prototype.scale = function(x, y) {
      this.scaleX *= x;
      this.scaleY *= y;
      this.setScaleAndRotation();
    };

    Property.prototype.scaleTo = function(x, y) {
      this.scaleX = x;
      this.scaleY = y;
      this.setScaleAndRotation();
    };

    Property.prototype.setScaleAndRotation = function() {
      var c, radian, s;

      radian = this.rotation * Math.PI / 180;
      if (radian === 0) {
        c = 1;
        s = 0;
      } else {
        c = Math.cos(radian);
        s = Math.sin(radian);
      }
      this.matrix.scaleX = this.scaleX * c;
      this.matrix.skew0 = this.scaleY * -s;
      this.matrix.skew1 = this.scaleX * s;
      this.matrix.scaleY = this.scaleY * c;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      this.scaleX = scaleX != null ? scaleX : 1;
      this.scaleY = scaleY != null ? scaleY : 1;
      this.rotation = rotation != null ? rotation : 0;
      this.matrix.set(m);
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setAlpha = function(alpha) {
      this.colorTransform.multi.alpha = alpha;
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setColorTransform = function(c) {
      this.colorTransform.set(c);
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setRenderingOffset = function(rOffset) {
      this.renderingOffset = rOffset;
      this.hasRenderingOffset = true;
    };

    Property.prototype.clearRenderingOffset = function() {
      this.renderingOffset = Number.MIN_VALUE;
      this.hasRenderingOffset = false;
    };

    return Property;

  })();

  Movie = (function(_super) {
    __extends(Movie, _super);

    function Movie(lwf, parent, objId, instId, matrixId, colorTransformId, attached, handler) {
      var func, type, _ref1;

      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      if (attached == null) {
        attached = false;
      }
      if (handler == null) {
        handler = null;
      }
      type = attached ? Type.ATTACHEDMOVIE : Type.MOVIE;
      Movie.__super__.constructor.call(this, lwf, parent, type, objId, instId);
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.data = lwf.data.movies[objId];
      this.totalFrames = this.data.frames;
      this.instanceHead = null;
      this.instanceTail = null;
      this.currentFrameInternal = -1;
      this.execedFrame = -1;
      this.animationPlayedFrame = -1;
      this.lastControlOffset = -1;
      this.lastControls = -1;
      this.lastHasButton = false;
      this.lastControlAnimationOffset = -1;
      this.skipped = false;
      this.postLoaded = false;
      this.active = true;
      this.visible = true;
      this.playing = true;
      this.jumped = false;
      this.overriding = false;
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      this.movieExecCount = -1;
      this.postExecCount = -1;
      this.eventHandlers = {};
      this.property = new Property(lwf);
      if (typeof this.__defineGetter__ !== "undefined") {
        this.__defineGetter__("x", function() {
          return this.getX();
        });
        this.__defineSetter__("x", function(v) {
          return this.setX(v);
        });
        this.__defineGetter__("y", function() {
          return this.getY();
        });
        this.__defineSetter__("y", function(v) {
          return this.setY(v);
        });
        this.__defineGetter__("scaleX", function() {
          return this.getScaleX();
        });
        this.__defineSetter__("scaleX", function(v) {
          return this.setScaleX(v);
        });
        this.__defineGetter__("scaleY", function() {
          return this.getScaleY();
        });
        this.__defineSetter__("scaleY", function(v) {
          return this.setScaleY(v);
        });
        this.__defineGetter__("rotation", function() {
          return this.getRotation();
        });
        this.__defineSetter__("rotation", function(v) {
          return this.setRotation(v);
        });
        this.__defineGetter__("alpha", function() {
          return this.getAlphaProperty();
        });
        this.__defineSetter__("alpha", function(v) {
          return this.setAlphaProperty(v);
        });
        this.__defineGetter__("currentFrame", function() {
          return this.currentFrameInternal + 1;
        });
      } else if (typeof Object.defineProperty !== "undefined") {
        Object.defineProperty(this, "x", {
          get: function() {
            return this.getX();
          },
          set: function(v) {
            return this.setX(v);
          }
        });
        Object.defineProperty(this, "y", {
          get: function() {
            return this.getY();
          },
          set: function(v) {
            return this.setY(v);
          }
        });
        Object.defineProperty(this, "scaleX", {
          get: function() {
            return this.getScaleX();
          },
          set: function(v) {
            return this.setScaleX(v);
          }
        });
        Object.defineProperty(this, "scaleY", {
          get: function() {
            return this.getScaleY();
          },
          set: function(v) {
            return this.setScaleY(v);
          }
        });
        Object.defineProperty(this, "rotation", {
          get: function() {
            return this.getRotation();
          },
          set: function(v) {
            return this.setRotation(v);
          }
        });
        Object.defineProperty(this, "alpha", {
          get: function() {
            return this.getAlphaProperty();
          },
          set: function(v) {
            return this.setAlphaProperty(v);
          }
        });
        Object.defineProperty(this, "currentFrame", {
          get: function() {
            return this.currentFrameInternal + 1;
          }
        });
      }
      this.matrix0 = new Matrix;
      this.matrix1 = new Matrix;
      this.colorTransform0 = new ColorTransform;
      this.colorTransform1 = new ColorTransform;
      this.blendMode = "normal";
      this.displayList = [];
      this.attachName = null;
      this.depth = null;
      this.hasButton = false;
      this.getMovieFunctions();
      if (objId === this.lwf.data.header.rootMovieId) {
        func = (_ref1 = this.lwf.functions) != null ? _ref1['init'] : void 0;
        if (func != null) {
          func.call(this);
        }
      }
      if (this.loadFunc != null) {
        this.loadFunc.call(this);
      }
      this.playAnimation(ClipEvent.LOAD);
      this.handler = new MovieEventHandlers;
      this.handler.concat(lwf.getMovieEventHandlers(this));
      this.handler.concat(handler);
      if (!this.handler.empty) {
        this.handler.call("load", this);
      }
      lwf.execMovieCommand();
    }

    Movie.prototype.getMovieFunctions = function() {
      var _ref1;

      _ref1 = this.lwf.getMovieFunctions(this.objectId), this.loadFunc = _ref1[0], this.postLoadFunc = _ref1[1], this.unloadFunc = _ref1[2], this.enterFrameFunc = _ref1[3];
    };

    Movie.prototype.setHandlers = function(handler) {
      this.handler.concat(handler);
    };

    Movie.prototype.play = function() {
      this.playing = true;
      return this;
    };

    Movie.prototype.stop = function() {
      this.playing = false;
      return this;
    };

    Movie.prototype.nextFrame = function() {
      this.jumped = true;
      this.stop();
      ++this.currentFrameInternal;
      return this;
    };

    Movie.prototype.prevFrame = function() {
      this.jumped = true;
      this.stop();
      --this.currentFrameInternal;
      return this;
    };

    Movie.prototype.gotoFrame = function(frameNo) {
      return this.gotoFrameInternal(frameNo - 1);
    };

    Movie.prototype.gotoFrameInternal = function(frameNo) {
      this.jumped = true;
      this.stop();
      this.currentFrameInternal = frameNo;
      return this;
    };

    Movie.prototype.setVisible = function(visible) {
      this.visible = visible;
      return this;
    };

    Movie.prototype.globalToLocal = function(point) {
      var invert, m, x, y, _ref1;

      if (this.property.hasMatrix) {
        m = new Matrix();
        m = Utility.calcMatrix(m, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      invert = new Matrix();
      Utility.invertMatrix(invert, m);
      _ref1 = Utility.calcMatrixToPoint(point.x, point.y, invert), x = _ref1[0], y = _ref1[1];
      return new Point(x, y);
    };

    Movie.prototype.localToGlobal = function(point) {
      var m, x, y, _ref1;

      if (this.property.hasMatrix) {
        m = new Matrix();
        m = Utility.calcMatrix(m, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      _ref1 = Utility.calcMatrixToPoint(point.x, point.y, m), x = _ref1[0], y = _ref1[1];
      return new Point(x, y);
    };

    Movie.prototype.getDepth = function(keys) {
      var depth;

      depth = keys.length === 0 ? 0 : keys[keys.length - 1] + 1;
      return depth;
    };

    Movie.prototype.reorderList = function(reorder, keys, list, index, object, op) {
      var i, k, newlist, v;

      Utility.insertIntArray(keys, index);
      list[index] = object;
      if (reorder) {
        i = 0;
        newlist = {};
        for (k in list) {
          v = list[k];
          op(v, i);
          keys[i] = i;
          newlist[i] = v;
          ++i;
        }
        list = newlist;
      }
      return list;
    };

    Movie.prototype.deleteAttachedMovie = function(parent, movie, destroy, deleteFromDetachedMovies) {
      var attachName, depth;

      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedMovies == null) {
        deleteFromDetachedMovies = true;
      }
      attachName = movie.attachName;
      depth = movie.depth;
      delete parent.attachedMovies[attachName];
      delete parent.attachedMovieList[depth];
      Utility.deleteIntArray(parent.attachedMovieListKeys, depth);
      if (deleteFromDetachedMovies) {
        delete parent.detachedMovies[attachName];
      }
      delete parent[attachName];
      if (destroy) {
        return movie.destroy();
      }
    };

    Movie.prototype.attachMovie = function(linkageName, attachName, options) {
      var attachedMovie, depth, handlers, movie, movieId, reorder, _ref1;

      if (options == null) {
        options = null;
      }
      if (linkageName instanceof LWF) {
        return this.attachLWF(linkageName, attachName, options);
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref1 = options["reorder"]) != null ? _ref1 : false;
      if (linkageName instanceof Movie && linkageName.lwf === this.lwf) {
        movie = linkageName;
        this.deleteAttachedMovie(movie.parent, movie, false);
      } else if (typeof linkageName === "string") {
        movieId = this.lwf.searchMovieLinkage(this.lwf.getStringId(linkageName));
        if (movieId === -1) {
          return null;
        }
      } else {
        return null;
      }
      if (this.attachedMovies == null) {
        this.attachedMovies = {};
        this.detachedMovies = {};
        this.attachedMovieList = {};
        this.attachedMovieListKeys = Utility.newIntArray();
      }
      attachedMovie = this.attachedMovies[attachName];
      if (attachedMovie != null) {
        this.deleteAttachedMovie(this, attachedMovie);
      }
      if (!reorder) {
        attachedMovie = this.attachedMovieList[depth];
        if (attachedMovie != null) {
          this.deleteAttachedMovie(this, attachedMovie);
        }
      }
      handlers = new MovieEventHandlers();
      handlers.add(options);
      if (movie != null) {
        movie.setHandlers(handlers);
      } else {
        movie = new Movie(this.lwf, this, movieId, -1, 0, 0, true, handlers);
        if (this.attachMovieExeced) {
          movie.exec();
        }
        if (this.attachMoviePostExeced) {
          movie.postExec(true);
        }
      }
      movie.attachName = attachName;
      if (depth == null) {
        depth = this.getDepth(this.attachedMovieListKeys);
      }
      movie.depth = depth;
      movie.name = attachName;
      this.attachedMovies[attachName] = movie;
      this.attachedMovieList = this.reorderList(reorder, this.attachedMovieListKeys, this.attachedMovieList, movie.depth, movie, function(o, i) {
        return o.depth = i;
      });
      this[attachName] = movie;
      return movie;
    };

    Movie.prototype.swapAttachedMovieDepth = function(depth0, depth1) {
      var attachedMovie0, attachedMovie1;

      if ((this.attachedMovies == null) || depth0 === depth1) {
        return;
      }
      attachedMovie0 = this.attachedMovieList[depth0];
      attachedMovie1 = this.attachedMovieList[depth1];
      if (attachedMovie0 != null) {
        attachedMovie0.depth = depth1;
        this.attachedMovieList[depth1] = attachedMovie0;
        Utility.insertIntArray(this.attachedMovieListKeys, depth1);
      } else {
        delete this.attachedMovieList[depth1];
        Utility.deleteIntArray(this.attachedMovieListKeys, depth1);
      }
      if (attachedMovie1 != null) {
        attachedMovie1.depth = depth0;
        this.attachedMovieList[depth0] = attachedMovie1;
        Utility.insertIntArray(this.attachedMovieListKeys, depth0);
      } else {
        delete this.attachedMovieList[depth0];
        Utility.deleteIntArray(this.attachedMovieListKeys, depth0);
      }
    };

    Movie.prototype.getAttachedMovie = function(attachName) {
      var depth;

      if (this.attachedMovies == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return this.attachedMovies[attachName];
        case "number":
          depth = attachName;
          return this.attachedMovieList[depth];
      }
    };

    Movie.prototype.searchAttachedMovie = function(attachName, recursive) {
      var i, instance, movie;

      if (recursive == null) {
        recursive = true;
      }
      movie = this.getAttachedMovie(attachName);
      if (movie != null) {
        return movie;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedMovie(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachMovie = function(arg) {
      var attachedMovie, _ref1;

      if (this.detachedMovies != null) {
        if (arg instanceof Movie) {
          if ((arg != null ? arg.attachName : void 0) != null) {
            this.detachedMovies[arg.attachName] = true;
          }
        } else {
          switch (typeof arg) {
            case "string":
              this.detachedMovies[arg] = true;
              break;
            case "number":
              attachedMovie = (_ref1 = this.attachedMovieList) != null ? _ref1[arg] : void 0;
              if ((attachedMovie != null ? attachedMovie.attachName : void 0) != null) {
                this.detachedMovies[attachedMovie.attachName] = true;
              }
          }
        }
      }
    };

    Movie.prototype.detachFromParent = function() {
      if (this.type !== Type.ATTACHEDMOVIE) {
        return;
      }
      this.active = false;
      if (this.parent != null) {
        this.parent.detachMovie(this);
      }
    };

    Movie.prototype.removeMovieClip = function() {
      if (this.attachName != null) {
        if (this.parent != null) {
          this.parent.detachMovie(this);
        }
      } else if (this.lwf.attachName != null) {
        if (this.lwf.parent != null) {
          this.lwf.parent.detachLWF(this.lwf);
        }
      }
    };

    Movie.prototype.execDetachHandler = function(lwfContainer) {
      var lwf;

      lwf = lwfContainer.child;
      if (lwf.detachHandler != null) {
        if (lwf.detachHandler(lwf)) {
          lwf.destroy();
        } else {
          lwf.setAttachVisible(false);
          lwf.render();
        }
      } else {
        lwf.destroy();
      }
      lwf.parent = null;
      lwf.detachHandler = null;
      lwf.attachName = null;
    };

    Movie.prototype.deleteAttachedLWF = function(parent, lwfContainer, destroy, deleteFromDetachedLWFs) {
      var attachName, depth;

      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedLWFs == null) {
        deleteFromDetachedLWFs = true;
      }
      attachName = lwfContainer.child.attachName;
      depth = lwfContainer.child.depth;
      delete parent.attachedLWFs[attachName];
      delete parent.attachedLWFList[depth];
      Utility.deleteIntArray(parent.attachedLWFListKeys, depth);
      if (deleteFromDetachedLWFs) {
        delete parent.detachedLWFs[attachName];
      }
      delete parent[attachName];
      if (destroy) {
        return this.execDetachHandler(lwfContainer);
      }
    };

    Movie.prototype.attachLWF = function(attachLWF, attachName, options) {
      var depth, detachHandler, lwfContainer, reorder, _ref1;

      if (options == null) {
        options = null;
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref1 = options["reorder"]) != null ? _ref1 : false;
      detachHandler = options["detach"];
      if (this.attachedLWFs == null) {
        this.attachedLWFs = {};
        this.detachedLWFs = {};
        this.attachedLWFList = {};
        this.attachedLWFListKeys = Utility.newIntArray();
      }
      if (attachLWF.parent != null) {
        lwfContainer = attachLWF.parent.attachedLWFs[attachLWF.attachName];
        this.deleteAttachedLWF(attachLWF.parent, lwfContainer, false);
      }
      lwfContainer = this.attachedLWFs[attachName];
      if (lwfContainer != null) {
        this.deleteAttachedLWF(this, lwfContainer);
      }
      if (!reorder) {
        lwfContainer = this.attachedLWFList[depth];
        if (lwfContainer != null) {
          this.deleteAttachedLWF(this, lwfContainer);
        }
      }
      lwfContainer = new LWFContainer(this, attachLWF);
      if (attachLWF.interactive) {
        this.lwf.setInteractive();
      }
      attachLWF.setParent(this);
      attachLWF.rootMovie.parent = this;
      attachLWF.detachHandler = detachHandler;
      attachLWF.attachName = attachName;
      if (depth == null) {
        depth = this.getDepth(this.attachedLWFListKeys);
      }
      attachLWF.depth = depth;
      this.attachedLWFs[attachName] = lwfContainer;
      this.attachedLWFList = this.reorderList(reorder, this.attachedLWFListKeys, this.attachedLWFList, attachLWF.depth, lwfContainer, function(o, i) {
        return o.child.depth = i;
      });
      this[attachName] = attachLWF.rootMovie;
      if (attachLWF.lwfInstanceId != null) {
        delete this.lwf.loadedLWFs[attachLWF.lwfInstanceId];
      }
      this.lwf.isLWFAttached = true;
    };

    Movie.prototype.swapAttachedLWFDepth = function(depth0, depth1) {
      var attachedLWF0, attachedLWF1;

      if ((this.attachedLWFs == null) || depth0 === depth1) {
        return;
      }
      attachedLWF0 = this.attachedLWFList[depth0];
      attachedLWF1 = this.attachedLWFList[depth1];
      if (attachedLWF0 != null) {
        attachedLWF0.child.depth = depth1;
        this.attachedLWFList[depth1] = attachedLWF0;
        Utility.insertIntArray(this.attachedLWFListKeys, depth1);
      } else {
        delete this.attachedLWFList[depth1];
        Utility.deleteIntArray(this.attachedLWFListKeys, depth1);
      }
      if (attachedLWF1 != null) {
        attachedLWF1.child.depth = depth0;
        this.attachedLWFList[depth0] = attachedLWF1;
        Utility.insertIntArray(this.attachedLWFListKeys, depth0);
      } else {
        delete this.attachedLWFList[depth0];
        Utility.deleteIntArray(this.attachedLWFListKeys, depth0);
      }
    };

    Movie.prototype.swapDepths = function(depth) {
      var movie;

      if (depth instanceof Movie) {
        movie = depth;
        if (this.attachName != null) {
          this.parent.swapAttachedMovieDepth(this.depth, movie.depth);
        } else if (this.lwf === movie.lwf && (this.lwf.attachName != null)) {
          this.parent.swapAttachedLWFDepth(this.lwf.depth, movie.lwf.depth);
        }
      } else {
        if (this.attachName != null) {
          this.parent.swapAttachedMovieDepth(this.depth, depth);
        } else if (this.lwf.attachName != null) {
          this.parent.swapAttachedLWFDepth(this.lwf.depth, depth);
        }
      }
    };

    Movie.prototype.getAttachedLWF = function(attachName) {
      var depth, _ref1, _ref2;

      if (this.attachedLWFs == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return (_ref1 = this.attachedLWFs[attachName]) != null ? _ref1.child : void 0;
        case "number":
          depth = attachName;
          return (_ref2 = this.attachedLWFList[depth]) != null ? _ref2.child : void 0;
      }
    };

    Movie.prototype.searchAttachedLWF = function(attachName, recursive) {
      var attachedLWF, i, instance;

      if (recursive == null) {
        recursive = true;
      }
      attachedLWF = this.getAttachedLWF(attachName);
      if (attachedLWF != null) {
        return attachedLWF;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedLWF(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachLWF = function(arg) {
      var attachedLWF, _ref1, _ref2;

      if (this.detachedLWFs != null) {
        if (arg instanceof LWF) {
          if ((arg != null ? arg.attachName : void 0) != null) {
            this.detachedLWFs[arg.attachName] = true;
          }
        } else {
          switch (typeof arg) {
            case "string":
              this.detachedLWFs[arg] = true;
              break;
            case "number":
              attachedLWF = (_ref1 = this.attachedLWFList) != null ? _ref1[arg] : void 0;
              if ((attachedLWF != null ? (_ref2 = attachedLWF.child) != null ? _ref2.attachName : void 0 : void 0) != null) {
                this.detachedLWFs[attachedLWF.child.attachName] = true;
              }
          }
        }
      }
    };

    Movie.prototype.detachAllLWFs = function() {
      var k, lwfContainer, _ref1;

      if (this.detachedLWFs != null) {
        _ref1 = this.attachedLWFs;
        for (k in _ref1) {
          lwfContainer = _ref1[k];
          this.detachedLWFs[lwfContainer.child.attachName] = true;
        }
      }
    };

    Movie.prototype.execObject = function(depth, objId, matrixId, colorTransformId, instId) {
      var data, dataObject, dataObjectId, obj;

      if (objId === -1) {
        return;
      }
      data = this.lwf.data;
      dataObject = data.objects[objId];
      dataObjectId = dataObject.objectId;
      obj = this.displayList[depth];
      if ((obj != null) && (obj.type !== dataObject.objectType || obj.objectId !== dataObjectId || (obj.isMovie && obj.instanceId !== instId))) {
        obj.destroy();
        obj = null;
      }
      if (obj == null) {
        switch (dataObject.objectType) {
          case Type.BUTTON:
            obj = new Button(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            break;
          case Type.GRAPHIC:
            obj = new Graphic(this.lwf, this, dataObjectId);
            break;
          case Type.MOVIE:
            obj = new Movie(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            break;
          case Type.BITMAP:
            obj = new Bitmap(this.lwf, this, dataObjectId);
            break;
          case Type.BITMAPEX:
            obj = new BitmapEx(this.lwf, this, dataObjectId);
            break;
          case Type.TEXT:
            obj = new Text(this.lwf, this, dataObjectId);
            break;
          case Type.PARTICLE:
            obj = new Particle(this.lwf, this, dataObjectId);
            break;
          case Type.PROGRAMOBJECT:
            obj = new ProgramObject(this.lwf, this, dataObjectId);
        }
      }
      if (obj.isMovie || obj.isButton) {
        obj.linkInstance = null;
        if (this.instanceHead === null) {
          this.instanceHead = obj;
        } else {
          this.instanceTail.linkInstance = obj;
        }
        this.instanceTail = obj;
        if (obj.isButton) {
          this.hasButton = true;
        }
      }
      this.displayList[depth] = obj;
      obj.execCount = this.movieExecCount;
      obj.exec(matrixId, colorTransformId);
    };

    Movie.prototype.override = function(m, c) {
      this.overriding = true;
      Utility.copyMatrix(this.matrix, m);
      Utility.copyColorTransform(this.colorTransform, c);
      this.lwf.isPropertyDirty = true;
    };

    Movie.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      Movie.__super__.exec.call(this, matrixId, colorTransformId);
    };

    Movie.prototype.postExec = function(progressing) {
      var animationPlayed, attachName, control, controlAnimationOffset, ctrl, data, depth, frame, i, instance, k, movie, obj, p, postExeced, v, _i, _j, _k, _l, _len, _len1, _m, _n, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

      this.hasButton = false;
      if (!this.active) {
        return;
      }
      this.execedFrame = -1;
      postExeced = this.postExecCount === this.lwf.execCount;
      if (progressing && this.playing && !this.jumped && !postExeced) {
        ++this.currentFrameInternal;
      }
      while (true) {
        if (this.currentFrameInternal < 0 || this.currentFrameInternal >= this.totalFrames) {
          this.currentFrameInternal = 0;
        }
        if (this.currentFrameInternal === this.execedFrame) {
          break;
        }
        this.currentFrameCurrent = this.currentFrameInternal;
        this.execedFrame = this.currentFrameCurrent;
        data = this.lwf.data;
        frame = data.frames[this.data.frameOffset + this.currentFrameCurrent];
        if (this.lastControlOffset === frame.controlOffset && this.lastControls === frame.controls) {
          controlAnimationOffset = this.lastControlAnimationOffset;
          if (this.skipped) {
            instance = this.instanceHead;
            while (instance !== null) {
              if (instance.isMovie) {
                instance.attachMovieExeced = false;
                instance.attachMoviePostExeced = false;
              } else if (instance.isButton) {
                instance.enterFrame();
              }
              instance = instance.linkInstance;
            }
            this.hasButton = this.lastHasButton;
          } else {
            for (depth = _i = 0, _ref1 = this.data.depths; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; depth = 0 <= _ref1 ? ++_i : --_i) {
              obj = this.displayList[depth];
              if (obj != null) {
                if (!postExeced) {
                  obj.matrixIdChanged = false;
                  obj.colorTransformIdChanged = false;
                }
                if (obj.isMovie) {
                  obj.attachMovieExeced = false;
                  obj.attachMoviePostExeced = false;
                } else if (obj.isButton) {
                  obj.enterFrame();
                  this.hasButton = true;
                }
              }
            }
            this.lastHasButton = this.hasButton;
            this.skipped = true;
          }
        } else {
          ++this.movieExecCount;
          this.instanceHead = null;
          this.instanceTail = null;
          this.lastControlOffset = frame.controlOffset;
          this.lastControls = frame.controls;
          controlAnimationOffset = -1;
          for (i = _j = 0, _ref2 = frame.controls; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            control = data.controls[frame.controlOffset + i];
            switch (control.controlType) {
              case ControlType.MOVE:
                p = data.places[control.controlId];
                this.execObject(p.depth, p.objectId, p.matrixId, 0, p.instanceId);
                break;
              case ControlType.MOVEM:
                ctrl = data.controlMoveMs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, 0, p.instanceId);
                break;
              case ControlType.MOVEC:
                ctrl = data.controlMoveCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, p.matrixId, ctrl.colorTransformId, p.instanceId);
                break;
              case ControlType.MOVEMC:
                ctrl = data.controlMoveMCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, ctrl.colorTransformId, p.instanceId);
                break;
              case ControlType.ANIMATION:
                if (controlAnimationOffset === -1) {
                  controlAnimationOffset = i;
                }
            }
          }
          this.lastControlAnimationOffset = controlAnimationOffset;
          this.lastHasButton = this.hasButton;
          for (depth = _k = 0, _ref3 = this.data.depths; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; depth = 0 <= _ref3 ? ++_k : --_k) {
            obj = this.displayList[depth];
            if ((obj != null) && obj.execCount !== this.movieExecCount) {
              obj.destroy();
              this.displayList[depth] = null;
            }
          }
        }
        this.attachMovieExeced = true;
        if (this.attachedMovies != null) {
          _ref4 = this.attachedMovieListKeys;
          for (_l = 0, _len = _ref4.length; _l < _len; _l++) {
            k = _ref4[_l];
            movie = this.attachedMovieList[k];
            movie.exec();
          }
        }
        instance = this.instanceHead;
        while (instance !== null) {
          if (instance.isMovie) {
            movie = instance;
            movie.postExec(progressing);
            if (!this.hasButton && movie.hasButton) {
              this.hasButton = true;
            }
          }
          instance = instance.linkInstance;
        }
        this.attachMoviePostExeced = true;
        if (this.attachedMovies != null) {
          _ref5 = this.detachedMovies;
          for (attachName in _ref5) {
            v = _ref5[attachName];
            movie = this.attachedMovies[attachName];
            if (movie != null) {
              this.deleteAttachedMovie(this, movie, true, false);
            }
          }
          this.detachedMovies = {};
          _ref6 = this.attachedMovieListKeys;
          for (_m = 0, _len1 = _ref6.length; _m < _len1; _m++) {
            k = _ref6[_m];
            movie = this.attachedMovieList[k];
            movie.postExec(progressing);
            if (!this.hasButton && movie.hasButton) {
              this.hasButton = true;
            }
          }
        }
        if (this.attachedLWFs != null) {
          this.hasButton = true;
        }
        if (!this.postLoaded) {
          this.postLoaded = true;
          if (this.postLoadFunc != null) {
            this.postLoadFunc.call(this);
          }
          if (!this.handler.empty) {
            this.handler.call("postLoad", this);
          }
        }
        if (controlAnimationOffset !== -1 && this.execedFrame === this.currentFrameInternal) {
          animationPlayed = this.animationPlayedFrame === this.currentFrameCurrent && !this.jumped;
          if (!animationPlayed) {
            for (i = _n = controlAnimationOffset, _ref7 = frame.controls; controlAnimationOffset <= _ref7 ? _n < _ref7 : _n > _ref7; i = controlAnimationOffset <= _ref7 ? ++_n : --_n) {
              control = data.controls[frame.controlOffset + i];
              this.lwf.playAnimation(control.controlId, this);
            }
          }
        }
        this.animationPlayedFrame = this.currentFrameCurrent;
        if (this.currentFrameCurrent === this.currentFrameInternal) {
          this.jumped = false;
        }
      }
      if (this.enterFrameFunc != null) {
        this.enterFrameFunc.call(this);
      }
      this.playAnimation(ClipEvent.ENTERFRAME);
      if (!this.handler.empty) {
        this.handler.call("enterFrame", this);
      }
      this.postExecCount = this.lwf.execCount;
    };

    Movie.prototype.updateObject = function(obj, m, c, matrixChanged, colorTransformChanged) {
      var objc, objm;

      if (obj.isMovie && obj.property.hasMatrix) {
        objm = m;
      } else if (matrixChanged || !obj.updated || obj.matrixIdChanged) {
        objm = Utility.calcMatrixId(this.lwf, this.matrix1, m, obj.matrixId);
      } else {
        objm = null;
      }
      if (obj.isMovie && obj.property.hasColorTransform) {
        objc = c;
      } else if (colorTransformChanged || !obj.updated || obj.colorTransformIdChanged) {
        objc = Utility.calcColorTransformId(this.lwf, this.colorTransform1, c, obj.colorTransformId);
      } else {
        objc = null;
      }
      return obj.update(objm, objc);
    };

    Movie.prototype.update = function(m, c) {
      var attachName, colorTransformChanged, depth, inspector, invert, k, lwfContainer, matrixChanged, movie, obj, p, v, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3, _ref4,
        _this = this;

      if (!this.active) {
        return;
      }
      if (this.overriding) {
        matrixChanged = true;
        colorTransformChanged = true;
      } else {
        matrixChanged = this.matrix.setWithComparing(m);
        colorTransformChanged = this.colorTransform.setWithComparing(c);
      }
      if (!this.handler.empty) {
        this.handler.call("update", this);
      }
      if (this.property.hasMatrix) {
        matrixChanged = true;
        m = Utility.calcMatrix(this.matrix0, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      if (this.property.hasColorTransform) {
        colorTransformChanged = true;
        c = Utility.calcColorTransform(this.colorTransform0, this.colorTransform, this.property.colorTransform);
      } else {
        c = this.colorTransform;
      }
      for (depth = _i = 0, _ref1 = this.data.depths; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; depth = 0 <= _ref1 ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          this.updateObject(obj, m, c, matrixChanged, colorTransformChanged);
        }
      }
      if ((this.attachedMovies != null) || (this.attachedLWFs != null)) {
        if (this.attachedMovies != null) {
          _ref2 = this.attachedMovieListKeys;
          for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
            k = _ref2[_j];
            movie = this.attachedMovieList[k];
            this.updateObject(movie, m, c, matrixChanged, colorTransformChanged);
          }
        }
        if (this.attachedLWFs != null) {
          _ref3 = this.detachedLWFs;
          for (attachName in _ref3) {
            v = _ref3[attachName];
            lwfContainer = this.attachedLWFs[attachName];
            if (lwfContainer != null) {
              this.deleteAttachedLWF(this, lwfContainer, true, false);
            }
          }
          this.detachedLWFs = {};
          _ref4 = this.attachedLWFListKeys;
          for (_k = 0, _len1 = _ref4.length; _k < _len1; _k++) {
            k = _ref4[_k];
            lwfContainer = this.attachedLWFList[k];
            this.lwf.renderObject(lwfContainer.child.exec(this.lwf.thisTick, m, c));
          }
        }
      }
      if (this.requestedCalculateBounds) {
        this.xMin = Number.MAX_VALUE;
        this.xMax = -Number.MAX_VALUE;
        this.yMin = Number.MAX_VALUE;
        this.yMax = -Number.MAX_VALUE;
        inspector = function(o, h, d, r) {
          return _this.calculateBounds(o);
        };
        this.inspect(inspector, 0, 0);
        if (this.lwf.property.hasMatrix) {
          invert = new Matrix();
          Utility.invertMatrix(invert, this.lwf.property.matrix);
          p = Utility.calcMatrixToPoint(this.xMin, this.yMin, invert);
          this.xMin = p[0];
          this.yMin = p[1];
          p = Utility.calcMatrixToPoint(this.xMax, this.yMax, invert);
          this.xMax = p[0];
          this.yMax = p[1];
        }
        this.bounds = {
          "xMin": this.xMin,
          "xMax": this.xMax,
          "yMin": this.yMin,
          "yMax": this.yMax
        };
        this.requestedCalculateBounds = false;
      }
    };

    Movie.prototype.calculateBounds = function(o) {
      var obj, pobj, text, tf, tfId, _i, _len, _ref1;

      tfId = null;
      switch (o.type) {
        case Type.GRAPHIC:
          _ref1 = o.displayList;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            obj = _ref1[_i];
            this.calculateBounds(obj);
          }
          break;
        case Type.BITMAP:
        case Type.BITMAPEX:
          if (o.type === Type.BITMAP) {
            tfId = o.lwf.data.bitmaps[o.objectId].textureFragmentId;
          } else {
            tfId = o.lwf.data.bitmapExs[o.objectId].textureFragmentId;
          }
          if ((tfId != null) && tfId >= 0) {
            tf = o.lwf.data.textureFragments[tfId];
            this.updateBounds(o.matrix, tf.x, tf.x + tf.w, tf.y, tf.y + tf.h);
          }
          break;
        case Type.BUTTON:
          this.updateBounds(o.matrix, 0, o.width, 0, o.height);
          break;
        case Type.TEXT:
          text = o.lwf.data.texts[o.objectId];
          this.updateBounds(o.matrix, 0, text.width, 0, text.height);
          break;
        case Type.PROGRAMOBJECT:
          pobj = o.lwf.data.programObjects[o.objectId];
          this.updateBounds(o.matrix, 0, pobj.width, 0, pobj.height);
      }
    };

    Movie.prototype.updateBounds = function(matrix, xmin, xmax, ymin, ymax) {
      var p, x, y, _i, _len, _ref1, _ref2;

      _ref1 = [[xmin, ymin], [xmin, ymax], [xmax, ymin], [xmax, ymax]];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        p = _ref1[_i];
        _ref2 = Utility.calcMatrixToPoint(p[0], p[1], matrix), x = _ref2[0], y = _ref2[1];
        if (x < this.xMin) {
          this.xMin = x;
        } else if (x > this.xMax) {
          this.xMax = x;
        }
        if (y < this.yMin) {
          this.yMin = y;
        } else if (y > this.yMax) {
          this.yMax = y;
        }
      }
    };

    Movie.prototype.linkButton = function() {
      var depth, k, lwfContainer, movie, obj, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3;

      if (!this.visible || !this.active || !this.hasButton) {
        return;
      }
      if (this.attachedLWFs != null) {
        _ref1 = this.attachedLWFListKeys;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          lwfContainer = this.attachedLWFList[k];
          lwfContainer.linkButton();
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          k = _ref2[_j];
          movie = this.attachedMovieList[k];
          if (movie.hasButton) {
            movie.linkButton();
          }
        }
      }
      for (depth = _k = 0, _ref3 = this.data.depths; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; depth = 0 <= _ref3 ? ++_k : --_k) {
        obj = this.displayList[depth];
        if (obj != null) {
          if (obj.isButton) {
            obj.linkButton();
          } else if (obj.isMovie) {
            if (obj.hasButton) {
              obj.linkButton();
            }
          }
        }
      }
    };

    Movie.prototype.render = function(v, rOffset) {
      var attachedMovie, child, depth, k, lwfContainer, obj, useBlendMode, useMaskMode, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3;

      if (!this.visible || !this.active) {
        v = false;
      }
      useBlendMode = false;
      useMaskMode = false;
      if (this.blendMode !== "normal") {
        switch (this.blendMode) {
          case "add":
            this.lwf.beginBlendMode(this.blendMode);
            useBlendMode = true;
            break;
          case "erase":
          case "layer":
          case "mask":
            this.lwf.beginMaskMode(this.blendMode);
            useMaskMode = true;
        }
      }
      if (!this.handler.empty) {
        this.handler.call("render", this);
      }
      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      for (depth = _i = 0, _ref1 = this.data.depths; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; depth = 0 <= _ref1 ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          obj.render(v, rOffset);
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
          k = _ref2[_j];
          attachedMovie = this.attachedMovieList[k];
          attachedMovie.render(v, rOffset);
        }
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFListKeys;
        for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
          k = _ref3[_k];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          child.setAttachVisible(v);
          this.lwf.renderObject(child.render(this.lwf.renderingIndex, this.lwf.renderingCount, rOffset));
        }
      }
      if (useBlendMode) {
        this.lwf.endBlendMode();
      }
      if (useMaskMode) {
        this.lwf.endMaskMode();
      }
    };

    Movie.prototype.inspect = function(inspector, hierarchy, depth) {
      var attachedMovie, child, d, k, lwfContainer, obj, rOffset, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3;

      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      inspector(this, hierarchy, depth, rOffset);
      ++hierarchy;
      for (d = _i = 0, _ref1 = this.data.depths; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; d = 0 <= _ref1 ? ++_i : --_i) {
        obj = this.displayList[d];
        if (obj != null) {
          obj.inspect(inspector, hierarchy, d, rOffset);
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
          k = _ref2[_j];
          attachedMovie = this.attachedMovieList[k];
          attachedMovie.inspect(inspector, hierarchy, d++, rOffset);
        }
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFListKeys;
        for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
          k = _ref3[_k];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          this.lwf.renderObject(child.inspect(inspector, hierarchy, d++, rOffset));
        }
      }
    };

    Movie.prototype.destroy = function() {
      var k, lwfContainer, movie, obj, _i, _len, _ref1, _ref2, _ref3;

      _ref1 = this.displayList;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        obj = _ref1[_i];
        if (obj != null) {
          obj.destroy();
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovies;
        for (k in _ref2) {
          movie = _ref2[k];
          movie.destroy();
        }
        this.attachedMovies = null;
        this.detachedMovies = null;
        this.attachedMovieList = null;
        this.attachedMovieListKeys = null;
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFs;
        for (k in _ref3) {
          lwfContainer = _ref3[k];
          this.execDetachHandler(lwfContainer);
        }
        this.attachedLWFs = null;
        this.detachedLWFs = null;
        this.attachedLWFList = null;
        this.attachedLWFListKeys = null;
      }
      if (this.unloadFunc != null) {
        this.unloadFunc.call(this);
      }
      this.playAnimation(ClipEvent.UNLOAD);
      if (!this.handler.empty) {
        this.handler.call("unload", this);
      }
      this.instanceHead = null;
      this.instanceTail = null;
      this.displayList = null;
      this.property = null;
      Movie.__super__.destroy.apply(this, arguments);
    };

    Movie.prototype.playAnimation = function(clipEvent) {
      var c, clipEvents, i, _i, _ref1;

      clipEvents = this.lwf.data.movieClipEvents;
      for (i = _i = 0, _ref1 = this.data.clipEvents; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        c = clipEvents[this.data.clipEventId + i];
        if ((c.clipEvent & clipEvent) !== 0) {
          this.lwf.playAnimation(c.animationId, this);
        }
      }
    };

    Movie.prototype.dispatchEvent = function(e) {
      var handler, handlers, _i, _len;

      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          if (!this.handler.empty) {
            this.handler.call(e, this);
          }
          break;
        default:
          handlers = this.eventHandlers[e];
          if (handlers == null) {
            return false;
          }
          handlers = (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = handlers.length; _i < _len; _i++) {
              handler = handlers[_i];
              _results.push(handler);
            }
            return _results;
          })();
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            if (handler != null) {
              handler.call(this);
            }
          }
      }
      return true;
    };

    Movie.prototype.addEventHandler = function(e, eventHandler) {
      var _base, _ref1;

      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.lwf.enableExec();
          this.handler.addHandler(e, eventHandler);
          break;
        default:
          if ((_ref1 = (_base = this.eventHandlers)[e]) == null) {
            _base[e] = [];
          }
          this.eventHandlers[e].push(eventHandler);
      }
    };

    Movie.prototype.removeEventHandler = function(e, eventHandler) {
      var handlers, i;

      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.handler.removeHandler(e, eventHandler);
          break;
        default:
          handlers = this.eventHandlers[e];
          if (handlers == null) {
            return;
          }
          i = 0;
          while (i < handlers.length) {
            if (handlers[i] === eventHandler) {
              handlers.splice(i, 1);
            } else {
              ++i;
            }
          }
          if (handlers.length === 0) {
            delete this.eventHandlers[e];
          }
      }
    };

    Movie.prototype.clearEventHandler = function(e) {
      if (e == null) {
        e = null;
      }
      switch (e) {
        case null:
          this.handler.clear();
          this.eventHandlers = {};
          break;
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.handler.clear(e);
          break;
        default:
          delete this.eventHandlers[e];
      }
    };

    Movie.prototype.setEventHandler = function(e, eventHandler) {
      this.clearEventHandler(e);
      this.addEventHandler(e, eventHandler);
    };

    Movie.prototype.searchFrame = function(label) {
      return this.lwf.searchFrame(this, label);
    };

    Movie.prototype.gotoLabel = function(label) {
      if (typeof label === "string") {
        label = this.lwf.getStringId(label);
      }
      this.gotoFrame(this.lwf.searchFrame(this, label));
      return this;
    };

    Movie.prototype.gotoAndStop = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.stop();
      return this;
    };

    Movie.prototype.gotoAndPlay = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.play();
      return this;
    };

    Movie.prototype.searchMovieInstance = function(stringId, recursive) {
      var i, instance;

      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchMovieInstanceByInstanceId = function(instId, recursive) {
      var i, instance;

      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstance = function(stringId, recursive) {
      var i, instance;

      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchButtonInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstanceByInstanceId = function(instId, recursive) {
      var i, instance;

      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.move = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.move(x, y);
      return this;
    };

    Movie.prototype.moveTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(x, y);
      return this;
    };

    Movie.prototype.rotate = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotate(degree);
      return this;
    };

    Movie.prototype.rotateTo = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(degree);
      return this;
    };

    Movie.prototype.scale = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scale(x, y);
      return this;
    };

    Movie.prototype.scaleTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(x, y);
      return this;
    };

    Movie.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      if (scaleX == null) {
        scaleX = 1;
      }
      if (scaleY == null) {
        scaleY = 1;
      }
      if (rotation == null) {
        rotation = 0;
      }
      this.property.setMatrix(m, scalex, scaleY, rotation);
      return this;
    };

    Movie.prototype.setAlpha = function(alpha) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(alpha);
      return this;
    };

    Movie.prototype.setColorTransform = function(c) {
      this.property.setColorTransform(c);
      return this;
    };

    Movie.prototype.setRenderingOffset = function(rOffset) {
      this.property.setRenderingOffset(rOffset);
      return this;
    };

    Movie.prototype.getX = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateX;
      } else {
        return Utility.getX(this);
      }
    };

    Movie.prototype.setX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(v, this.property.matrix.translateY);
    };

    Movie.prototype.getY = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateY;
      } else {
        return Utility.getY(this);
      }
    };

    Movie.prototype.setY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(this.property.matrix.translateX, v);
    };

    Movie.prototype.getScaleX = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleX;
      } else {
        return Utility.getScaleX(this);
      }
    };

    Movie.prototype.setScaleX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(v, this.property.scaleY);
    };

    Movie.prototype.getScaleY = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleY;
      } else {
        return Utility.getScaleY(this);
      }
    };

    Movie.prototype.setScaleY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(this.property.scaleX, v);
    };

    Movie.prototype.getRotation = function() {
      if (this.property.hasMatrix) {
        return this.property.rotation;
      } else {
        return Utility.getRotation(this);
      }
    };

    Movie.prototype.setRotation = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(v);
    };

    Movie.prototype.getAlphaProperty = function() {
      if (this.property.hasColorTransform) {
        return this.property.colorTransform.multi.alpha;
      } else {
        return Utility.getAlpha(this);
      }
    };

    Movie.prototype.setAlphaProperty = function(v) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(v);
    };

    Movie.prototype.requestCalculateBounds = function() {
      this.requestedCalculateBounds = true;
    };

    Movie.prototype.getBounds = function() {
      return this.bounds;
    };

    Movie.prototype.setFrameRate = function(frameRate) {
      var instance, k, lwfContainer, movie, _i, _j, _len, _len1, _ref1, _ref2;

      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovieListKeys;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          movie = this.attachedMovieList[k];
          movie.setFrameRate(frameRate);
        }
      }
      if (this.attachedLWFs != null) {
        _ref2 = this.attachedLWFListKeys;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          k = _ref2[_j];
          lwfContainer = this.attachedLWFList[k];
          lwfContainer.child.setFrameRate(frameRate);
        }
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          instance.setFrameRate(frameRate);
        }
        instance = instance.linkInstance;
      }
    };

    return Movie;

  })(IObject);

  EventHandlers = (function() {
    function EventHandlers() {
      this.clear();
    }

    EventHandlers.prototype.clear = function(type) {
      var _i, _len, _ref1;

      if (type == null) {
        type = null;
      }
      if (type != null) {
        if (this[type] != null) {
          this[type] = [];
        }
      } else {
        _ref1 = this.types;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          type = _ref1[_i];
          this[type] = [];
        }
      }
      this.empty = true;
    };

    EventHandlers.prototype.add = function(handlers) {
      var handler, type, _i, _len, _ref1;

      if (handlers == null) {
        return;
      }
      _ref1 = this.types;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        type = _ref1[_i];
        handler = handlers[type];
        if (handler != null) {
          this[type].push(handler);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.concat = function(handlers) {
      var h, handler, type, _i, _j, _len, _len1, _ref1;

      if (handlers == null) {
        return;
      }
      if (handlers.empty) {
        return;
      }
      _ref1 = this.types;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        type = _ref1[_i];
        handler = handlers[type];
        for (_j = 0, _len1 = handler.length; _j < _len1; _j++) {
          h = handler[_j];
          this[type].push(h);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.addHandler = function(type, handler) {
      if (handler != null) {
        this[type].push(handler);
        this.empty = false;
      }
    };

    EventHandlers.prototype.removeInternal = function(array, handler) {
      var i;

      i = 0;
      while (i < array.length) {
        if (array[i] === handler) {
          array.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    EventHandlers.prototype.remove = function(handlers) {
      var handler, type, _i, _len, _ref1;

      _ref1 = this.types;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        type = _ref1[_i];
        handler = handlers[type];
        if (handler != null) {
          this.removeInternal(this[type], handler);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.removeHandler = function(type, handler) {
      if (handler != null) {
        this.removeInternal(this[type], handler);
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.call = function(type, target) {
      var handler, handlers, _i, _len;

      handlers = this[type];
      if ((handlers != null) && handlers.length > 0) {
        handlers = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            _results.push(handler);
          }
          return _results;
        })();
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          handler.call(target);
        }
      }
    };

    EventHandlers.prototype.updateEmpty = function() {
      var type, _i, _len, _ref1, _ref2;

      _ref1 = this.types;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        type = _ref1[_i];
        if (((_ref2 = this[type]) != null ? _ref2.length : void 0) > 0) {
          this.empty = false;
          return;
        }
      }
      this.empty = true;
    };

    return EventHandlers;

  })();

  MovieEventHandlers = (function(_super) {
    var TYPES;

    __extends(MovieEventHandlers, _super);

    TYPES = ["load", "postLoad", "unload", "enterFrame", "update", "render"];

    function MovieEventHandlers() {
      this.types = TYPES;
      MovieEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return MovieEventHandlers;

  })(EventHandlers);

  ButtonEventHandlers = (function(_super) {
    var TYPES;

    __extends(ButtonEventHandlers, _super);

    TYPES = ["load", "unload", "enterFrame", "update", "render", "press", "release", "rollOver", "rollOut", "keyPress"];

    function ButtonEventHandlers() {
      this.types = TYPES;
      ButtonEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return ButtonEventHandlers;

  })(EventHandlers);

  LWF = (function() {
    var ROUND_OFF_TICK_RATE;

    ROUND_OFF_TICK_RATE = 0.05;

    function LWF(lwfData, rendererFactory, embeddedScript, privateData) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (embeddedScript == null) {
        embeddedScript = null;
      }
      this.privateData = privateData != null ? privateData : null;
      this.data = lwfData;
      if (embeddedScript != null) {
        this.functions = embeddedScript();
      }
      this.width = this.data.header.width;
      this.height = this.data.header.height;
      this.backgroundColor = this.data.header.backgroundColor;
      this.name = this.data.strings[this.data.header.nameStringId];
      this.interactive = this.data.buttonConditions.length > 0;
      this.url = null;
      this.lwfInstanceId = null;
      this.frameRate = this.data.header.frameRate;
      this.active = true;
      this.frameSkip = true;
      this.execLimit = 3;
      this.tick = 1.0 / this.frameRate;
      this.roundOffTick = this.tick * ROUND_OFF_TICK_RATE;
      this.time = 0;
      this.thisTick = 0;
      this.attachVisible = true;
      this.execCount = 0;
      this.isExecDisabled = false;
      this.isPropertyDirty = false;
      this.isLWFAttached = false;
      this.interceptByNotAllowOrDenyButtons = true;
      this.intercepted = false;
      this.scaleByStage = 1;
      this.pointX = Number.MIN_VALUE;
      this.pointY = Number.MIN_VALUE;
      this.pressing = false;
      this.buttonHead = null;
      this.blendModes = [];
      this.maskModes = [];
      this._tweens = null;
      if (!this.interactive && this.data.frames.length === 1) {
        if (!this.functions || !(this.functions['_root_load'] || this.functions['_root_postLoad'] || this.functions['_root_unload'] || this.functions['_root_enterFrame'] || this.functions['_root_update'] || this.functions['_root_render'])) {
          this.disableExec();
        }
      }
      this.property = new Property(this);
      this.instances = [];
      this.execHandlers = null;
      this.eventHandlers = [];
      this.genericEventHandlers = [];
      this.movieEventHandlers = [];
      this.buttonEventHandlers = [];
      this.movieCommands = {};
      this.programObjectConstructors = [];
      this.loadedLWFs = {};
      this.parent = null;
      this.attachName = null;
      this.depth = null;
      this.matrix = new Matrix;
      this.matrixIdentity = new Matrix;
      this.colorTransform = new ColorTransform;
      this.colorTransformIdentity = new ColorTransform;
      this.setRendererFactory(rendererFactory);
      this.init();
    }

    LWF.prototype.setRendererFactory = function(rendererFactory) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (rendererFactory == null) {
        rendererFactory = new NullRendererFactory();
      }
      this.rendererFactory = rendererFactory;
      this.rendererFactory.init(this);
    };

    LWF.prototype.setFrameRate = function(frameRate) {
      if (frameRate === 0) {
        return;
      }
      this.frameRate = frameRate;
      this.tick = 1.0 / this.frameRate;
      if (this.isLWFAttached) {
        this.rootMovie.setFrameRate(frameRate);
      }
    };

    LWF.prototype.setPreferredFrameRate = function(preferredFrameRate, execLimit) {
      if (execLimit == null) {
        execLimit = 2;
      }
      if (preferredFrameRate === 0) {
        return;
      }
      this.execLimit = Math.ceil(this.frameRate / preferredFrameRate) + execLimit;
    };

    LWF.prototype.fitForHeight = function(stageWidth, stageHeight) {
      Utility.fitForHeight(this, stageWidth, stageHeight);
    };

    LWF.prototype.fitForWidth = function(stageWidth, stageHeight) {
      Utility.fitForWidth(this, stageWidth, stageHeight);
    };

    LWF.prototype.scaleForHeight = function(stageHeight) {
      Utility.scaleForHeight(this, stageHeight);
    };

    LWF.prototype.scaleForWidth = function(stageWidth) {
      Utility.scaleForWidth(this, stageWidth);
    };

    LWF.prototype.getStageSize = function() {
      var h, w, _ref1;

      _ref1 = this.rendererFactory.getStageSize(), w = _ref1[0], h = _ref1[1];
      return {
        width: w,
        height: h
      };
    };

    LWF.prototype.renderOffset = function() {
      this.renderingIndexOffsetted = 0;
    };

    LWF.prototype.clearRenderOffset = function() {
      this.renderingIndexOffsetted = this.renderingIndex;
    };

    LWF.prototype.renderObject = function(count) {
      if (count == null) {
        count = 1;
      }
      this.renderingIndex += count;
      this.renderingIndexOffsetted += count;
      return this.renderingIndex;
    };

    LWF.prototype.beginBlendMode = function(blendMode) {
      this.blendModes.unshift(blendMode);
      this.rendererFactory.setBlendMode(blendMode);
    };

    LWF.prototype.endBlendMode = function() {
      this.blendModes.shift();
      this.rendererFactory.setBlendMode(this.blendModes.length > 0 ? this.blendModes[0] : "normal");
    };

    LWF.prototype.beginMaskMode = function(maskMode) {
      this.maskModes.unshift(maskMode);
      this.rendererFactory.setMaskMode(maskMode);
    };

    LWF.prototype.endMaskMode = function() {
      this.maskModes.shift();
      this.rendererFactory.setMaskMode(this.maskModes.length > 0 ? this.maskModes[0] : "normal");
    };

    LWF.prototype.setAttachVisible = function(visible) {
      this.attachVisible = visible;
    };

    LWF.prototype.clearFocus = function(button) {
      if (this.focus === button) {
        this.focus = null;
      }
    };

    LWF.prototype.clearPressed = function(button) {
      if (this.pressed === button) {
        this.pressed = null;
      }
    };

    LWF.prototype.clearIntercepted = function() {
      this.intercepted = false;
    };

    LWF.prototype.init = function() {
      this.time = 0;
      this.progress = 0;
      this.instances = [];
      this.focus = null;
      this.pressed = null;
      this.movieCommands = {};
      this.rootMovieStringId = this.getStringId("_root");
      if (this.rootMovie != null) {
        this.rootMovie.destroy();
      }
      this.rootMovie = new Movie(this, null, this.data.header.rootMovieId, this.searchInstanceId(this.rootMovieStringId));
    };

    LWF.prototype.calcMatrix = function(matrix) {
      var m, p;

      p = this.property;
      if (p.hasMatrix) {
        if (matrix != null) {
          m = Utility.calcMatrix(this.matrix, matrix, p.matrix);
        } else {
          m = p.matrix;
        }
      } else {
        m = matrix != null ? matrix : this.matrixIdentity;
      }
      return m;
    };

    LWF.prototype.calcColorTransform = function(colorTransform) {
      var c, p;

      p = this.property;
      if (p.hasColorTransform) {
        if (colorTransform != null) {
          c = Utility.calcColorTransform(this.colorTransform, colorTransform, p.colorTransform);
        } else {
          c = p.colorTransform;
        }
      } else {
        c = colorTransform != null ? colorTransform : this.colorTransformIdentity;
      }
      return c;
    };

    LWF.prototype.exec = function(tick, matrix, colorTransform) {
      var currentProgress, execLimit, execed, handler, handlers, progressing, _i, _len;

      if (tick == null) {
        tick = 0;
      }
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      if (!((this.rootMovie != null) && this.active)) {
        return;
      }
      execed = false;
      currentProgress = this.progress;
      this.thisTick = tick;
      if (this.isExecDisabled && this._tweens === null) {
        if (!this.executedForExecDisabled) {
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(true);
          this.executedForExecDisabled = true;
          execed = true;
        }
      } else {
        progressing = true;
        if (tick === 0) {
          this.progress = this.tick;
        } else if (tick < 0) {
          this.progress = this.tick;
          progressing = false;
        } else {
          if (this.time === 0) {
            this.time += this.tick;
            this.progress += this.tick;
          } else {
            this.time += tick;
            this.progress += tick;
          }
        }
        handlers = this.execHandlers;
        if (handlers != null) {
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            handler.call(this);
          }
        }
        execLimit = this.execLimit;
        while (this.progress >= this.tick - this.roundOffTick) {
          if (--execLimit < 0) {
            this.progress = 0;
            break;
          }
          this.progress -= this.tick;
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(progressing);
          execed = true;
          if (!this.frameSkip) {
            break;
          }
        }
        if (this.progress < this.roundOffTick) {
          this.progress = 0;
        }
        this.buttonHead = null;
        if (this.interactive && this.rootMovie.hasButton) {
          this.rootMovie.linkButton();
        }
      }
      if (execed || this.isLWFAttached || this.isPropertyDirty || (matrix != null) || (colorTransform != null)) {
        this.update(matrix, colorTransform);
      }
      if (!this.execDisabled) {
        if (tick < 0) {
          this.progress = currentProgress;
        }
      }
      return this.renderingCount;
    };

    LWF.prototype.forceExec = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(0, matrix, colorTransform);
    };

    LWF.prototype.forceExecWithoutProgress = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(-1, matrix, colorTransform);
    };

    LWF.prototype.update = function(matrix, colorTransform) {
      var c, m;

      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      m = this.calcMatrix(matrix);
      c = this.calcColorTransform(colorTransform);
      this.renderingIndex = 0;
      this.renderingIndexOffsetted = 0;
      this.rootMovie.update(m, c);
      this.renderingCount = this.renderingIndex;
      this.isPropertyDirty = false;
    };

    LWF.prototype.render = function(rIndex, rCount, rOffset) {
      var renderingCountBackup;

      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      if (!((this.rootMovie != null) && this.active)) {
        return;
      }
      renderingCountBackup = this.renderingCount;
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rendererFactory.beginRender(this);
      this.rootMovie.render(this.attachVisible, rOffset);
      this.rendererFactory.endRender(this);
      this.renderingCount = renderingCountBackup;
      return this.renderingCount;
    };

    LWF.prototype.inspect = function(inspector, hierarchy, depth, rIndex, rCount, rOffset) {
      var renderingCountBackup;

      if (hierarchy == null) {
        hierarchy = 0;
      }
      if (depth == null) {
        depth = 0;
      }
      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      renderingCountBackup = this.renderingCount;
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rootMovie.inspect(inspector, hierarchy, depth, rOffset);
      this.renderingCount = renderingCountBackup;
      return this.renderingCount;
    };

    LWF.prototype.destroy = function() {
      var func, k, lwfInstance, resourceCache, _ref1, _ref2;

      if (this.rootMovie == null) {
        return;
      }
      if (this.stopTweens != null) {
        this.stopTweens();
      }
      _ref1 = this.loadedLWFs;
      for (k in _ref1) {
        lwfInstance = _ref1[k];
        lwfInstance.destroy();
      }
      this.loadedLWFs = null;
      this.rootMovie.destroy();
      this.rootMovie = null;
      func = (_ref2 = this.functions) != null ? _ref2['destroy'] : void 0;
      if (func != null) {
        func.call(this);
      }
      this.functions = null;
      if (this.rendererFactory != null) {
        resourceCache = this.rendererFactory.resourceCache;
        if (resourceCache != null) {
          resourceCache.unloadLWF(this);
        }
        this.rendererFactory.destruct();
        this.rendererFactory = null;
      }
      this.property = null;
      this.buttonHead = null;
      this.instances = null;
      this.execHandlers = null;
      this.eventHandlers = null;
      this.genericEventHandlers = null;
      this.movieEventHandlers = null;
      this.buttonEventHandlers = null;
      this.movieCommands = null;
      this.programObjectConstructors = null;
    };

    LWF.prototype.getInstanceNameStringId = function(instId) {
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return -1;
      } else {
        return this.data.instanceNames[instId].stringId;
      }
    };

    LWF.prototype.getStringId = function(str) {
      var i;

      i = this.data.stringMap[str];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchInstanceId = function(stringId) {
      var i;

      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.instanceNameMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchFrame = function(movie, stringId) {
      var frameNo;

      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      frameNo = this.data.labelMap[movie.objectId][stringId];
      if (frameNo != null) {
        return frameNo + 1;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLabels = function(movie) {
      if (movie == null) {
        return null;
      }
      return this.data.labelMap[movie.objectId];
    };

    LWF.prototype.searchMovieLinkage = function(stringId) {
      var i;

      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.movieLinkageMap[stringId];
      if (i != null) {
        return this.data.movieLinkages[i].movieId;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLinkageName = function(movieId) {
      var i;

      i = this.data.movieLinkageNameMap[movieId];
      if (i != null) {
        return this.data.strings[i];
      } else {
        return null;
      }
    };

    LWF.prototype.searchMovieInstance = function(stringId) {
      var instanceName, m, name, names, _i, _len;

      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            m = m.searchMovieInstance(name, false);
            if (m == null) {
              return null;
            }
          }
          return m;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchMovieInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchMovieInstanceByInstanceId = function(instId) {
      var obj;

      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isMovie) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchButtonInstance = function(stringId) {
      var i, instanceName, m, names, _i, _ref1;

      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (i = _i = 1, _ref1 = names.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
            if (i === names.length - 1) {
              return m.searchButtonInstance(names[i], false);
            } else {
              m = m.searchButtonInstance(names[i], false);
              if (m == null) {
                return null;
              }
            }
          }
          return null;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchButtonInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchButtonInstanceByInstanceId = function(instId) {
      var obj;

      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isButton) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchEventId = function(stringId) {
      var i;

      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.eventMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchProgramObjectId = function(stringId) {
      var i;

      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.programObjectMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.getInstance = function(instId) {
      return this.instances[instId];
    };

    LWF.prototype.setInstance = function(instId, instance) {
      this.instances[instId] = instance;
    };

    LWF.prototype.addExecHandler = function(execHandler) {
      var _ref1;

      if ((_ref1 = this.execHandlers) == null) {
        this.execHandlers = [];
      }
      this.execHandlers.push(execHandler);
    };

    LWF.prototype.removeExecHandler = function(execHandler) {
      var handlers, i;

      handlers = this.execHandlers;
      if (handlers == null) {
        return;
      }
      i = 0;
      while (i < handlers.length) {
        if (handlers[i] === execHandler) {
          handlers.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    LWF.prototype.clearExecHandler = function() {
      this.execHandlers = null;
    };

    LWF.prototype.setExecHandler = function(execHandler) {
      this.clearExecHandler();
      this.addExecHandler(execHandler);
    };

    LWF.prototype.addEventHandler = function(e, eventHandler) {
      var eventId, _base, _base1, _ref1, _ref2;

      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        if ((_ref1 = (_base = this.genericEventHandlers)[e]) == null) {
          _base[e] = [];
        }
        this.genericEventHandlers[e].push(eventHandler);
      } else {
        if ((_ref2 = (_base1 = this.eventHandlers)[eventId]) == null) {
          _base1[eventId] = [];
        }
        this.eventHandlers[eventId].push(eventHandler);
      }
    };

    LWF.prototype.removeEventHandler = function(e, eventHandler) {
      var eventId, handlers, i, k, keys, v, _i, _len;

      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        handlers = this.genericEventHandlers[e];
        if (handlers == null) {
          return;
        }
        keys = [];
        for (k in handlers) {
          v = handlers[k];
          if (v === eventHandler) {
            keys.push(k);
          }
        }
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          k = keys[_i];
          delete handlers[k];
        }
      } else {
        handlers = this.eventHandlers[eventId];
        if (handlers == null) {
          return;
        }
        i = 0;
        while (i < handlers.length) {
          if (handlers[i] === eventHandler) {
            handlers.splice(i, 1);
          } else {
            ++i;
          }
        }
        if (handlers.length === 0) {
          delete this.eventHandlers[eventId];
        }
      }
    };

    LWF.prototype.clearEventHandler = function(e) {
      var eventId;

      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        this.genericEventHandlers[e] = null;
      } else {
        this.eventHandlers[eventId] = null;
      }
    };

    LWF.prototype.setEventHandler = function(eventId, eventHandler) {
      this.clearEventHandler(eventId);
      this.addEventHandler(eventId, eventHandler);
    };

    LWF.prototype.getProgramObjectConstructor = function(programObjectId) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return null;
      }
      return this.programObjectConstructors[programObjectId];
    };

    LWF.prototype.setProgramObjectConstructor = function(programObjectId, programObjectConstructor) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return;
      }
      this.programObjectConstructors[programObjectId] = programObjectConstructor;
    };

    LWF.prototype.getMovieEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;

      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.movieEventHandlers[instId];
        } else {
          if (this.movieEventHandlersByFullName == null) {
            return null;
          }
          return this.movieEventHandlersByFullName[instanceName];
        }
      }
      if (this.movieEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.movieEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.movieEventHandlers[m.instanceId];
    };

    LWF.prototype.addMovieEventHandler = function(instanceName, handlers) {
      var h, instId, movie, _ref1;

      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.movieEventHandlers[instId];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlers[instId] = h;
        }
        movie = this.searchMovieInstanceByInstanceId(instId);
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if ((_ref1 = this.movieEventHandlersByFullName) == null) {
          this.movieEventHandlersByFullName = [];
        }
        h = this.movieEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlersByFullName[instanceName] = h;
        }
        movie = this.searchMovieInstance(instanceName);
      }
      h.add(handlers);
      if (movie != null) {
        movie.setHandlers(h);
      }
    };

    LWF.prototype.removeMovieEventHandler = function(instanceName, handlers) {
      var h, movie;

      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
      movie = this.searchMovieInstance(instanceName);
      if (movie != null) {
        movie.handler.remove(handlers);
      }
    };

    LWF.prototype.clearMovieEventHandler = function(instanceName, type) {
      var h, movie;

      if (type == null) {
        type = null;
      }
      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
      movie = this.searchMovieInstance(instanceName);
      if (movie != null) {
        movie.handler.clear(type);
      }
    };

    LWF.prototype.setMovieEventHandler = function(instanceName, handlers) {
      this.clearMovieEventHandler(instanceName);
      this.addMovieEventHandler(instanceName, handlers);
    };

    LWF.prototype.getButtonEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;

      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.buttonEventHandlers[instId];
        } else {
          if (this.buttonEventHandlersByFullName == null) {
            return null;
          }
          return this.buttonEventHandlersByFullName[instanceName];
        }
      }
      if (this.buttonEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.buttonEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.buttonEventHandlers[m.instanceId];
    };

    LWF.prototype.addButtonEventHandler = function(instanceName, handlers) {
      var button, h, instId, _ref1;

      this.setInteractive();
      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.buttonEventHandlers[instId];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlers[instId] = h;
        }
        button = this.searchButtonInstanceByInstanceId(instId);
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if ((_ref1 = this.buttonEventHandlersByFullName) == null) {
          this.buttonEventHandlersByFullName = [];
        }
        h = this.buttonEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlersByFullName[instanceName] = h;
        }
        button = this.searchButtonInstance(instanceName);
      }
      h.add(handlers);
      if (button != null) {
        button.setHandlers(h);
      }
    };

    LWF.prototype.removeButtonEventHandler = function(instanceName, handlers) {
      var button, h;

      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
      button = this.searchButtonInstance(instanceName);
      if ((button != null ? button.handler : void 0) != null) {
        button.handler.remove(handlers);
      }
    };

    LWF.prototype.clearButtonEventHandler = function(instanceName, type) {
      var button, h;

      if (type == null) {
        type = null;
      }
      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
      button = this.searchButtonInstance(instanceName);
      if ((typeof buffon !== "undefined" && buffon !== null ? buffon.handler : void 0) != null) {
        button.handler.clear(type);
      }
    };

    LWF.prototype.setButtonEventHandler = function(instanceName, handlers) {
      this.clearButtonEventHandler(instanceName);
      this.addButtonEventHandler(instanceName, handlers);
    };

    LWF.prototype.execMovieCommand = function() {
      var available, deletes, k, movie, name, v, _i, _j, _len, _len1, _ref1;

      deletes = [];
      _ref1 = this.movieCommands;
      for (k in _ref1) {
        v = _ref1[k];
        available = true;
        movie = this.rootMovie;
        for (_i = 0, _len = k.length; _i < _len; _i++) {
          name = k[_i];
          movie = movie.searchMovieInstance(name);
          if (movie == null) {
            available = false;
            break;
          }
        }
        if (available) {
          v(movie);
          deletes.push(k);
        }
      }
      for (_j = 0, _len1 = deletes.length; _j < _len1; _j++) {
        k = deletes[_j];
        delete this.movieCommands[k];
      }
    };

    LWF.prototype.setMovieCommand = function(instanceNames, cmd) {
      var names;

      names = instanceNames.slice(0);
      this.movieCommands[names] = cmd;
      this.execMovieCommand();
    };

    LWF.prototype.searchAttachedMovie = function(attachName) {
      return this.rootMovie.searchAttachedMovie(attachName);
    };

    LWF.prototype.searchAttachedLWF = function(attachName) {
      return this.rootMovie.searchAttachedLWF(attachName);
    };

    LWF.prototype.addAllowButton = function(buttonName) {
      var instId;

      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.allowButtonList == null) {
        this.allowButtonList = {};
      }
      this.allowButtonList[instId] = true;
      return true;
    };

    LWF.prototype.removeAllowButton = function(buttonName) {
      var instId;

      if (this.allowButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.allowButtonList[instId];
      return true;
    };

    LWF.prototype.clearAllowButton = function() {
      this.allowButtonList = null;
    };

    LWF.prototype.addDenyButton = function(buttonName) {
      var instId;

      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      this.denyButtonList[instId] = true;
      return true;
    };

    LWF.prototype.denyAllButtons = function() {
      var instId, _i, _ref1;

      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      for (instId = _i = 0, _ref1 = this.data.instanceNames.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; instId = 0 <= _ref1 ? ++_i : --_i) {
        this.denyButtonList[instId] = true;
      }
    };

    LWF.prototype.removeDenyButton = function(buttonName) {
      var instId;

      if (this.denyButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.denyButtonList[instId];
      return true;
    };

    LWF.prototype.clearDenyButton = function() {
      this.denyButtonList = null;
    };

    LWF.prototype.disableExec = function() {
      this.isExecDisabled = true;
      this.executedForExecDisabled = false;
    };

    LWF.prototype.enableExec = function() {
      this.isExecDisabled = false;
    };

    LWF.prototype.setPropertyDirty = function() {
      this.isPropertyDirty = true;
      if (this.parent != null) {
        this.parent.lwf.setPropertyDirty();
      }
    };

    LWF.prototype.setParent = function(parent) {
      var func, _ref1;

      this.active = true;
      this.parent = parent;
      func = (_ref1 = this.functions) != null ? _ref1['init'] : void 0;
      if (func != null) {
        func.call(this);
      }
    };

    LWF.prototype.setInteractive = function() {
      this.interactive = true;
      if (this.parent != null) {
        this.parent.lwf.setInteractive();
      }
    };

    LWF.prototype.setFrameSkip = function(frameSkip) {
      this.frameSkip = frameSkip;
      this.progress = 0;
      if (this.parent != null) {
        this.parent.lwf.setFrameSkip(frameSkip);
      }
    };

    LWF.prototype.getMovieFunctions = function(movieId) {
      var enterFrameFunc, linkageName, loadFunc, postLoadFunc, unloadFunc, _ref1, _ref2, _ref3, _ref4;

      linkageName = this.getMovieLinkageName(movieId);
      loadFunc = (_ref1 = this.functions) != null ? _ref1[linkageName + "_load"] : void 0;
      postLoadFunc = (_ref2 = this.functions) != null ? _ref2[linkageName + "_postLoad"] : void 0;
      unloadFunc = (_ref3 = this.functions) != null ? _ref3[linkageName + "_unload"] : void 0;
      enterFrameFunc = (_ref4 = this.functions) != null ? _ref4[linkageName + "_enterFrame"] : void 0;
      return [loadFunc, postLoadFunc, unloadFunc, enterFrameFunc];
    };

    LWF.prototype.playAnimation = function(animationId, movie, button) {
      var a, animations, count, eventId, func, handler, handlers, i, instId, j, stringId, target, _i, _j, _len, _ref1;

      i = 0;
      animations = this.data.animations[animationId];
      target = movie;
      while (true) {
        a = animations[i++];
        switch (a) {
          case Animation.END:
            return;
          case Animation.PLAY:
            target.play();
            break;
          case Animation.STOP:
            target.stop();
            break;
          case Animation.NEXTFRAME:
            target.nextFrame();
            break;
          case Animation.PREVFRAME:
            target.prevFrame();
            break;
          case Animation.GOTOFRAME:
            target.gotoFrameInternal(animations[i++]);
            break;
          case Animation.GOTOLABEL:
            target.gotoFrame(this.searchFrame(target, animations[i++]));
            break;
          case Animation.SETTARGET:
            target = movie;
            count = animations[i++];
            if (count !== 0) {
              for (j = _i = 0; 0 <= count ? _i < count : _i > count; j = 0 <= count ? ++_i : --_i) {
                instId = animations[i++];
                switch (instId) {
                  case Animation.INSTANCE_TARGET_ROOT:
                    target = this.rootMovie;
                    break;
                  case Animation.INSTANCE_TARGET_PARENT:
                    target = target.parent;
                    if (this.target == null) {
                      target = this.rootMovie;
                    }
                    break;
                  default:
                    target = target.searchMovieInstanceByInstanceId(instId, false);
                    if (target == null) {
                      target = movie;
                    }
                }
              }
            }
            break;
          case Animation.EVENT:
            eventId = animations[i++];
            handlers = this.eventHandlers[eventId];
            if (handlers != null) {
              for (_j = 0, _len = handlers.length; _j < _len; _j++) {
                handler = handlers[_j];
                handler(movie, button);
              }
            }
            break;
          case Animation.CALL:
            stringId = animations[i++];
            func = (_ref1 = this.functions) != null ? _ref1[this.data.strings[stringId]] : void 0;
            if (func != null) {
              func.call(movie);
            }
        }
      }
    };

    LWF.prototype.dispatchEvent = function(e, movie, button) {
      var eventId, handler, handlers, _i, _len;

      if (movie == null) {
        movie = this.rootMovie;
      }
      if (button == null) {
        button = null;
      }
      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        handlers = this.genericEventHandlers[e];
      } else {
        handlers = this.eventHandlers[eventId];
      }
      if (handlers == null) {
        return false;
      }
      handlers = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          _results.push(handler);
        }
        return _results;
      })();
      for (_i = 0, _len = handlers.length; _i < _len; _i++) {
        handler = handlers[_i];
        if (handler != null) {
          handler(movie, button);
        }
      }
      return true;
    };

    LWF.prototype.inputPoint = function(x, y) {
      var button, found;

      if (this.rootMovie == null) {
        return null;
      }
      this.intercepted = false;
      if (!this.interactive) {
        return null;
      }
      this.pointX = x;
      this.pointY = y;
      found = false;
      button = this.buttonHead;
      while (button != null) {
        if (button.checkHit(x, y)) {
          if (this.allowButtonList != null) {
            if (this.allowButtonList[button.instanceId] == null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          } else if (this.denyButtonList != null) {
            if (this.denyButtonList[button.instanceId] != null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          }
          found = true;
          if (this.focus !== button) {
            if (this.focus != null) {
              this.focus.rollOut();
            }
            this.focus = button;
            this.focus.rollOver();
          }
          break;
        }
        button = button.buttonLink;
      }
      if (!found && (this.focus != null)) {
        this.focus.rollOut();
        this.focus = null;
      }
      return this.focus;
    };

    LWF.prototype.inputPress = function() {
      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      this.pressing = true;
      if (this.focus != null) {
        this.pressed = this.focus;
        this.focus.press();
      }
    };

    LWF.prototype.inputRelease = function() {
      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      this.pressing = false;
      if ((this.focus != null) && this.pressed === this.focus) {
        this.focus.release();
        this.pressed = null;
      }
    };

    LWF.prototype.inputKeyPress = function(code) {
      var button;

      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      button = this.buttonHead;
      while (button != null) {
        button.keyPress(code);
        button = button.buttonLink;
      }
    };

    return LWF;

  })();

  if (typeof global !== "undefined") {
    if ((_ref1 = global["LWF"]) == null) {
      global["LWF"] = {};
    }
    global["LWF"]["Color"] = Color;
    global["LWF"]["ColorTransform"] = ColorTransform;
    global["LWF"]["Format"] = Format;
    global["LWF"]["LWF"] = LWF;
    global["LWF"]["Loader"] = Loader;
    global["LWF"]["Matrix"] = Matrix;
    global["LWF"]["Movie"] = Movie;
    global["LWF"]["Point"] = Point;
    global["LWF"]["Property"] = Property;
  }

  LWF.prototype["addAllowButton"] = LWF.prototype.addAllowButton;

  LWF.prototype["addButtonEventHandler"] = LWF.prototype.addButtonEventHandler;

  LWF.prototype["addButtonEventListener"] = LWF.prototype.addButtonEventHandler;

  LWF.prototype["addDenyButton"] = LWF.prototype.addDenyButton;

  LWF.prototype["addEventHandler"] = LWF.prototype.addEventHandler;

  LWF.prototype["addEventListener"] = LWF.prototype.addEventHandler;

  LWF.prototype["addMovieEventHandler"] = LWF.prototype.addMovieEventHandler;

  LWF.prototype["addMovieEventListener"] = LWF.prototype.addMovieEventHandler;

  LWF.prototype["clearAllowButton"] = LWF.prototype.clearAllowButton;

  LWF.prototype["clearButtonEventHandler"] = LWF.prototype.clearButtonEventHandler;

  LWF.prototype["clearButtonEventListener"] = LWF.prototype.clearButtonEventHandler;

  LWF.prototype["clearDenyButton"] = LWF.prototype.clearDenyButton;

  LWF.prototype["clearEventHandler"] = LWF.prototype.clearEventHandler;

  LWF.prototype["clearEventListener"] = LWF.prototype.clearEventHandler;

  LWF.prototype["clearMovieEventHandler"] = LWF.prototype.clearMovieEventHandler;

  LWF.prototype["clearMovieEventListener"] = LWF.prototype.clearMovieEventHandler;

  LWF.prototype["denyAllButtons"] = LWF.prototype.denyAllButtons;

  LWF.prototype["destroy"] = LWF.prototype.destroy;

  LWF.prototype["dispatchEvent"] = LWF.prototype.dispatchEvent;

  LWF.prototype["exec"] = LWF.prototype.exec;

  LWF.prototype["fitForHeight"] = LWF.prototype.fitForHeight;

  LWF.prototype["fitForWidth"] = LWF.prototype.fitForWidth;

  LWF.prototype["forceExec"] = LWF.prototype.forceExec;

  LWF.prototype["forceExecWithoutProgress"] = LWF.prototype.forceExecWithoutProgress;

  LWF.prototype["getStageSize"] = LWF.prototype.getStageSize;

  LWF.prototype["getStringId"] = LWF.prototype.getStringId;

  LWF.prototype["init"] = LWF.prototype.init;

  LWF.prototype["inputKeyPress"] = LWF.prototype.inputKeyPress;

  LWF.prototype["inputPoint"] = LWF.prototype.inputPoint;

  LWF.prototype["inputPress"] = LWF.prototype.inputPress;

  LWF.prototype["inputRelease"] = LWF.prototype.inputRelease;

  LWF.prototype["inspect"] = LWF.prototype.inspect;

  LWF.prototype["removeAllowButton"] = LWF.prototype.removeAllowButton;

  LWF.prototype["removeButtonEventHandler"] = LWF.prototype.removeButtonEventHandler;

  LWF.prototype["removeButtonEventListener"] = LWF.prototype.removeButtonEventHandler;

  LWF.prototype["removeDenyButton"] = LWF.prototype.removeDenyButton;

  LWF.prototype["removeEventHandler"] = LWF.prototype.removeEventHandler;

  LWF.prototype["removeEventListener"] = LWF.prototype.removeEventHandler;

  LWF.prototype["removeMovieEventHandler"] = LWF.prototype.removeMovieEventHandler;

  LWF.prototype["removeMovieEventListener"] = LWF.prototype.removeMovieEventHandler;

  LWF.prototype["render"] = LWF.prototype.render;

  LWF.prototype["scaleForHeight"] = LWF.prototype.scaleForHeight;

  LWF.prototype["scaleForWidth"] = LWF.prototype.scaleForWidth;

  LWF.prototype["searchAttachedLWF"] = LWF.prototype.searchAttachedLWF;

  LWF.prototype["searchAttachedMovie"] = LWF.prototype.searchAttachedMovie;

  LWF.prototype["searchEventId"] = LWF.prototype.searchEventId;

  LWF.prototype["searchFrame"] = LWF.prototype.searchFrame;

  LWF.prototype["searchProgramObjectId"] = LWF.prototype.searchProgramObjectId;

  LWF.prototype["setButtonEventHandler"] = LWF.prototype.setButtonEventHandler;

  LWF.prototype["setButtonEventListener"] = LWF.prototype.setButtonEventHandler;

  LWF.prototype["setEventHandler"] = LWF.prototype.setEventHandler;

  LWF.prototype["setEventListener"] = LWF.prototype.setEventHandler;

  LWF.prototype["setFrameRate"] = LWF.prototype.setFrameRate;

  LWF.prototype["setFrameSkip"] = LWF.prototype.setFrameSkip;

  LWF.prototype["setMovieCommand"] = LWF.prototype.setMovieCommand;

  LWF.prototype["setMovieEventHandler"] = LWF.prototype.setMovieEventHandler;

  LWF.prototype["setMovieEventListener"] = LWF.prototype.setMovieEventHandler;

  LWF.prototype["setPreferredFrameRate"] = LWF.prototype.setPreferredFrameRate;

  LWF.prototype["setProgramObjectConstructor"] = LWF.prototype.setProgramObjectConstructor;

  LWF.prototype["setRendererFactory"] = LWF.prototype.setRendererFactory;

  Loader["load"] = Loader.load;

  Data.prototype["check"] = Data.prototype.check;

  Data.prototype["name"] = Data.prototype.name;

  IObject.prototype["getFullName"] = IObject.prototype.getFullName;

  Button.prototype["addEventHandler"] = Button.prototype.addEventHandler;

  Button.prototype["addEventListener"] = Button.prototype.addEventHandler;

  Button.prototype["clearEventHandler"] = Button.prototype.clearEventHandler;

  Button.prototype["clearEventListener"] = Button.prototype.clearEventHandler;

  Button.prototype["dispatchEvent"] = Button.prototype.dispatchEvent;

  Button.prototype["removeEventHandler"] = Button.prototype.removeEventHandler;

  Button.prototype["removeEventListener"] = Button.prototype.removeEventHandler;

  Button.prototype["setEventHandler"] = Button.prototype.setEventHandler;

  Button.prototype["setEventListener"] = Button.prototype.setEventHandler;

  Movie.prototype["addEventHandler"] = Movie.prototype.addEventHandler;

  Movie.prototype["addEventListener"] = Movie.prototype.addEventHandler;

  Movie.prototype["attachLWF"] = Movie.prototype.attachLWF;

  Movie.prototype["attachMovie"] = Movie.prototype.attachMovie;

  Movie.prototype["clearEventHandler"] = Movie.prototype.clearEventHandler;

  Movie.prototype["clearEventListener"] = Movie.prototype.clearEventHandler;

  Movie.prototype["detachFromParent"] = Movie.prototype.detachFromParent;

  Movie.prototype["detachLWF"] = Movie.prototype.detachLWF;

  Movie.prototype["detachMovie"] = Movie.prototype.detachMovie;

  Movie.prototype["dispatchEvent"] = Movie.prototype.dispatchEvent;

  Movie.prototype["getAttachedLWF"] = Movie.prototype.getAttachedLWF;

  Movie.prototype["getAttachedMovie"] = Movie.prototype.getAttachedMovie;

  Movie.prototype["getBounds"] = Movie.prototype.getBounds;

  Movie.prototype["globalToLocal"] = Movie.prototype.globalToLocal;

  Movie.prototype["gotoAndPlay"] = Movie.prototype.gotoAndPlay;

  Movie.prototype["gotoAndStop"] = Movie.prototype.gotoAndStop;

  Movie.prototype["gotoFrame"] = Movie.prototype.gotoFrame;

  Movie.prototype["gotoLabel"] = Movie.prototype.gotoLabel;

  Movie.prototype["inspect"] = Movie.prototype.inspect;

  Movie.prototype["localToGlobal"] = Movie.prototype.localToGlobal;

  Movie.prototype["move"] = Movie.prototype.move;

  Movie.prototype["moveTo"] = Movie.prototype.moveTo;

  Movie.prototype["nextFrame"] = Movie.prototype.nextFrame;

  Movie.prototype["override"] = Movie.prototype.override;

  Movie.prototype["play"] = Movie.prototype.play;

  Movie.prototype["prevFrame"] = Movie.prototype.prevFrame;

  Movie.prototype["removeEventHandler"] = Movie.prototype.removeEventHandler;

  Movie.prototype["removeEventListener"] = Movie.prototype.removeEventHandler;

  Movie.prototype["removeMovieClip"] = Movie.prototype.removeMovieClip;

  Movie.prototype["requestCalculateBounds"] = Movie.prototype.requestCalculateBounds;

  Movie.prototype["rotate"] = Movie.prototype.rotate;

  Movie.prototype["rotateTo"] = Movie.prototype.rotateTo;

  Movie.prototype["scale"] = Movie.prototype.scale;

  Movie.prototype["scaleTo"] = Movie.prototype.scaleTo;

  Movie.prototype["searchAttachedLWF"] = Movie.prototype.searchAttachedLWF;

  Movie.prototype["searchAttachedMovie"] = Movie.prototype.searchAttachedMovie;

  Movie.prototype["searchMovieInstance"] = Movie.prototype.searchMovieInstance;

  Movie.prototype["searchMovieInstanceByInstanceId"] = Movie.prototype.searchMovieInstanceByInstanceId;

  Movie.prototype["setAlpha"] = Movie.prototype.setAlpha;

  Movie.prototype["setColorTransform"] = Movie.prototype.setColorTransform;

  Movie.prototype["setEventHandler"] = Movie.prototype.setEventHandler;

  Movie.prototype["setEventListener"] = Movie.prototype.setEventHandler;

  Movie.prototype["setMatrix"] = Movie.prototype.setMatrix;

  Movie.prototype["setRenderingOffset"] = Movie.prototype.setRenderingOffset;

  Movie.prototype["setVisible"] = Movie.prototype.setVisible;

  Movie.prototype["stop"] = Movie.prototype.stop;

  Movie.prototype["swapAttachedLWFDepth"] = Movie.prototype.swapAttachedLWFDepth;

  Movie.prototype["swapAttachedMovieDepth"] = Movie.prototype.swapAttachedMovieDepth;

  Movie.prototype["swapDepths"] = Movie.prototype.swapDepths;

  Property.prototype["clear"] = Property.prototype.clear;

  Property.prototype["move"] = Property.prototype.move;

  Property.prototype["moveTo"] = Property.prototype.moveTo;

  Property.prototype["rotate"] = Property.prototype.rotate;

  Property.prototype["rotateTo"] = Property.prototype.rotateTo;

  Property.prototype["scale"] = Property.prototype.scale;

  Property.prototype["scaleTo"] = Property.prototype.scaleTo;

  Property.prototype["setAlpha"] = Property.prototype.setAlpha;

  Property.prototype["setColorTransform"] = Property.prototype.setColorTransform;

  Property.prototype["setMatrix"] = Property.prototype.setMatrix;

  Matrix.prototype["clear"] = Matrix.prototype.clear;

  Matrix.prototype["set"] = Matrix.prototype.set;

  Color.prototype["set"] = Color.prototype.set;

  ColorTransform.prototype["clear"] = ColorTransform.prototype.clear;

  ColorTransform.prototype["set"] = ColorTransform.prototype.set;

  WebkitCSSRendererFactory = (function() {
    function WebkitCSSRendererFactory(data, resourceCache, cache, stage, textInSubpixel, use3D) {
      var bitmap, bitmapEx, h, style, text, w, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5;

      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.use3D = use3D;
      this.maskMode = "normal";
      this.bitmapContexts = [];
      _ref2 = data.bitmaps;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        bitmap = _ref2[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        this.bitmapContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref3 = data.bitmapExs;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        bitmapEx = _ref3[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref4 = data.texts;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        text = _ref4[_k];
        this.textContexts.push(new WebkitCSSTextContext(this, data, text));
      }
      style = this.stage.style;
      style.display = "block";
      style.overflow = "hidden";
      style.webkitUserSelect = "none";
      if (this.use3D) {
        style.webkitTransform = "translateZ(0)";
        style.webkitTransformStyle = "preserve-3d";
      }
      _ref5 = this.getStageSize(), w = _ref5[0], h = _ref5[1];
      if (w === 0 && h === 0) {
        style.width = "" + data.header.width + "px";
        style.height = "" + data.header.height + "px";
      }
      this.initCommands();
    }

    WebkitCSSRendererFactory.prototype.initCommands = function() {
      this.commands = {};
      this.commandsKeys = Utility.newIntArray();
      this.subCommands = null;
      this.subCommandsKeys = null;
    };

    WebkitCSSRendererFactory.prototype.isMask = function(cmd) {
      switch (cmd.maskMode) {
        case "erase":
        case "mask":
          return true;
      }
      return false;
    };

    WebkitCSSRendererFactory.prototype.isLayer = function(cmd) {
      return cmd.maskMode === "layer";
    };

    WebkitCSSRendererFactory.prototype.addCommand = function(rIndex, cmd) {
      if (this.isMask(cmd)) {
        if (this.subCommands != null) {
          this.subCommands[rIndex] = cmd;
          Utility.insertIntArray(this.subCommandsKeys, rIndex);
        }
      } else {
        if (this.isLayer(cmd) && this.commandMaskMode !== cmd.maskMode) {
          cmd.subCommands = {};
          cmd.subCommandsKeys = Utility.newIntArray();
          this.subCommands = cmd.subCommands;
          this.subCommandsKeys = cmd.subCommandsKeys;
        }
        this.commands[rIndex] = cmd;
        Utility.insertIntArray(this.commandsKeys, rIndex);
      }
      this.commandMaskMode = cmd.maskMode;
    };

    WebkitCSSRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;

      _ref2 = this.bitmapContexts;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        context = _ref2[_i];
        context.destruct();
      }
      _ref3 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        context = _ref3[_j];
        context.destruct();
      }
      _ref4 = this.textContexts;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        context = _ref4[_k];
        context.destruct();
      }
    };

    WebkitCSSRendererFactory.prototype.init = function(lwf) {
      var domName, m, name, progObj, _i, _len, _ref2, _results,
        _this = this;

      lwf.stage = this.stage;
      lwf.resourceCache = this.resourceCache;
      if (this.setupedDomElementConstructor) {
        return;
      }
      this.setupedDomElementConstructor = true;
      _ref2 = lwf.data.programObjects;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        progObj = _ref2[_i];
        name = lwf.data.strings[progObj.stringId];
        m = name.match(/^DOM_(.*)/);
        if (m != null) {
          domName = m[1];
          _results.push((function(domName) {
            return lwf.setProgramObjectConstructor(name, function(lwf_, objId, w, h) {
              var ctor, domElement;

              ctor = _this.resourceCache.domElementConstructor;
              if (ctor == null) {
                return null;
              }
              domElement = ctor(lwf_, domName, w, h);
              if (domElement == null) {
                return null;
              }
              return new WebkitCSSDomElementRenderer(_this, domElement);
            });
          })(domName));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WebkitCSSRendererFactory.prototype.beginRender = function(lwf) {};

    WebkitCSSRendererFactory.prototype.render = function(cmd) {
      var m, node, renderer, scaleX, scaleY, skew0, skew1, style, translateX, translateY;

      renderer = cmd.renderer;
      node = renderer.node;
      style = node.style;
      style.zIndex = renderer.zIndex;
      m = cmd.matrix;
      switch (cmd.maskMode) {
        case "mask":
          this.renderMasked = true;
          style.opacity = 0;
          if (this.renderMaskMode !== "mask") {
            if (node.mask != null) {
              this.mask = node.mask;
              style = this.mask.style;
            } else {
              this.mask = node.mask = document.createElement("div");
              style = this.mask.style;
              style.display = "block";
              style.position = "absolute";
              style.overflow = "hidden";
              style.webkitUserSelect = "none";
              style.webkitTransformOrigin = "0px 0px";
              this.stage.appendChild(this.mask);
            }
            style.width = node.style.width;
            style.height = node.style.height;
            if (this.maskMatrix == null) {
              this.maskMatrix = new Matrix();
              this.maskedMatrix = new Matrix();
            }
            Utility.invertMatrix(this.maskMatrix, m);
          } else {
            return;
          }
          break;
        case "layer":
          if (this.renderMasked) {
            if (this.renderMaskMode !== cmd.maskMode) {
              this.mask.style.zIndex = renderer.zIndex;
            }
            if (node.parentNode !== this.mask) {
              node.parentNode.removeChild(node);
              this.mask.appendChild(node);
            }
            m = Utility.calcMatrix(this.maskedMatrix, this.maskMatrix, m);
          } else {
            if (node.parentNode !== this.stage) {
              node.parentNode.removeChild(node);
              this.stage.appendChild(node);
            }
          }
          break;
        default:
          if (node.parentNode !== this.stage) {
            node.parentNode.removeChild(node);
            this.stage.appendChild(node);
          }
      }
      this.renderMaskMode = cmd.maskMode;
      style.opacity = renderer.alpha;
      scaleX = m.scaleX.toFixed(12);
      scaleY = m.scaleY.toFixed(12);
      skew1 = m.skew1.toFixed(12);
      skew0 = m.skew0.toFixed(12);
      translateX = m.translateX.toFixed(12);
      translateY = m.translateY.toFixed(12);
      if (this.use3D) {
        style.webkitTransform = "matrix3d(" + ("" + scaleX + "," + skew1 + ",0,0,") + ("" + skew0 + "," + scaleY + ",0,0,") + "0,0,1,0," + ("" + translateX + "," + translateY + ",0,1)");
      } else {
        style.webkitTransform = "matrix(" + ("" + scaleX + "," + skew1 + "," + skew0 + "," + scaleY + "," + translateX + "," + translateY + ")");
      }
    };

    WebkitCSSRendererFactory.prototype.endRender = function(lwf) {
      var cmd, rIndex, scmd, srIndex, _i, _j, _len, _len1, _ref2, _ref3;

      this.renderMaskMode = "normal";
      this.renderMasked = false;
      _ref2 = this.commandsKeys;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rIndex = _ref2[_i];
        cmd = this.commands[rIndex];
        if (cmd.subCommandsKeys != null) {
          _ref3 = cmd.subCommandsKeys;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            srIndex = _ref3[_j];
            scmd = cmd.subCommands[srIndex];
            this.render(scmd);
          }
        }
        this.render(cmd);
      }
      this.initCommands();
    };

    WebkitCSSRendererFactory.prototype.setBlendMode = function(blendMode) {};

    WebkitCSSRendererFactory.prototype.setMaskMode = function(maskMode) {
      this.maskMode = maskMode;
    };

    WebkitCSSRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;

      context = this.bitmapContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;

      context = this.bitmapExContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;

      context = this.textContexts[objectId];
      if (context) {
        return new WebkitCSSTextRenderer(lwf, context, text);
      }
    };

    WebkitCSSRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;

      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    WebkitCSSRendererFactory.prototype.convertColor = function(d, c, t) {
      Utility.calcColor(d, c, t);
      d.red = Math.round(d.red * 255);
      d.green = Math.round(d.green * 255);
      d.blue = Math.round(d.blue * 255);
    };

    WebkitCSSRendererFactory.prototype.convertRGB = function(c) {
      var b, g, r;

      r = Math.round(c.red * 255);
      g = Math.round(c.green * 255);
      b = Math.round(c.blue * 255);
      return "rgb(" + r + "," + g + "," + b + ")";
    };

    WebkitCSSRendererFactory.prototype.getStageSize = function() {
      var r;

      r = this.stage.getBoundingClientRect();
      return [r.width, r.height];
    };

    WebkitCSSRendererFactory.prototype.fitForHeight = function(lwf) {
      var h, w, _ref2;

      _ref2 = this.getStageSize(), w = _ref2[0], h = _ref2[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.fitForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.fitForWidth = function(lwf) {
      var h, w, _ref2;

      _ref2 = this.getStageSize(), w = _ref2[0], h = _ref2[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.fitForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForHeight = function(lwf) {
      var h, w, _ref2;

      _ref2 = this.getStageSize(), w = _ref2[0], h = _ref2[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.scaleForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForWidth = function(lwf) {
      var h, w, _ref2;

      _ref2 = this.getStageSize(), w = _ref2[0], h = _ref2[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.scaleForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.parseBackgroundColor = function(v) {
      var a, b, bgColor, g, lwf, r;

      if (typeof v === "number") {
        bgColor = v;
      } else if (typeof v === "string") {
        bgColor = parseInt(v, 16);
      } else if (v instanceof LWF) {
        lwf = v;
        bgColor = lwf.data.header.backgroundColor;
        bgColor |= 0xff << 24;
      } else {
        return [255, 255, 255, 255];
      }
      a = (bgColor >> 24) & 0xff;
      r = (bgColor >> 16) & 0xff;
      g = (bgColor >> 8) & 0xff;
      b = (bgColor >> 0) & 0xff;
      return [r, g, b, a];
    };

    WebkitCSSRendererFactory.prototype.setBackgroundColor = function(v) {
      var a, b, g, r, _ref2;

      _ref2 = this.parseBackgroundColor(v), r = _ref2[0], g = _ref2[1], b = _ref2[2], a = _ref2[3];
      this.stage.style.backgroundColor = "rgba(" + r + "," + g + "," + b + "," + (a / 255) + ")";
    };

    WebkitCSSRendererFactory.prototype.fitText = function(ctx, line, words, lineStart, imin, imax) {
      var imid, start, str, w;

      if (imax < imin) {
        return;
      }
      imid = ((imin + imax) / 2) >> 0;
      start = lineStart === 0 ? 0 : words[lineStart - 1];
      str = line.slice(start, words[imid]);
      w = ctx.measureText(str).width;
      if (w <= this.maxWidth) {
        if (w > this.lineWidth) {
          this.index = imid;
          this.lineWidth = w;
        }
        this.fitText(ctx, line, words, lineStart, imid + 1, imax);
      }
      if (w >= this.lineWidth) {
        return this.fitText(ctx, line, words, lineStart, imin, imid - 1);
      }
    };

    WebkitCSSRendererFactory.prototype.adjustText = function(lines, ctx, maxWidth) {
      var c, i, imax, imin, line, newlines, prev, start, str, to, word, words, _i, _j, _k, _len, _len1, _ref2;

      this.maxWidth = maxWidth;
      newlines = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        words = line.split(" ");
        line = "";
        for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
          word = words[_j];
          if (word.length > 0) {
            if (line.length > 0) {
              line += " ";
            }
            line += word;
          }
        }
        if (ctx.measureText(line).width > this.maxWidth) {
          words = [];
          prev = 0;
          for (i = _k = 1, _ref2 = line.length; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
            c = line.charCodeAt(i);
            if (c === 0x20 || c >= 0x80 || prev >= 0x80) {
              words.push(i);
            }
            prev = c;
          }
          words.push(line.length);
          imin = 0;
          imax = words.length - 1;
          while (true) {
            this.index = null;
            this.lineWidth = 0;
            this.fitText(ctx, line, words, imin, imin, imax);
            if (this.index === null) {
              break;
            }
            start = imin === 0 ? 0 : words[imin - 1];
            if (line.charCodeAt(start) === 0x20) {
              ++start;
            }
            to = words[this.index];
            str = line.slice(start, to);
            if (this.index === imax) {
              line = str;
              break;
            }
            newlines.push(str);
            start = to + (line.charCodeAt(to) === 0x20 ? 1 : 0);
            str = line.slice(start);
            if (ctx.measureText(str).width <= this.maxWidth) {
              line = str;
              break;
            }
            imin = this.index + 1;
          }
        }
        newlines.push(line);
      }
      return newlines;
    };

    WebkitCSSRendererFactory.prototype.renderText = function(canvas, ctx, str, maxWidth, scale, context, fontHeight, offsetX, textColor) {
      var h, i, leading, len, line, lines, offsetY, property, shadowColor, useStroke, x, y, _i, _ref2, _results;

      lines = this.adjustText(str.split("\n"), ctx, maxWidth);
      property = context.textProperty;
      leading = property.leading * scale;
      switch (property.align & Align.VERTICAL_MASK) {
        case Align.VERTICAL_BOTTOM:
          len = lines.length;
          h = (fontHeight * len + leading * (len - 1)) * 96 / 72;
          offsetY = canvas.height - h;
          break;
        case Align.VERTICAL_MIDDLE:
          len = lines.length + 1;
          h = (fontHeight * len + leading * (len - 1)) * 96 / 72;
          offsetY = (canvas.height - h) / 2;
          break;
        default:
          offsetY = 0;
      }
      ctx.clearRect(0, 0, canvas.width + 1, canvas.height + 1);
      ctx.fillStyle = "rgb(" + textColor.red + "," + textColor.green + "," + textColor.blue + ")";
      useStroke = false;
      if (context.strokeColor != null) {
        ctx.strokeStyle = context.factory.convertRGB(context.strokeColor);
        ctx.lineWidth = property.strokeWidth * scale;
        useStroke = true;
      }
      if (context.shadowColor != null) {
        shadowColor = context.factory.convertRGB(context.shadowColor);
        ctx.shadowOffsetX = property.shadowOffsetX * scale;
        ctx.shadowOffsetY = property.shadowOffsetY * scale;
        ctx.shadowBlur = property.shadowBlur * scale;
      }
      _results = [];
      for (i = _i = 0, _ref2 = lines.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        line = lines[i];
        x = offsetX * scale;
        y = fontHeight + offsetY;
        if (i > 0) {
          y += (fontHeight + leading) * i * 96 / 72;
        }
        if (context.shadowColor != null) {
          ctx.shadowColor = shadowColor;
        }
        ctx.fillText(line, x, y);
        if (useStroke) {
          if (context.shadowColor != null) {
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
          }
          _results.push(ctx.strokeText(line, x, y));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return WebkitCSSRendererFactory;

  })();

  WebkitCSSDomElementRenderer = (function() {
    function WebkitCSSDomElementRenderer(factory, node) {
      this.factory = factory;
      this.node = node;
      this.node.style.position = "absolute";
      this.node.style.webkitTransformOrigin = "0px 0px";
      this.node.style.display = "block";
      this.factory.stage.parentNode.appendChild(this.node);
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = true;
    }

    WebkitCSSDomElementRenderer.prototype.destruct = function() {
      this.factory.stage.parentNode.removeChild(this.node);
    };

    WebkitCSSDomElementRenderer.prototype.update = function(m, c) {};

    WebkitCSSDomElementRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var matrixChanged, style;

      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          this.node.style.visibility = "hidden";
          return;
        } else {
          this.node.style.visibility = "visible";
        }
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (!matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex) {
        return;
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      style = this.node.style;
      style.zIndex = this.zIndex;
      style.opacity = this.alpha;
      m = this.matrix;
      if (this.use3D) {
        style.webkitTransform = "matrix3d(" + ("" + m.scaleX + "," + m.skew1 + ",0,0,") + ("" + m.skew0 + "," + m.scaleY + ",0,0,") + "0,0,1,0," + ("" + m.translateX + "," + m.translateY + ",0,1)");
      } else {
        style.webkitTransform = "matrix(" + ("" + m.scaleX + "," + m.skew1 + "," + m.skew0 + "," + m.scaleY + ",") + ("" + m.translateX + "," + m.translateY + ")");
      }
    };

    return WebkitCSSDomElementRenderer;

  })();

  WebkitCSSResourceCache = (function() {
    var _instance;

    _instance = null;

    WebkitCSSResourceCache.get = function() {
      return _instance != null ? _instance : _instance = new this();
    };

    function WebkitCSSResourceCache() {
      this.cache = {};
      this.lwfInstanceIndex = 0;
      this.canvasIndex = 0;
    }

    WebkitCSSResourceCache.prototype.clear = function() {
      var cache, k, kk, lwfInstance, _ref2, _ref3;

      _ref2 = this.cache;
      for (k in _ref2) {
        cache = _ref2[k];
        _ref3 = cache.instances;
        for (kk in _ref3) {
          lwfInstance = _ref3[kk];
          lwfInstance.destroy();
        }
      }
      return this.cache = {};
    };

    WebkitCSSResourceCache.prototype.getTextureURL = function(settings, data, texture) {
      var imageMap, newUrl, prefix, suffix, url, _ref2, _ref3, _ref4;

      prefix = (_ref2 = (_ref3 = settings["imagePrefix"]) != null ? _ref3 : settings["prefix"]) != null ? _ref2 : "";
      suffix = (_ref4 = settings["imageSuffix"]) != null ? _ref4 : "";
      imageMap = settings["imageMap"];
      url = texture.filename;
      if (typeof imageMap === 'function') {
        newUrl = imageMap.call(settings, url);
        if (newUrl != null) {
          url = newUrl;
        }
      } else if (typeof imageMap === 'object') {
        newUrl = imageMap[url];
        if (newUrl != null) {
          url = newUrl;
        }
      }
      if (!url.match(/^\//)) {
        url = prefix + url;
      }
      url = url.replace(/(\.png|\.jpg)/i, suffix + "$1");
      return url;
    };

    WebkitCSSResourceCache.prototype.checkTextures = function(settings, data) {
      var a, b, colorOp, colorValue, g, h, m, ma, orig, pngFilename, r, re, re_add, re_add10, re_rgb, re_rgb10, re_rgba, re_rgba10, rotated, t, texture, u, v, w, x, y, _base, _i, _len, _ref2, _ref3;

      settings._alphaMap = {};
      settings._colorMap = {};
      settings._textures = [];
      re = new RegExp("_atlas_(.*)_info_" + "([0-9])_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)", "i");
      re_rgb = new RegExp("(.*)_rgb_([0-9a-f]{6})(.*)$", "i");
      re_rgb10 = new RegExp("(.*)_rgb_([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      re_rgba = new RegExp("(.*)_rgba_([0-9a-f]{8})(.*)$", "i");
      re_rgba10 = new RegExp("(.*)_rgba_([0-9]*),([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      re_add = new RegExp("(.*)_add_([0-9a-f]{6})(.*)$", "i");
      re_add10 = new RegExp("(.*)_add_([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      _ref2 = data.textures;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        texture = _ref2[_i];
        orig = null;
        if ((m = texture.filename.match(re_rgb)) != null) {
          orig = m[1] + m[3];
          colorOp = "rgb";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_rgb10)) != null) {
          orig = m[1] + m[5];
          colorOp = "rgb";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b;
        } else if ((m = texture.filename.match(re_rgba)) != null) {
          orig = m[1] + m[3];
          colorOp = "rgba";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_rgba10)) != null) {
          orig = m[1] + m[6];
          colorOp = "rgba";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          a = parseInt(m[5], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b + (a.length === 1 ? "0" : "") + a;
        } else if ((m = texture.filename.match(re_add)) != null) {
          orig = m[1] + m[3];
          colorOp = "add";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_add10)) != null) {
          orig = m[1] + m[5];
          colorOp = "add";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b;
        }
        if (orig != null) {
          ma = texture.filename.match(re);
          if (ma != null) {
            orig = ma[1];
            rotated = ma[2] === "1" ? true : false;
            u = parseInt(ma[3], 10);
            v = parseInt(ma[4], 10);
            w = parseInt(ma[5], 10);
            h = parseInt(ma[6], 10);
            x = parseInt(ma[7], 10);
            y = parseInt(ma[8], 10);
          } else {
            rotated = false;
            u = 0;
            v = 0;
            w = null;
            h = null;
            x = 0;
            y = 0;
          }
          if ((_ref3 = (_base = settings._colorMap)[orig]) == null) {
            _base[orig] = [];
          }
          settings._colorMap[orig].push({
            filename: texture.filename,
            colorOp: colorOp,
            colorValue: colorValue,
            rotated: rotated,
            u: u,
            v: v,
            w: w,
            h: h,
            x: x,
            y: y
          });
          continue;
        }
        settings._textures.push(texture);
        m = texture.filename.match(/^(.*)_withalpha(.*\.)jpg(.*)$/i);
        if (m != null) {
          pngFilename = "" + m[1] + "_alpha" + m[2] + "png" + m[3];
          t = new Format.TextureReplacement(pngFilename);
          settings._textures.push(t);
          settings._alphaMap[texture.filename] = [texture, t];
          settings._alphaMap[t.filename] = [texture, t];
        }
      }
    };

    WebkitCSSResourceCache.prototype.onloaddata = function(settings, data, url) {
      var lwfUrl;

      if (!((data != null) && data.check())) {
        settings.error.push({
          url: url,
          reason: "dataError"
        });
        settings["onload"].call(settings, null);
        return;
      }
      settings["name"] = data.name();
      this.checkTextures(settings, data);
      lwfUrl = settings["lwf"];
      this.cache[lwfUrl].data = data;
      settings.total = settings._textures.length + 1;
      if (data.useScript) {
        settings.total++;
      }
      settings.loadedCount = 1;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (data.useScript) {
        this.loadJS(settings, data);
      } else {
        this.loadImages(settings, data);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWF = function(settings) {
      var data, lwfUrl, url, _ref2;

      lwfUrl = settings["lwf"];
      url = lwfUrl;
      if (!url.match(/^\//)) {
        url = ((_ref2 = settings["prefix"]) != null ? _ref2 : "") + url;
      }
      settings.error = [];
      if (this.cache[lwfUrl] != null) {
        data = this.cache[lwfUrl].data;
        if (data != null) {
          settings["name"] = data.name();
          this.checkTextures(settings, data);
          settings.total = settings._textures.length + 1;
          settings.loadedCount = 1;
          if (typeof onprogress !== "undefined" && onprogress !== null) {
            onprogress.call(settings, settings.loadedCount, settings.total);
          }
          this.loadImages(settings, data);
          return;
        }
      }
      this.cache[lwfUrl] = {};
      this.loadLWFData(settings, url);
    };

    WebkitCSSResourceCache.prototype.dispatchOnloaddata = function(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data) {
      var i, m, re, scripts, src, workerJS, _i, _ref2,
        _this = this;

      if (useWorker) {
        workerJS = null;
        scripts = document.getElementsByTagName("script");
        re = new RegExp("(^|.*\/" + __FILE__ + ")$", "i");
        for (i = _i = 0, _ref2 = scripts.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
          if (scripts[i].src === "") {
            continue;
          }
          src = scripts[i].src.split('?')[0];
          m = src.match(re);
          if (m != null) {
            workerJS = m[1];
            break;
          }
        }
        if (workerJS != null) {
          (function(workerJS) {
            var worker;

            worker = new Worker(workerJS);
            worker.onmessage = function(e) {
              data = new Data(e.data);
              worker = worker.onmessage = worker.onerror = null;
              return _this.onloaddata(settings, data, url);
            };
            worker.onerror = function(e) {
              settings.error.push({
                url: workerJS,
                reason: "error"
              });
              worker = worker.onmessage = worker.onerror = null;
              return settings["onload"].call(settings, null);
            };
            if (useWorkerWithArrayBuffer && data.type !== "base64") {
              return worker.webkitPostMessage(data.data);
            } else {
              return worker.postMessage(data.data);
            }
          })(workerJS);
        }
      }
      if (workerJS == null) {
        if (data.type === "base64") {
          data = global["LWF"].Base64.atobArray(data.data);
          data = (new global["LWF"].Zlib.Inflate(data)).decompress();
          data = Loader.loadArray(data);
        } else if (useArrayBuffer) {
          data = Loader.loadArrayBuffer(data.data);
        } else {
          data = Loader.load(data.data);
        }
        this.onloaddata(settings, data, url);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFData = function(settings, url) {
      var head, lwfUrl, m, name, onload, script, useArrayBuffer, useWorker, useWorkerWithArrayBuffer, xhr, _base, _ref2,
        _this = this;

      onload = settings["onload"];
      useWorker = false;
      useWorkerWithArrayBuffer = false;
      if (typeof Worker !== 'undefined' && ((settings["worker"] == null) || settings["worker"])) {
        useWorker = true;
        if (typeof Worker.prototype.webkitPostMessage !== "undefined") {
          useWorkerWithArrayBuffer = true;
        }
      }
      m = url.match(/([^\/]+)\.lwf\.js/i);
      if (m != null) {
        name = m[1].toLowerCase();
        head = document.getElementsByTagName('head')[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.charset = "UTF-8";
        script.onabort = function() {
          settings.error.push({
            url: url,
            reason: "abort"
          });
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
        script.onerror = function() {
          settings.error.push({
            url: url,
            reason: "error"
          });
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
        script.onload = function() {
          var data, str, _ref2, _ref3;

          str = (_ref2 = global["LWF"]) != null ? (_ref3 = _ref2["DataScript"]) != null ? _ref3[name] : void 0 : void 0;
          head.removeChild(script);
          script = script.onload = script.onabort = script.onerror = null;
          if (str != null) {
            data = {
              type: "base64",
              data: str
            };
            return _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
          } else {
            settings.error.push({
              url: url,
              reason: "error"
            });
            return onload.call(settings, null);
          }
        };
        script.src = url;
        head.appendChild(script);
        lwfUrl = settings["lwf"];
        if ((_ref2 = (_base = this.cache[lwfUrl]).scripts) == null) {
          _base.scripts = [];
        }
        this.cache[lwfUrl].scripts.push(script);
        return;
      }
      xhr = new XMLHttpRequest;
      xhr.open('GET', url, true);
      if (typeof xhr.responseType === 'string' && typeof Uint8Array !== 'undefined' && typeof Int32Array !== 'undefined' && typeof Float32Array !== 'undefined' && (!useWorker || useWorkerWithArrayBuffer)) {
        useArrayBuffer = true;
        xhr.responseType = "arraybuffer";
      } else {
        useArrayBuffer = false;
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
      }
      xhr.onabort = function() {
        settings.error.push({
          url: url,
          reason: "abort"
        });
        xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
        return onload.call(settings, null);
      };
      xhr.onerror = function() {
        settings.error.push({
          url: url,
          reason: "error"
        });
        xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
        return onload.call(settings, null);
      };
      xhr.onreadystatechange = function() {
        var data;

        if (xhr.readyState !== 4) {
          return;
        }
        if (!(xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300))) {
          settings.error.push({
            url: url,
            reason: "error"
          });
          xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
          onload.call(settings, null);
          return;
        }
        if (useArrayBuffer) {
          data = {
            type: "arraybuffer",
            data: xhr.response
          };
        } else {
          data = {
            type: "text",
            data: xhr.responseText
          };
        }
        _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
        return xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
      };
      xhr.send(null);
    };

    WebkitCSSResourceCache.prototype.loadJS = function(settings, data) {
      var head, lwfUrl, onload, onprogress, script, url, _base, _ref2, _ref3, _ref4,
        _this = this;

      lwfUrl = settings["lwf"];
      url = (_ref2 = settings["js"]) != null ? _ref2 : lwfUrl.replace(/\.lwf(\.js)?/i, ".js");
      if (!url.match(/^\//)) {
        url = ((_ref3 = settings["prefix"]) != null ? _ref3 : "") + url;
      }
      onload = settings["onload"];
      onprogress = settings["onprogress"];
      script = document.createElement("script");
      script.type = "text/javascript";
      script.charset = "UTF-8";
      script.onabort = function() {
        delete _this.cache[lwfUrl];
        settings.error.push({
          url: url,
          reason: "abort"
        });
        script = script.onload = script.onabort = script.onerror = null;
        return onload.call(settings, null);
      };
      script.onerror = function() {
        delete _this.cache[lwfUrl];
        settings.error.push({
          url: url,
          reason: "error"
        });
        script = script.onload = script.onabort = script.onerror = null;
        return onload.call(settings, null);
      };
      script.onload = function() {
        settings.loadedCount++;
        if (onprogress != null) {
          onprogress.call(settings, settings.loadedCount, settings.total);
        }
        script = script.onload = script.onabort = script.onerror = null;
        return _this.loadImages(settings, data);
      };
      script.src = url;
      head = document.getElementsByTagName('head')[0];
      head.appendChild(script);
      if ((_ref4 = (_base = this.cache[lwfUrl]).scripts) == null) {
        _base.scripts = [];
      }
      this.cache[lwfUrl].scripts.push(script);
    };

    WebkitCSSResourceCache.prototype.loadImagesCallback = function(settings, imageCache, data) {
      settings.loadedCount++;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (settings.loadedCount === settings.total) {
        delete settings._alphaMap;
        delete settings._colorMap;
        delete settings._textures;
        if (settings.error.length > 0) {
          delete this.cache[settings["lwf"]];
          settings["onload"].call(settings, null);
        } else {
          this.newLWF(settings, imageCache, data);
        }
      }
    };

    WebkitCSSResourceCache.prototype.drawImage = function(ctx, image, o, x, y, u, v, h, iw, ih) {
      var m;

      if (o.rotated) {
        m = new Matrix();
        Utility.rotateMatrix(m, new Matrix(), 1, x, y + h);
        ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
      } else if (x !== 0 || y !== 0) {
        m = new Matrix();
        Utility.scaleMatrix(m, new Matrix(), 1, x, y);
        ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
      }
      ctx.drawImage(image, u, v, iw, ih, 0, 0, iw, ih);
    };

    WebkitCSSResourceCache.prototype.createCanvas = function(filename, w, h) {
      var canvas, ctx, name;

      if (this.constructor === WebkitCSSResourceCache) {
        name = "canvas_" + ++this.canvasIndex;
        ctx = document.getCSSCanvasContext("2d", name, w, h);
        canvas = ctx.canvas;
        canvas.name = name;
      } else {
        canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        ctx = canvas.getContext('2d');
      }
      return [canvas, ctx];
    };

    WebkitCSSResourceCache.prototype.generateImages = function(settings, imageCache, texture, image) {
      var a, b, canvas, canvasAdd, ctx, ctxAdd, d, g, h, ih, iw, o, r, scale, u, v, val, w, x, y, _i, _len, _ref2, _ref3, _ref4;

      d = settings._colorMap[texture.filename];
      if (d != null) {
        scale = image.width / texture.width;
        for (_i = 0, _len = d.length; _i < _len; _i++) {
          o = d[_i];
          x = Math.round(o.x * scale);
          y = Math.round(o.y * scale);
          u = Math.round(o.u * scale);
          v = Math.round(o.v * scale);
          w = Math.round(((_ref2 = o.w) != null ? _ref2 : texture.width) * scale);
          h = Math.round(((_ref3 = o.h) != null ? _ref3 : texture.height) * scale);
          if (o.rotated) {
            iw = h;
            ih = w;
          } else {
            iw = w;
            ih = h;
          }
          _ref4 = this.createCanvas(o.filename, w, h), canvas = _ref4[0], ctx = _ref4[1];
          switch (o.colorOp) {
            case "rgb":
              ctx.fillStyle = "#" + o.colorValue;
              ctx.fillRect(0, 0, w, h);
              ctx.globalCompositeOperation = 'destination-in';
              this.drawImage(ctx, image, o, x, y, u, v, h, iw, ih);
              break;
            case "rgba":
              this.drawImage(ctx, image, o, x, y, u, v, h, iw, ih);
              ctx.globalCompositeOperation = 'source-atop';
              val = o.colorValue;
              r = parseInt(val.substr(0, 2), 16);
              g = parseInt(val.substr(2, 2), 16);
              b = parseInt(val.substr(4, 2), 16);
              a = parseInt(val.substr(6, 2), 16) / 255;
              ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
              ctx.fillRect(0, 0, w, h);
              break;
            case "add":
              canvasAdd = document.createElement('canvas');
              canvasAdd.width = w;
              canvasAdd.height = h;
              ctxAdd = canvasAdd.getContext('2d');
              ctxAdd.fillStyle = "#" + o.colorValue;
              ctxAdd.fillRect(0, 0, w, h);
              ctxAdd.globalCompositeOperation = 'destination-in';
              this.drawImage(ctxAdd, image, o, x, y, u, v, h, iw, ih);
              this.drawImage(ctx, image, o, x, y, u, v, h, iw, ih);
              ctx.globalCompositeOperation = 'lighter';
              ctx.drawImage(canvasAdd, 0, 0, canvasAdd.width, canvasAdd.height, 0, 0, canvasAdd.width, canvasAdd.height);
          }
          ctx.globalCompositeOperation = 'source-over';
          imageCache[o.filename] = canvas;
        }
      }
    };

    WebkitCSSResourceCache.prototype.loadImages = function(settings, data) {
      var imageCache, texture, url, _fn, _i, _len, _ref2,
        _this = this;

      imageCache = {};
      if (data.textures.length === 0) {
        this.newLWF(settings, imageCache, data);
        return;
      }
      _ref2 = settings._textures;
      _fn = function(texture, url) {
        var image;

        image = new Image();
        image.onabort = function() {
          settings.error.push({
            url: url,
            reason: "abort"
          });
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        image.onerror = function() {
          settings.error.push({
            url: url,
            reason: "error"
          });
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        image.onload = function() {
          var alpha, alphaImg, canvas, ctx, d, jpg, jpgImg, _ref3;

          imageCache[texture.filename] = image;
          d = settings._alphaMap[texture.filename];
          if (d != null) {
            jpg = d[0];
            alpha = d[1];
            jpgImg = imageCache[jpg.filename];
            alphaImg = imageCache[alpha.filename];
            if ((jpgImg != null) && (alphaImg != null)) {
              _ref3 = _this.createCanvas(jpg.filename, jpgImg.width, jpgImg.height), canvas = _ref3[0], ctx = _ref3[1];
              ctx.drawImage(jpgImg, 0, 0, jpgImg.width, jpgImg.height, 0, 0, jpgImg.width, jpgImg.height);
              ctx.globalCompositeOperation = 'destination-in';
              ctx.drawImage(alphaImg, 0, 0, alphaImg.width, alphaImg.height, 0, 0, jpgImg.width, jpgImg.height);
              ctx.globalCompositeOperation = 'source-over';
              delete imageCache[jpg.filename];
              delete imageCache[alpha.filename];
              imageCache[jpg.filename] = canvas;
              _this.generateImages(settings, imageCache, jpg, canvas);
            }
          } else {
            _this.generateImages(settings, imageCache, texture, image);
          }
          image = image.onload = image.onabort = image.onerror = null;
          return _this.loadImagesCallback(settings, imageCache, data);
        };
        return image.src = url;
      };
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        texture = _ref2[_i];
        url = this.getTextureURL(settings, data, texture);
        _fn(texture, url);
      }
    };

    WebkitCSSResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref2, _ref3;

      return new WebkitCSSRendererFactory(data, this, cache, settings["stage"], (_ref2 = settings["textInSubpixel"]) != null ? _ref2 : false, (_ref3 = settings["use3D"]) != null ? _ref3 : true);
    };

    WebkitCSSResourceCache.prototype.onloadLWF = function(settings, lwf) {
      var factory;

      factory = lwf.rendererFactory;
      if (settings["setBackgroundColor"] != null) {
        factory.setBackgroundColor(settings["setBackgroundColor"]);
      } else if (settings["useBackgroundColor"]) {
        factory.setBackgroundColor(lwf);
      }
      if (settings["fitForHeight"]) {
        factory.fitForHeight(lwf);
      } else if (settings["fitForWidth"]) {
        factory.fitForWidth(lwf);
      }
      settings["onload"].call(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.newLWF = function(settings, imageCache, data) {
      var cache, embeddedScript, factory, lwf, lwfUrl, parentLWF, _ref2, _ref3, _ref4;

      lwfUrl = settings["lwf"];
      cache = this.cache[lwfUrl];
      factory = this.newFactory(settings, imageCache, data);
      if (data.useScript) {
        embeddedScript = (_ref2 = global["LWF"]) != null ? (_ref3 = _ref2["Script"]) != null ? _ref3[data.name()] : void 0 : void 0;
      }
      lwf = new LWF(data, factory, embeddedScript, settings["privateData"]);
      if (settings["active"] != null) {
        lwf.active = settings["active"];
      }
      lwf.url = settings["lwf"];
      lwf.lwfInstanceId = ++this.lwfInstanceIndex;
      if ((_ref4 = cache.instances) == null) {
        cache.instances = {};
      }
      cache.instances[lwf.lwfInstanceId] = lwf;
      parentLWF = settings["parentLWF"];
      if (parentLWF != null) {
        parentLWF.loadedLWFs[lwf.lwfInstanceId] = lwf;
      }
      if (settings["preferredFrameRate"] != null) {
        if (settings["execLimit"] != null) {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"], settings["execLimit"]);
        } else {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"]);
        }
      }
      this.onloadLWF(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.unloadLWF = function(lwf) {
      var cache, e, empty, head, k, script, v, _i, _len, _ref2, _ref3;

      cache = this.cache[lwf.url];
      if (cache != null) {
        if (lwf.lwfInstanceId) {
          delete cache.instances[lwf.lwfInstanceId];
        }
        empty = true;
        _ref2 = cache.instances;
        for (k in _ref2) {
          v = _ref2[k];
          empty = false;
          break;
        }
        if (empty) {
          try {
            head = document.getElementsByTagName('head')[0];
            _ref3 = cache.scripts;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              script = _ref3[_i];
              head.removeChild(script);
            }
          } catch (_error) {
            e = _error;
          }
          delete this.cache[lwf.url];
        }
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFs = function(settingsArray, onloadall) {
      var errors, loadTotal, loadedCount, onload, settings, _fn, _i, _len, _results,
        _this = this;

      loadTotal = settingsArray.length;
      loadedCount = 0;
      errors = null;
      _fn = function(onload) {
        return settings["onload"] = function(lwf) {
          if (onload != null) {
            onload(lwf);
          }
          if (settings.error.length > 0) {
            if (errors == null) {
              errors = [];
            }
            errors = errors.concat(settings.error);
          }
          ++loadedCount;
          if (loadTotal === loadedCount) {
            return onloadall(errors);
          }
        };
      };
      _results = [];
      for (_i = 0, _len = settingsArray.length; _i < _len; _i++) {
        settings = settingsArray[_i];
        onload = settings["onload"];
        _fn(onload);
        _results.push(this.loadLWF(settings));
      }
      return _results;
    };

    WebkitCSSResourceCache.prototype.getCache = function() {
      return this.cache;
    };

    WebkitCSSResourceCache.prototype.setParticleConstructor = function(ctor) {
      this.particleConstructor = ctor;
    };

    WebkitCSSResourceCache.prototype.setDOMElementConstructor = function(ctor) {
      this.domElementConstructor = ctor;
    };

    return WebkitCSSResourceCache;

  })();

  if ((typeof window === "undefined" || window === null) && (typeof self !== "undefined" && self !== null)) {
    self.onmessage = function(event) {
      var data;

      if (typeof self.webkitPostMessage !== "undefined" && typeof event.data === "object") {
        data = Loader.loadArrayBuffer(event.data);
        self.webkitPostMessage(data);
      } else {
        data = event.data;
        if (data[0] === 'L' && data[1] === 'W' && data[2] === 'F') {
          data = Loader.load(data);
        } else {
          data = global["LWF"].Base64.atobArray(data);
          data = (new global["LWF"].Zlib.Inflate(data)).decompress();
          data = Loader.loadArray(data);
        }
        if (typeof self.webkitPostMessage !== "undefined") {
          self.webkitPostMessage(data);
        } else {
          self.postMessage(data);
        }
      }
      return self.close();
    };
  }

  WebGLRendererFactory = (function(_super) {
    __extends(WebGLRendererFactory, _super);

    WebGLRendererFactory.shaderProgram = null;

    function WebGLRendererFactory(data, resourceCache, cache, stage, textInSubpixel) {
      var bitmap, bitmapEx, depth, dpr, fn, fragmentShader, gl, params, pmatrix, r, rl, shaderProgram, tb, text, vertexShader, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5;

      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      params = {
        premultipliedAlpha: false
      };
      this.stage.style.webkitUserSelect = "none";
      this.stageContext = (_ref2 = this.stage.getContext("webgl", params)) != null ? _ref2 : this.stage.getContext("experimental-webgl", params);
      if (this.stage.width === 0 && this.stage.height === 0) {
        this.stage.width = data.header.width;
        this.stage.height = data.header.height;
      }
      this.blendMode = "normal";
      this.maskMode = "normal";
      gl = this.stageContext;
      gl.enable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.DITHER);
      gl.disable(gl.SCISSOR_TEST);
      gl.activeTexture(gl.TEXTURE0);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      r = this.stage.getBoundingClientRect();
      dpr = devicePixelRatio;
      this.w = Math.round(r.width * dpr);
      this.h = Math.round(r.height * dpr);
      gl.viewport(0, 0, this.w, this.h);
      if (WebGLRendererFactory.shaderProgram != null) {
        shaderProgram = WebGLRendererFactory.shaderProgram;
      } else {
        vertexShader = this.loadShader(gl, gl.VERTEX_SHADER, "attribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nuniform mat4 uPMatrix;\nuniform mat4 uMatrix;\nvarying mediump vec2 vTextureCoord;\nvoid main() {\n  vTextureCoord = aTextureCoord;\n  gl_Position = uPMatrix * uMatrix * vec4(aVertexPosition, 1.0);\n}");
        fragmentShader = this.loadShader(gl, gl.FRAGMENT_SHADER, "varying mediump vec2 vTextureCoord;\nuniform lowp vec4 uColor;\nuniform sampler2D uTexture;\nvoid main() {\n  gl_FragColor = texture2D(uTexture, vTextureCoord) * uColor;\n}");
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("Unable to initialize the shader program.");
        }
        WebGLRendererFactory.shaderProgram = shaderProgram;
      }
      gl.useProgram(shaderProgram);
      this.aVertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(this.aVertexPosition);
      this.aTextureCoord = gl.getAttribLocation(shaderProgram, "aTextureCoord");
      gl.enableVertexAttribArray(this.aTextureCoord);
      this.uPMatrix = gl.getUniformLocation(shaderProgram, "uPMatrix");
      this.uMatrix = gl.getUniformLocation(shaderProgram, "uMatrix");
      this.uColor = gl.getUniformLocation(shaderProgram, "uColor");
      this.uTexture = gl.getUniformLocation(shaderProgram, "uTexture");
      depth = 1024;
      this.farZ = -(depth - 1);
      rl = this.w;
      tb = -this.h;
      fn = depth * 2;
      pmatrix = [2 / rl, 0, 0, 0, 0, 2 / tb, 0, 0, 0, 0, -2 / fn, 0, -1, 1, 0, 1];
      gl.uniformMatrix4fv(this.uPMatrix, false, new Float32Array(pmatrix));
      this.textures = {};
      this.bitmapContexts = [];
      _ref3 = data.bitmaps;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        bitmap = _ref3[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        this.bitmapContexts.push(new WebGLBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref4 = data.bitmapExs;
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        bitmapEx = _ref4[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new WebGLBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref5 = data.texts;
      for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
        text = _ref5[_k];
        this.textContexts.push(new WebGLTextContext(this, data, text));
      }
      this.initCommands();
    }

    WebGLRendererFactory.prototype.loadShader = function(gl, type, program) {
      var shader;

      shader = gl.createShader(type);
      gl.shaderSource(shader, program);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
      }
      return shader;
    };

    WebGLRendererFactory.prototype.destruct = function() {
      var context, gl, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;

      this.deleteMask();
      gl = this.stageContext;
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      _ref2 = this.bitmapContexts;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        context = _ref2[_i];
        context.destruct();
      }
      _ref3 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        context = _ref3[_j];
        context.destruct();
      }
      _ref4 = this.textContexts;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        context = _ref4[_k];
        context.destruct();
      }
    };

    WebGLRendererFactory.prototype.beginRender = function(lwf) {
      var gl;

      WebGLRendererFactory.__super__.beginRender.apply(this, arguments);
      if (lwf.parent != null) {
        return;
      }
      gl = this.stageContext;
      gl.clear(gl.COLOR_BUFFER_BIT);
    };

    WebGLRendererFactory.prototype.render = function(gl, cmd, rIndex) {
      if (this.renderMaskMode !== cmd.maskMode) {
        this.generateMask();
        switch (cmd.maskMode) {
          case "erase":
          case "mask":
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask();
            }
            this.renderMasked = true;
            this.srcFactor = cmd.maskMode === "erase" ? gl.ONE_MINUS_DST_ALPHA : gl.DST_ALPHA;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFrameBuffer);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            break;
          case "layer":
            if (this.renderMasked) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.layerFrameBuffer);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            break;
          default:
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask();
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        this.renderMaskMode = cmd.maskMode;
      }
      cmd.renderer.renderCommand(cmd.matrix, cmd.colorTransform, rIndex, cmd.blendMode);
    };

    WebGLRendererFactory.prototype.endRender = function(lwf) {
      var cmd, f, gl, rIndex, scmd, srIndex, _i, _j, _len, _len1, _ref2, _ref3, _ref4;

      if (lwf.parent != null) {
        f = lwf.parent.lwf.rendererFactory;
        _ref2 = this.commands;
        for (rIndex in _ref2) {
          cmd = _ref2[rIndex];
          f.addCommand(parseInt(rIndex, 10), cmd);
        }
        this.initCommands();
        return;
      }
      this.renderMaskMode = "normal";
      this.renderMasked = false;
      gl = this.stageContext;
      _ref3 = this.commandsKeys;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        rIndex = _ref3[_i];
        cmd = this.commands[rIndex];
        if (cmd.subCommandsKeys != null) {
          _ref4 = cmd.subCommandsKeys;
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            srIndex = _ref4[_j];
            scmd = cmd.subCommands[srIndex];
            this.render(gl, scmd, srIndex);
          }
        }
        this.render(gl, cmd, rIndex);
      }
      if (this.renderMaskMode !== "normal") {
        if (this.renderMaskMode === "layer" && this.renderMasked) {
          this.renderMask();
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
      }
      this.initCommands();
    };

    WebGLRendererFactory.prototype.setBlendMode = function(blendMode) {
      this.blendMode = blendMode;
    };

    WebGLRendererFactory.prototype.setMaskMode = function(maskMode) {
      this.maskMode = maskMode;
    };

    WebGLRendererFactory.prototype.generateMask = function() {
      var framebuffer, framebuffers, gl, i, texture, textures, triangles, uv, vertices, _i;

      if (this.maskTexture != null) {
        return;
      }
      this.maskMatrix = new Float32Array([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, this.h, 0, 1]);
      this.maskColor = new Float32Array([1, 1, 1, 1]);
      gl = this.stageContext;
      this.maskTexture = gl.createTexture();
      this.layerTexture = gl.createTexture();
      textures = [this.maskTexture, this.layerTexture];
      this.maskFrameBuffer = gl.createFramebuffer();
      this.layerFrameBuffer = gl.createFramebuffer();
      framebuffers = [this.maskFrameBuffer, this.layerFrameBuffer];
      for (i = _i = 0; _i < 2; i = ++_i) {
        texture = textures[i];
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.w, this.h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        framebuffer = framebuffers[i];
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      vertices = new Float32Array([this.w, this.h, 0, this.w, 0, 0, 0, this.h, 0, 0, 0, 0]);
      this.maskVertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.maskVertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      uv = new Float32Array([1, 1, 1, 0, 0, 1, 0, 0]);
      this.maskUVBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.maskUVBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
      triangles = new Uint8Array([0, 1, 2, 2, 1, 3]);
      this.maskTrianglesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.maskTrianglesBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triangles, gl.STATIC_DRAW);
    };

    WebGLRendererFactory.prototype.deleteMask = function() {
      var gl;

      if (this.maskTexture == null) {
        return;
      }
      gl = this.stageContext;
      gl.deleteBuffer(this.maskVertexBuffer);
      gl.deleteBuffer(this.maskUVBuffer);
      gl.deleteBuffer(this.maskTrianglesBuffer);
      gl.deleteFramebuffer(this.maskFrameBuffer);
      gl.deleteFramebuffer(this.layerFrameBuffer);
      this.maskFrameBuffer = null;
      this.layerFrameBuffer = null;
      gl.deleteTexture(this.maskTexture);
      gl.deleteTexture(this.layerTexture);
      this.maskTexture = null;
      this.layerTexture = null;
    };

    WebGLRendererFactory.prototype.renderMask = function() {
      var gl;

      gl = this.stageContext;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.maskVertexBuffer);
      gl.vertexAttribPointer(this.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.maskUVBuffer);
      gl.vertexAttribPointer(this.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(this.uMatrix, false, this.maskMatrix);
      gl.uniform4fv(this.uColor, this.maskColor);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.maskTrianglesBuffer);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFrameBuffer);
      gl.blendFunc(this.srcFactor, gl.ZERO);
      gl.bindTexture(gl.TEXTURE_2D, this.layerTexture);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.bindTexture(gl.TEXTURE_2D, this.maskTexture);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
    };

    WebGLRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;

      context = this.bitmapContexts[objectId];
      if (context) {
        return new WebGLBitmapRenderer(context);
      }
    };

    WebGLRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;

      context = this.bitmapExContexts[objectId];
      if (context) {
        return new WebGLBitmapRenderer(context);
      }
    };

    WebGLRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;

      context = this.textContexts[objectId];
      if (context) {
        return new WebGLTextRenderer(lwf, context, text);
      }
    };

    WebGLRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;

      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    WebGLRendererFactory.prototype.getStageSize = function() {
      var dpr, r;

      r = this.stage.getBoundingClientRect();
      dpr = devicePixelRatio;
      return [r.width * dpr, r.height * dpr];
    };

    WebGLRendererFactory.prototype.setBackgroundColor = function(v) {
      var a, b, g, gl, r, _ref2;

      _ref2 = this.parseBackgroundColor(v), r = _ref2[0], g = _ref2[1], b = _ref2[2], a = _ref2[3];
      gl = this.stageContext;
      gl.clearColor(r / 255, g / 255, b / 255, a / 255);
    };

    return WebGLRendererFactory;

  })(WebkitCSSRendererFactory);

  WebGLBitmapContext = (function() {
    function WebGLBitmapContext(factory, data, bitmapEx) {
      var bh, bu, bv, bw, d, dh, dw, filename, fragment, gl, h, height, image, scale, texdata, th, triangles, tw, u, u0, u1, uv, v, v0, v1, vertices, w, x, x0, x1, y, y0, y1;

      this.factory = factory;
      this.data = data;
      gl = this.factory.stageContext;
      fragment = data.textureFragments[bitmapEx.textureFragmentId];
      texdata = data.textures[fragment.textureId];
      this.preMultipliedAlpha = texdata.format === Format.Constant.TEXTUREFORMAT_PREMULTIPLIEDALPHA;
      filename = texdata.filename;
      d = this.factory.textures[filename];
      if (d != null) {
        this.texture = d[0], scale = d[1];
      } else {
        image = this.factory.cache[filename];
        scale = 1 / texdata.scale;
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.factory.textures[filename] = [this.texture, scale];
      }
      tw = texdata.width;
      th = texdata.height;
      x = fragment.x;
      y = fragment.y;
      u = fragment.u;
      v = fragment.v;
      w = fragment.w;
      h = fragment.h;
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      height = h;
      x0 = x * scale;
      y0 = y * scale;
      x1 = (x + w) * scale;
      y1 = (y + h) * scale;
      vertices = new Float32Array([x1, y1, 0, x1, y0, 0, x0, y1, 0, x0, y0, 0]);
      this.verticesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      dw = 2.0 * tw;
      dh = 2.0 * th;
      if (fragment.rotated === 0) {
        u0 = (2 * u + 1) / dw;
        v0 = (2 * v + 1) / dh;
        u1 = u0 + (w * 2 - 2) / dw;
        v1 = v0 + (h * 2 - 1) / dh;
        uv = new Float32Array([u1, v1, u1, v0, u0, v1, u0, v0]);
      } else {
        u0 = (2 * u + 1) / dw;
        v0 = (2 * v + 1) / dh;
        u1 = u0 + (h * 2 - 2) / dw;
        v1 = v0 + (w * 2 - 1) / dh;
        uv = new Float32Array([u0, v1, u1, v1, u0, v0, u1, v0]);
      }
      this.uvBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
      triangles = new Uint8Array([0, 1, 2, 2, 1, 3]);
      this.trianglesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.trianglesBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triangles, gl.STATIC_DRAW);
    }

    WebGLBitmapContext.prototype.destruct = function() {
      var gl;

      gl = this.factory.stageContext;
      gl.deleteTexture(this.texture);
      gl.deleteBuffer(this.verticesBuffer);
      gl.deleteBuffer(this.uvBuffer);
      gl.deleteBuffer(this.trianglesBuffer);
    };

    return WebGLBitmapContext;

  })();

  WebGLBitmapRenderer = (function() {
    function WebGLBitmapRenderer(context) {
      this.context = context;
      this.matrix = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.color = new Float32Array([0, 0, 0, 0]);
    }

    WebGLBitmapRenderer.prototype.destruct = function() {};

    WebGLBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var factory;

      if (!visible) {
        return;
      }
      factory = this.context.factory;
      factory.addCommand(renderingIndex, {
        renderer: this,
        matrix: m,
        colorTransform: c,
        blendMode: factory.blendMode,
        maskMode: factory.maskMode
      });
    };

    WebGLBitmapRenderer.prototype.renderCommand = function(m, c, renderingIndex, blendMode) {
      var alpha, factory, gc, gl, gm, src;

      factory = this.context.factory;
      gl = factory.stageContext;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.context.verticesBuffer);
      gl.vertexAttribPointer(factory.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.context.uvBuffer);
      gl.vertexAttribPointer(factory.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
      gm = this.matrix;
      gm[0] = m.scaleX;
      gm[1] = m.skew1;
      gm[4] = m.skew0;
      gm[5] = m.scaleY;
      gm[12] = m.translateX;
      gm[13] = m.translateY;
      gm[14] = factory.farZ + renderingIndex;
      gl.uniformMatrix4fv(factory.uMatrix, false, gm);
      gc = this.color;
      if (this.context.preMultipliedAlpha) {
        src = gl.ONE;
        alpha = c.multi.alpha;
        gc[0] = c.multi.red * alpha;
        gc[1] = c.multi.green * alpha;
        gc[2] = c.multi.blue * alpha;
        gc[3] = alpha;
      } else {
        src = gl.SRC_ALPHA;
        gc[0] = c.multi.red;
        gc[1] = c.multi.green;
        gc[2] = c.multi.blue;
        gc[3] = c.multi.alpha;
      }
      gl.blendFunc(src, blendMode === "add" ? gl.ONE : gl.ONE_MINUS_SRC_ALPHA);
      gl.uniform4fv(factory.uColor, gc);
      gl.bindTexture(gl.TEXTURE_2D, this.context.texture);
      gl.uniform1i(factory.uTexture, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.context.trianglesBuffer);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
    };

    return WebGLBitmapRenderer;

  })();

  WebGLResourceCache = (function(_super) {
    __extends(WebGLResourceCache, _super);

    function WebGLResourceCache() {
      _ref2 = WebGLResourceCache.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    WebGLResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref3;

      return new WebGLRendererFactory(data, this, cache, settings.stage, (_ref3 = settings.textInSubpixel) != null ? _ref3 : false);
    };

    return WebGLResourceCache;

  })(WebkitCSSResourceCache);

  HTML5TextContext = (function() {
    function HTML5TextContext(factory, data, text) {
      var font;

      this.factory = factory;
      this.data = data;
      this.text = text;
      this.str = this.data.strings[this.text.stringId];
      this.textProperty = this.data.textProperties[this.text.textPropertyId];
      font = this.data.fonts[this.textProperty.fontId];
      this.textColor = this.data.colors[this.text.colorId];
      this.name = this.data.strings[this.text.nameStringId];
      if (this.textProperty.strokeColorId !== -1) {
        this.strokeColor = this.data.colors[this.textProperty.strokeColorId];
      }
      if (this.textProperty.shadowColorId !== -1) {
        this.shadowColor = this.data.colors[this.textProperty.shadowColorId];
      }
      this.fontName = "" + this.data.strings[font.stringId] + ",sans-serif";
      this.letterSpacing = font.letterSpacing + this.textProperty.letterSpacing;
    }

    HTML5TextContext.prototype.destruct = function() {};

    return HTML5TextContext;

  })();

  HTML5TextRenderer = (function() {
    function HTML5TextRenderer(lwf, context, textObject) {
      var _ref3;

      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      this.str = (_ref3 = this.textObject.parent[this.context.name]) != null ? _ref3 : this.context.str;
      if (this.str != null) {
        this.str = String(this.str);
      }
      this.matrixForScale = new Matrix();
      this.color = new Color;
      this.textRendered = false;
      this.scaleByStage = this.lwf.scaleByStage;
      this.initCanvas();
    }

    HTML5TextRenderer.prototype.destruct = function() {};

    HTML5TextRenderer.prototype.measureText = function(str) {
      var swidth;

      swidth = str.length <= 1 ? 0 : (str.length - 1) * this.letterSpacing;
      return this.canvasContext.measureText(str).width + swidth;
    };

    HTML5TextRenderer.prototype.fitText = function(line, words, lineStart, imin, imax) {
      var imid, start, str, w;

      if (imax < imin) {
        return;
      }
      imid = ((imin + imax) / 2) >> 0;
      start = lineStart === 0 ? 0 : words[lineStart - 1];
      str = line.slice(start, words[imid]);
      w = this.measureText(str);
      if (w <= this.maxWidth) {
        if (w > this.lineWidth) {
          this.index = imid;
          this.lineWidth = w;
        }
        this.fitText(line, words, lineStart, imid + 1, imax);
      }
      if (w >= this.lineWidth) {
        return this.fitText(line, words, lineStart, imin, imid - 1);
      }
    };

    HTML5TextRenderer.prototype.adjustText = function(lines) {
      var c, i, imax, imin, line, newlines, prev, start, str, to, word, words, _i, _j, _k, _len, _len1, _ref3;

      newlines = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        words = line.split(" ");
        line = "";
        for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
          word = words[_j];
          if (word.length > 0) {
            if (line.length > 0) {
              line += " ";
            }
            line += word;
          }
        }
        if (this.measureText(line) > this.maxWidth) {
          words = [];
          prev = 0;
          for (i = _k = 1, _ref3 = line.length; 1 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 1 <= _ref3 ? ++_k : --_k) {
            c = line.charCodeAt(i);
            if (c === 0x20 || c >= 0x80 || prev >= 0x80) {
              words.push(i);
            }
            prev = c;
          }
          words.push(line.length);
          imin = 0;
          imax = words.length - 1;
          while (true) {
            this.index = null;
            this.lineWidth = 0;
            this.fitText(line, words, imin, imin, imax);
            if (this.index === null) {
              break;
            }
            start = imin === 0 ? 0 : words[imin - 1];
            if (line.charCodeAt(start) === 0x20) {
              ++start;
            }
            to = words[this.index];
            str = line.slice(start, to);
            if (this.index === imax) {
              line = str;
              break;
            }
            newlines.push(str);
            start = to + (line.charCodeAt(to) === 0x20 ? 1 : 0);
            str = line.slice(start);
            if (this.measureText(str) <= this.maxWidth) {
              line = str;
              break;
            }
            imin = this.index + 1;
          }
        }
        newlines.push(line);
      }
      return newlines;
    };

    HTML5TextRenderer.prototype.renderText = function(textColor) {
      var c, canvas, context, ctx, h, i, j, len, line, lines, offset, offsetY, property, scale, shadowColor, useStroke, x, y, _i, _j, _k, _ref3, _ref4, _ref5;

      this.textRendered = true;
      context = this.context;
      canvas = this.canvas;
      ctx = this.canvasContext;
      scale = this.lwf.scaleByStage;
      lines = this.adjustText(this.str.split("\n"));
      property = context.textProperty;
      switch (property.align & Align.VERTICAL_MASK) {
        case Align.VERTICAL_BOTTOM:
          len = lines.length;
          h = (this.fontHeight * len + this.leading * (len - 1)) * 96 / 72;
          offsetY = canvas.height - h;
          break;
        case Align.VERTICAL_MIDDLE:
          len = lines.length;
          h = (this.fontHeight * len + this.leading * (len - 1)) * 96 / 72;
          offsetY = (canvas.height - h) / 2;
          break;
        default:
          offsetY = 0;
      }
      offsetY += this.fontHeight * 1.2;
      ctx.clearRect(0, 0, canvas.width + 1, canvas.height + 1);
      ctx.fillStyle = "rgb(" + textColor.red + "," + textColor.green + "," + textColor.blue + ")";
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      useStroke = false;
      if (context.strokeColor != null) {
        ctx.strokeStyle = context.factory.convertRGB(context.strokeColor);
        ctx.lineWidth = property.strokeWidth * scale;
        useStroke = true;
      }
      if (context.shadowColor != null) {
        shadowColor = context.factory.convertRGB(context.shadowColor);
        ctx.shadowOffsetX = property.shadowOffsetX * scale;
        ctx.shadowOffsetY = property.shadowOffsetY * scale;
        ctx.shadowBlur = property.shadowBlur * scale;
      }
      for (i = _i = 0, _ref3 = lines.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        line = lines[i];
        x = this.offsetX * scale;
        if (this.letterSpacing !== 0) {
          switch (this.context.textProperty.align & Align.ALIGN_MASK) {
            case Align.RIGHT:
              x -= this.measureText(line);
              break;
            case Align.CENTER:
              x -= this.measureText(line) / 2;
          }
        }
        y = offsetY + (this.fontHeight + this.leading) * i * 96 / 72;
        if (useStroke) {
          if (context.shadowColor != null) {
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
          }
          if (this.letterSpacing === 0) {
            ctx.strokeText(line, x, y);
          } else {
            offset = 0;
            for (j = _j = 0, _ref4 = line.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; j = 0 <= _ref4 ? ++_j : --_j) {
              c = line[j];
              ctx.strokeText(c, x + offset, y);
              offset += this.canvasContext.measureText(c).width + this.letterSpacing;
            }
          }
        }
        if (context.shadowColor != null) {
          ctx.shadowColor = shadowColor;
        }
        if (this.letterSpacing === 0) {
          ctx.fillText(line, x, y);
        } else {
          offset = 0;
          for (j = _k = 0, _ref5 = line.length; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; j = 0 <= _ref5 ? ++_k : --_k) {
            c = line[j];
            ctx.fillText(c, x + offset, y);
            offset += this.canvasContext.measureText(c).width + this.letterSpacing;
          }
        }
      }
    };

    HTML5TextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var blue, colorChanged, green, red, scaleChanged, str, strChanged;

      m = Utility.scaleMatrix(this.matrixForScale, m, 1 / this.lwf.scaleByStage, 0, 0);
      if (!this.context.factory.textInSubpixel) {
        m.translateX = Math.round(m.translateX);
        m.translateY = Math.round(m.translateY);
      }
      this.matrix = m;
      red = this.color.red;
      green = this.color.green;
      blue = this.color.blue;
      this.context.factory.convertColor(this.color, this.context.textColor, c);
      c = this.color;
      colorChanged = false;
      if (red !== c.red || green !== c.green || blue !== c.blue) {
        colorChanged = true;
      }
      strChanged = false;
      str = this.textObject.parent[this.context.name];
      if (str != null) {
        str = String(str);
      }
      if ((str != null) && str !== this.str) {
        strChanged = true;
        this.str = str;
      }
      scaleChanged = false;
      if (this.scaleByStage !== this.lwf.scaleByStage) {
        scaleChanged = true;
        this.initCanvas();
        this.scaleByStage = this.lwf.scaleByStage;
      }
      if (!this.textRendered || colorChanged || strChanged || scaleChanged) {
        this.renderText(c);
      }
    };

    HTML5TextRenderer.prototype.initCanvas = function() {
      var align, canvas, ctx, leftMargin, lm, property, rightMargin, rm, scale, sw, text;

      scale = this.lwf.scaleByStage;
      property = this.context.textProperty;
      this.leading = property.leading * scale;
      this.fontHeight = property.fontHeight * scale;
      leftMargin = property.leftMargin / this.fontHeight;
      rightMargin = property.rightMargin / this.fontHeight;
      lm = 0;
      rm = 0;
      if (this.context.strokeColor != null) {
        lm = rm = property.strokeWidth / 2 * scale;
      }
      if (this.context.shadowColor != null) {
        sw = (property.shadowBlur - property.shadowOffsetX) * scale;
        if (sw > lm) {
          lm = sw;
        }
        sw = (property.shadowOffsetX + property.shadowBlur) * scale;
        if (sw > rm) {
          rm = sw;
        }
      }
      leftMargin += lm;
      rightMargin += rm;
      text = this.context.text;
      switch (property.align & Align.ALIGN_MASK) {
        case Align.RIGHT:
          align = "right";
          this.offsetX = text.width - rightMargin;
          break;
        case Align.CENTER:
          align = "center";
          this.offsetX = text.width / 2;
          break;
        default:
          align = "left";
          this.offsetX = leftMargin;
      }
      canvas = document.createElement("canvas");
      canvas.width = this.context.text.width * scale;
      canvas.height = this.context.text.height * scale;
      this.maxWidth = canvas.width - (leftMargin + rightMargin);
      ctx = canvas.getContext("2d");
      ctx.font = "" + this.fontHeight + "px " + this.context.fontName;
      ctx.textAlign = align;
      ctx.textBaseline = "bottom";
      this.canvas = canvas;
      this.canvasContext = ctx;
      return this.letterSpacing = ctx.measureText('M').width * this.context.letterSpacing;
    };

    return HTML5TextRenderer;

  })();

  WebGLTextContext = (function(_super) {
    __extends(WebGLTextContext, _super);

    function WebGLTextContext(factory, data, text) {
      var dh, dw, gl, h, th, triangles, tw, u, u0, u1, uv, v, v0, v1, vertices, w, x, x0, x1, y, y0, y1;

      this.factory = factory;
      this.data = data;
      this.text = text;
      WebGLTextContext.__super__.constructor.apply(this, arguments);
      gl = this.factory.stageContext;
      tw = this.text.width;
      th = this.text.height;
      x = 0;
      y = 0;
      u = 0;
      v = 0;
      w = tw;
      h = th;
      x0 = x;
      y0 = y;
      x1 = x + w;
      y1 = y + h;
      vertices = new Float32Array([x1, y1, 0, x1, y0, 0, x0, y1, 0, x0, y0, 0]);
      this.verticesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      dw = 2.0 * tw;
      dh = 2.0 * th;
      u0 = (2 * u + 1) / dw;
      v0 = (2 * v + 1) / dh;
      u1 = u0 + (w * 2 - 2) / dw;
      v1 = v0 + (h * 2 - 1) / dh;
      uv = new Float32Array([u1, v1, u1, v0, u0, v1, u0, v0]);
      this.uvBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
      triangles = new Uint16Array([0, 1, 2, 2, 1, 3]);
      this.trianglesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.trianglesBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, triangles, gl.STATIC_DRAW);
    }

    WebGLTextContext.prototype.destruct = function() {
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.deleteBuffer(this.verticesBuffer);
      gl.deleteBuffer(this.uvBuffer);
      gl.deleteBuffer(this.trianglesBuffer);
    };

    return WebGLTextContext;

  })(HTML5TextContext);

  WebGLTextRenderer = (function(_super) {
    __extends(WebGLTextRenderer, _super);

    function WebGLTextRenderer(lwf, context, textObject) {
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      WebGLTextRenderer.__super__.constructor.apply(this, arguments);
      this.glMatrix = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.glColor = new Float32Array([0, 0, 0, 0]);
    }

    WebGLTextRenderer.prototype.destruct = function() {
      var gl;

      gl = this.context.factory.stageContext;
      if (this.texture) {
        gl.deleteTexture(this.texture);
      }
    };

    WebGLTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var factory;

      this.renderingCount = renderingCount;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      WebGLTextRenderer.__super__.render.apply(this, arguments);
      factory = this.context.factory;
      factory.addCommand(renderingIndex, {
        renderer: this,
        matrix: m,
        colorTransform: c,
        blendMode: factory.blendMode,
        maskMode: factory.maskMode
      });
    };

    WebGLTextRenderer.prototype.renderCommand = function(m, c, renderingIndex, blendMode) {
      var factory, gc, gl, gm, src, textInSubpixel;

      factory = this.context.factory;
      gl = factory.stageContext;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.context.verticesBuffer);
      gl.vertexAttribPointer(factory.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.context.uvBuffer);
      gl.vertexAttribPointer(factory.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
      textInSubpixel = factory.textInSubpixel;
      gm = this.glMatrix;
      gm[0] = m.scaleX;
      gm[1] = m.skew1;
      gm[4] = m.skew0;
      gm[5] = m.scaleY;
      gm[12] = textInSubpixel ? m.translateX : Math.round(m.translateX);
      gm[13] = textInSubpixel ? m.translateY : Math.round(m.translateY);
      gm[14] = factory.farZ + renderingIndex;
      gl.uniformMatrix4fv(factory.uMatrix, false, gm);
      gc = this.glColor;
      src = gl.SRC_ALPHA;
      gc[0] = c.multi.red;
      gc[1] = c.multi.green;
      gc[2] = c.multi.blue;
      gc[3] = c.multi.alpha;
      gl.blendFunc(src, blendMode === "add" ? gl.ONE : gl.ONE_MINUS_SRC_ALPHA);
      gl.uniform4fv(factory.uColor, gc);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.uniform1i(factory.uTexture, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.context.trianglesBuffer);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    };

    WebGLTextRenderer.prototype.renderText = function(textColor) {
      var gl;

      WebGLTextRenderer.__super__.renderText.apply(this, arguments);
      gl = this.context.factory.stageContext;
      if (this.texture) {
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.deleteTexture(this.texture);
      }
      this.texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    };

    return WebGLTextRenderer;

  })(HTML5TextRenderer);

  if (typeof global !== "undefined") {
    global["LWF"]["WebGLRendererFactory"] = WebGLRendererFactory;
    global["LWF"]["WebGLResourceCache"] = WebGLResourceCache;
    global["LWF"]["useWebGLRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = WebGLResourceCache;
    };
  }

  WebGLRendererFactory.prototype["convertColor"] = WebGLRendererFactory.prototype.convertColor;

  WebGLRendererFactory.prototype["fitForHeight"] = WebGLRendererFactory.prototype.fitForHeight;

  WebGLRendererFactory.prototype["fitForWidth"] = WebGLRendererFactory.prototype.fitForWidth;

  WebGLRendererFactory.prototype["scaleForHeight"] = WebGLRendererFactory.prototype.scaleForHeight;

  WebGLRendererFactory.prototype["scaleForWidth"] = WebGLRendererFactory.prototype.scaleForWidth;

  WebGLRendererFactory.prototype["setBackgroundColor"] = WebGLRendererFactory.prototype.setBackgroundColor;

  WebGLResourceCache.prototype["clear"] = WebGLResourceCache.prototype.clear;

  WebGLResourceCache.prototype["getCache"] = WebGLResourceCache.prototype.getCache;

  WebGLResourceCache.prototype["loadLWF"] = WebGLResourceCache.prototype.loadLWF;

  WebGLResourceCache.prototype["loadLWFs"] = WebGLResourceCache.prototype.loadLWFs;

  WebGLResourceCache.prototype["unloadLWF"] = WebGLResourceCache.prototype.unloadLWF;

  WebGLResourceCache.prototype["setParticleConstructor"] = WebGLResourceCache.prototype.setParticleConstructor;

  WebGLResourceCache.prototype["setDOMElementConstructor"] = WebGLResourceCache.prototype.setDOMElementConstructor;

}).call(this);
/**
 * @author sole / http://soledadpenades.com
 * @author mrdoob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 * @author endel / http://endel.me
 * @author GREE, Inc.
 *
 * The MIT License
 *
 * Copyright (c) 2010-2012 Tween.js authors.
 * Copyright (c) 2012 GREE, Inc.
 *
 * Easing equations
 *   Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function() {

var TWEENLWF = {};

TWEENLWF.REVISION = '10';

TWEENLWF.Tween = function ( movie ) {

	this.lwf = movie.lwf;
	this.object = movie;
	this.valuesStart = {};
	this.valuesEnd = {};
	this.valuesStartRepeat = {};
	this.duration = 0;
	this.repeat = 0;
	this.delayTime = 0;
	this.startTime = null;
	this.easingFunction = TWEENLWF.Easing.Linear.None;
	this.interpolationFunction = TWEENLWF.Interpolation.Linear;
	this.chainedTweens = [];
	this.onStartCallback = null;
	this.onStartCallbackFired = false;
	this.onUpdateCallback = null;
	this.onCompleteCallback = null;

	if ( this.lwf._tweens === null ) {

		this.lwf._tweens = [];

		if ( this.lwf._tweenMode === "lwf" ) {

			this.lwf.addExecHandler( TWEENLWF._tweenExecHandler );

		} else {

			this.lwf.addMovieEventHandler( "_root", {

				"enterFrame": TWEENLWF._tweenMovieHandler

			});

		}

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			this.duration = duration * this.lwf.tick;

		}

		this.valuesEnd = properties;

		return this;

	};

	this.start = function () {

		this.lwf._tweens.push( this );

		this.onStartCallbackFired = false;

		this.startTime = this.lwf.time;
		this.startTime += this.delayTime;

		for ( var property in this.valuesEnd ) {

			// This prevents the engine from interpolating null values
			if ( this.object[ property ] === null ) {

				continue;

			}

			// check if an Array was provided as property value
			if ( this.valuesEnd[ property ] instanceof Array ) {

				if ( this.valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				this.valuesEnd[ property ] = [ this.object[ property ] ].concat( this.valuesEnd[ property ] );

			}

			this.valuesStart[ property ] = this.object[ property ];

			if( ( this.valuesStart[ property ] instanceof Array ) === false ) {
				this.valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
			}

			this.valuesStartRepeat[ property ] = this.valuesStart[ property ] || 0;

		}

		return this;

	};

	this.stop = function () {

		var i = this.lwf._tweens.indexOf( this );

		if ( i !== -1 ) {

			this.lwf._tweens.splice( i, 1 );

			if ( this.lwf._tweens.length == 0 ) {

				this.lwf.stopTweens();

			}

		}

		return this;

	};

	this.delay = function ( amount ) {

		this.delayTime = amount * this.lwf.tick;
		return this;

	};

	this.repeat = function ( times ) {

		this.repeat = times;
		return this;

	};

	this.easing = function ( easing ) {

		this.easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		this.interpolationFunction = interpolation;
		return this;

	};

	this.chain = function ( chainedTween ) {

		if ( typeof chainedTween !== "undefined" && chainedTween !== null ) {

			this.chainedTweens.push( chainedTween );
			return this;

		} else {

			chainedTween = new TWEENLWF.Tween( this.object );
			this.chainedTweens.push( chainedTween );
			return chainedTween;

		}

	};

	this.onStart = function ( callback ) {

		this.onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		this.onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		this.onCompleteCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		if ( time < this.startTime ) {

			return true;

		}

		if ( this.object[ "property" ] === null ) {

			return false;

		}

		if ( this.onStartCallbackFired === false ) {

			if ( this.onStartCallback !== null ) {

				this.onStartCallback.call( this.object );

			}

			this.onStartCallbackFired = true;

		}

		var duration = this.duration <= 0 ? this.lwf.tick : this.duration;

		var elapsed = ( time - this.startTime ) / duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = this.easingFunction( elapsed );

		for ( var property in this.valuesEnd ) {

			var start = this.valuesStart[ property ] || 0;
			var end = this.valuesEnd[ property ];

			if ( end instanceof Array ) {

				this.object[ property ] = this.interpolationFunction( end, value );

			} else {

				if ( typeof(end) === "string" ) {
					end = start + parseFloat(end, 10);
				}

				this.object[ property ] = start + ( end - start ) * value;

			}

		}

		if ( this.onUpdateCallback !== null ) {

			this.onUpdateCallback.call( this.object, value );

		}

		if ( elapsed == 1 ) {

			if ( this.repeat > 0 ) {

				if( isFinite( this.repeat ) ) {
					this.repeat--;
				}

				// reassign starting values, restart by making startTime = now
				for( var property in this.valuesStartRepeat ) {

					if ( typeof( this.valuesEnd[ property ] ) === "string" ) {
						this.valuesStartRepeat[ property ] = this.valuesStartRepeat[ property ] + parseFloat(this.valuesEnd[ property ], 10);
					}

					this.valuesStart[ property ] = this.valuesStartRepeat[ property ];

				}

				this.startTime = time + this.delayTime;

				return true;

			} else {

				if ( this.onCompleteCallback !== null ) {

					this.onCompleteCallback.call( this.object );

				}

				for ( var i = 0, l = this.chainedTweens.length; i < l; i ++ ) {

					this.chainedTweens[ i ].start( time );

				}

				return false;

			}

		}

		return true;

	};

	this[ "to" ] = this.to;
	this[ "start" ] = this.start;
	this[ "stop" ] = this.stop;
	this[ "delay" ] = this.delay;
	this[ "easing" ] = this.easing;
	this[ "interpolation" ] = this.interpolation;
	this[ "chain" ] = this.chain;
	this[ "onStart" ] = this.onStart;
	this[ "onUpdate" ] = this.onUpdate;
	this[ "onComplete" ] = this.onComplete;
	this[ "update" ] = this.update;

};

TWEENLWF.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEENLWF.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEENLWF.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEENLWF.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEENLWF.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEENLWF.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEENLWF.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

var lwfPrototype = global[ "LWF" ][ "LWF" ].prototype;

lwfPrototype[ "setTweenMode" ] = function( mode ) {

	this._tweenMode = mode;

};

lwfPrototype.stopTweens = function() {

	if ( this._tweens !== null ) {

		this._tweens = null;

		this.removeExecHandler( TWEENLWF._tweenExecHandler );
		this.removeMovieEventHandler( "_root", {
			
			"enterFrame": TWEENLWF._tweenMovieHandler

		});

	}

};

lwfPrototype[ "stopTweens" ] = lwfPrototype.stopTweens;

TWEENLWF._tweenUpdater = function() {

	if ( this._tweens === null )
		return;

	var i = 0;
	var num_tweens = this._tweens.length;
	var time = this.time;

	while ( i < num_tweens ) {

		if ( this._tweens[ i ].update( time ) ) {

			i ++;

		} else {

			this._tweens.splice( i, 1 );
			num_tweens --;

		}

	}

	if ( this._tweens.length == 0 ) {

		this.stopTweens();

	}

};

TWEENLWF._tweenExecHandler = function() {

	TWEENLWF._tweenUpdater.call( this );

};

TWEENLWF._tweenMovieHandler = function() {

	TWEENLWF._tweenUpdater.call( this.lwf );

};

var moviePrototype = global[ "LWF" ][ "Movie" ].prototype;

moviePrototype[ "addTween" ] = function() {

	var tween = new TWEENLWF.Tween( this );

	return tween;

};

moviePrototype[ "stopTweens" ] = function() {

	if ( typeof this.lwf === "undefined" || this.lwf === null ||
			this.lwf._tweens === null ) {

		return this;

	}

	var tweens = this.lwf._tweens;

	var i = 0;
	var num_tweens = tweens.length;

	while ( i < num_tweens ) {

		if ( tweens[ i ].object === this ) {

			tweens.splice( i, 1 );
			num_tweens --;

		} else {

			i ++;

		}

	}

	if ( tweens.length == 0 ) {

		this.lwf.stopTweens();

	}

	return this;

};

global[ "LWF" ][ "Tween" ] = TWEENLWF.Tween;
global[ "LWF" ][ "Tween" ][ "Easing" ] = TWEENLWF.Easing;
var e = global[ "LWF" ][ "Tween" ][ "Easing" ];
e[ "Linear" ] = TWEENLWF.Easing.Linear;
e[ "Linear" ][ "None" ] = TWEENLWF.Easing.Linear.None;
e[ "Quadratic" ] = TWEENLWF.Easing.Quadratic;
e[ "Quadratic" ][ "In" ] = TWEENLWF.Easing.Quadratic.In;
e[ "Quadratic" ][ "Out" ] = TWEENLWF.Easing.Quadratic.Out;
e[ "Quadratic" ][ "InOut" ] = TWEENLWF.Easing.Quadratic.InOut;
e[ "Cubic" ] = TWEENLWF.Easing.Cubic;
e[ "Cubic" ][ "In" ] = TWEENLWF.Easing.Cubic.In;
e[ "Cubic" ][ "Out" ] = TWEENLWF.Easing.Cubic.Out;
e[ "Cubic" ][ "InOut" ] = TWEENLWF.Easing.Cubic.InOut;
e[ "Quartic" ] = TWEENLWF.Easing.Quartic;
e[ "Quartic" ][ "In" ] = TWEENLWF.Easing.Quartic.In;
e[ "Quartic" ][ "Out" ] = TWEENLWF.Easing.Quartic.Out;
e[ "Quartic" ][ "InOut" ] = TWEENLWF.Easing.Quartic.InOut;
e[ "Quintic" ] = TWEENLWF.Easing.Quintic;
e[ "Quintic" ][ "In" ] = TWEENLWF.Easing.Quintic.In;
e[ "Quintic" ][ "Out" ] = TWEENLWF.Easing.Quintic.Out;
e[ "Quintic" ][ "InOut" ] = TWEENLWF.Easing.Quintic.InOut;
e[ "Sinusoidal" ] = TWEENLWF.Easing.Sinusoidal;
e[ "Sinusoidal" ][ "In" ] = TWEENLWF.Easing.Sinusoidal.In;
e[ "Sinusoidal" ][ "Out" ] = TWEENLWF.Easing.Sinusoidal.Out;
e[ "Sinusoidal" ][ "InOut" ] = TWEENLWF.Easing.Sinusoidal.InOut;
e[ "Exponential" ] = TWEENLWF.Easing.Exponential;
e[ "Exponential" ][ "In" ] = TWEENLWF.Easing.Exponential.In;
e[ "Exponential" ][ "Out" ] = TWEENLWF.Easing.Exponential.Out;
e[ "Exponential" ][ "InOut" ] = TWEENLWF.Easing.Exponential.InOut;
e[ "Circular" ] = TWEENLWF.Easing.Circular;
e[ "Circular" ][ "In" ] = TWEENLWF.Easing.Circular.In;
e[ "Circular" ][ "Out" ] = TWEENLWF.Easing.Circular.Out;
e[ "Circular" ][ "InOut" ] = TWEENLWF.Easing.Circular.InOut;
e[ "Elastic" ] = TWEENLWF.Easing.Elastic;
e[ "Elastic" ][ "In" ] = TWEENLWF.Easing.Elastic.In;
e[ "Elastic" ][ "Out" ] = TWEENLWF.Easing.Elastic.Out;
e[ "Elastic" ][ "InOut" ] = TWEENLWF.Easing.Elastic.InOut;
e[ "Back" ] = TWEENLWF.Easing.Back;
e[ "Back" ][ "In" ] = TWEENLWF.Easing.Back.In;
e[ "Back" ][ "Out" ] = TWEENLWF.Easing.Back.Out;
e[ "Back" ][ "InOut" ] = TWEENLWF.Easing.Back.InOut;
e[ "Bounce" ] = TWEENLWF.Easing.Bounce;
e[ "Bounce" ][ "In" ] = TWEENLWF.Easing.Bounce.In;
e[ "Bounce" ][ "Out" ] = TWEENLWF.Easing.Bounce.Out;
e[ "Bounce" ][ "InOut" ] = TWEENLWF.Easing.Bounce.InOut;

global[ "LWF" ][ "Tween" ][ "Interpolation" ] = TWEENLWF.Interpolation;
var i = global[ "LWF" ][ "Tween" ][ "Interpolation" ];
i[ "Linear" ] = TWEENLWF.Interpolation.Linear;
i[ "Bezier" ] = TWEENLWF.Interpolation.Bezier;
i[ "CatmullRom" ] = TWEENLWF.Interpolation.CatmullRom;
i[ "Utils" ] = TWEENLWF.Interpolation.Utils;
i[ "Utils" ][ "Linear" ] = TWEENLWF.Interpolation.Utils.Linear;
i[ "Utils" ][ "Bernstein" ] = TWEENLWF.Interpolation.Utils.Bernstein;
i[ "Utils" ][ "Factorial" ] = TWEENLWF.Interpolation.Utils.Factorial;
i[ "Utils" ][ "CatmullRom" ] = TWEENLWF.Interpolation.Utils.CatmullRom;

}).call(this);
(function() {

var Base64 = {};

/**
 * @const
 * @type {string}
 */
Base64.Character =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

/**
 * @const
 * @type {string}
 */
Base64.RangeError = "INVALID_CHARACTER_ERR";

Base64.btoaArray = {};

/**
 * @const
 * @type {(Uint8Array|Array.<number>)}
 */
Base64.btoaArray.CharacterTable = (
/**
 * @param {string} chars
 * @return {(Uint8Array|Array.<number>)}
 */
function(chars) {
  /** @type {(Uint8Array|Array.<number>)} */
  var array =
    new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(chars.length);
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = array.length; i < il; ++i) {
    array[i] = chars.charCodeAt(i);
  }

  return array;
})(Base64.Character);

/**
 * @param {string} str base64 encoded string.
 * @return {Array.<number>|Uint8Array} decoded byte-array.
 */
Base64.atobArray = function(str) {
  /** @type {number} */
  var buffer = 0;
  /** @type {number} */
  var pos = 0;
  /** @type {number} */
  var length = str.length;
  /** @type {(Uint8Array|Array.<number>)} */
  var out;
  /** @type {number} */
  var outpos = 0;
  /** @type {number} */
  var bitlen = 0;
  /** @type {Array.<number>|Int16Array} */
  var decode = Base64.atobArray.DecodeTable;
  /** @type {number} */
  var decoded;
  /** @type {number} */
  var tmp;
  /** @type {number} */
  var mod;

  // remove padding
  while (str.charAt(length-1) === '=') {
    --length;
  }
  mod = length % 4;

  // create output buffer
  out = new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(
    ((length + 3) / 4 | 0) * 3 - [0, 0, 2, 1][mod]
  );

  // check range
  if (length % 4 === 1 || (str.length > 0 && length === 0)) {
    throw new Error(Base64.RangeError);
  }

  while (pos < length) {
    tmp = str.charCodeAt(pos++);
    decoded = tmp < 256 ? decode[tmp] : -1;

    // check character range
    if (decoded === -1) {
      throw new Error(Base64.RangeError);
    }

    // add buffer (6bit)
    buffer = (buffer << 6) + decoded;
    bitlen += 6;

    // decode byte
    if (bitlen >= 8) {
      bitlen -= 8;

      // extract byte
      tmp = buffer >> bitlen;

      // decode character
      out[outpos++] = tmp;

      // remove character bits
      buffer ^= tmp << bitlen;
    }
  }

  return out;
};

/**
 * @const
 * @type {(Array.<number>|Int16Array)}
 */
Base64.atobArray.DecodeTable = (
/**
 * @param {Uint8Array|Array.<number>} encodeTable character table.
 * @return {Int16Array|Array.<number>} decode table.
 */
function(encodeTable) {
  /** @type {(Int16Array|Array.<number>)} */
  var table = new (typeof Int16Array !== 'undefined' ? Int16Array : Array)(256);
  /** @type {number} */
  var i;
  /** @type {Array.<number>} */
  var array = encodeTable instanceof Array ?
    encodeTable : Array.prototype.slice.call(encodeTable);

  for (i = 0; i < 0xff; ++i) {
    table[i] = array.indexOf(i);
  }

  return table;
})(Base64.btoaArray.CharacterTable);

global["LWF"].Base64 = Base64;

}).call(this);
(function() {

var Zlib = {};

var USE_TYPEDARRAY = false;

if (typeof Uint8Array !== 'undefined' &&
		typeof Uint16Array !== 'undefined' &&
		typeof Uint32Array !== 'undefined') {
	USE_TYPEDARRAY = true;
}

/**
 * zlib.js
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
 * されている. これは Inflate との共存を考慮している為.
 */


/**
 * Compression Method
 * @enum {number}
 */
Zlib.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};


/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * zlib.adler32.js
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Adler32 checksum 実装.
 */



/**
 * Adler32 ハッシュ値の作成
 * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32 = function(array) {
  if (typeof(array) === 'string') {
    array = Zlib.Util.stringToByteArray(array);
  }
  return Zlib.Adler32.update(1, array);
};

/**
 * Adler32 ハッシュ値の更新
 * @param {number} adler 現在のハッシュ値.
 * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32.update = function(adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib.Adler32.OptimizationParameter ?
      Zlib.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
 * Adler32 最適化パラメータ
 * 現状では 1024 程度が最適.
 * @see http://jsperf.com/adler-32-simple-vs-optimized/3
 * @const
 * @type {number}
 */
Zlib.Adler32.OptimizationParameter = 1024;


/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

Zlib.Huffman = {};

/**
 * build huffman table from length list.
 * @param {!(Array.<number>|Uint8Array)} lengths length list.
 * @return {!Array} huffman table.
 */
Zlib.Huffman.buildHuffmanTable = function(lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limit. */
  var jl;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        for (j = reversed; j < size; j += skip) {
          table[j] = (bitLength << 16) | i;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};



/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
 * @constructor
 * @param {!(Uint8Array|Array.<number>)} input input buffer.
 * @param {Object} opt_params option parameter.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
 *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
 */
Zlib.RawInflate = function(input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array.<(Array.<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;
  /** @type {!(Uint8Array|Array.<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      this.op = Zlib.RawInflate.MaxBackwardLength;
      this.output =
        new (USE_TYPEDARRAY ? Uint8Array : Array)(
          Zlib.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib.RawInflate.MaxCopyLength
        );
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
      this.expandBuffer = this.expandBufferAdaptive;
      this.concatBuffer = this.concatBufferDynamic;
      this.decodeHuffman = this.decodeHuffmanAdaptive;
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
 * @enum {number}
 */
Zlib.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
 * decompress.
 * @return {!(Uint8Array|Array.<number>)} inflated buffer.
 */
Zlib.RawInflate.prototype.decompress = function() {
  while (!this.bfinal) {
    this.parseBlock();
  }

  return this.concatBuffer();
};

/**
 * @const
 * @type {number} max backward length for LZ77.
 */
Zlib.RawInflate.MaxBackwardLength = 32768;

/**
 * @const
 * @type {number} max copy length for LZ77.
 */
Zlib.RawInflate.MaxCopyLength = 258;

/**
 * huffman order
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.Order = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
 * huffman length code table.
 * @const
 * @type {!(Array.<number>|Uint16Array)}
 */
Zlib.RawInflate.LengthCodeTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
 * huffman length extra-bits table.
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.LengthExtraTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
 * huffman dist code table.
 * @const
 * @type {!(Array.<number>|Uint16Array)}
 */
Zlib.RawInflate.DistCodeTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
 * huffman dist extra-bits table.
 * @const
 * @type {!(Array.<number>|Uint8Array)}
 */
Zlib.RawInflate.DistExtraTable = (function(table) {
  return USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
 * fixed huffman length code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedLiteralLengthTable = (function(table) {
  return table;
})((function() {
  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
      (i <= 255) ? 9 :
      (i <= 279) ? 7 :
      8;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * fixed huffman distance code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedDistanceTable = (function(table) {
  return table;
})((function() {
  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * parse deflated block.
 */
Zlib.RawInflate.prototype.parseBlock = function() {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
 * read inflate bits
 * @param {number} length bits length.
 * @return {number} read bits.
 */
Zlib.RawInflate.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    octet = input[ip++];
    if (octet === void 0) {
      throw new Error('input buffer is broken');
    }

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
 * read huffman code using table
 * @param {Array} table huffman code table.
 * @return {number} huffman code.
 */
Zlib.RawInflate.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array.<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    octet = input[ip++];
    if (octet === void 0) {
      throw new Error('input buffer is broken');
    }
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
 * parse uncompressed block.
 */
Zlib.RawInflate.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} input byte. */
  var octet;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len (1st)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: LEN (first byte)');
  }
  len = octet;

  // len (2nd)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: LEN (second byte)');
  }
  len |= octet << 8;

  // nlen (1st)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: NLEN (first byte)');
  }
  nlen = octet;

  // nlen (2nd)
  octet = input[ip++];
  if (octet === void 0) {
    throw new Error('invalid uncompressed block header: NLEN (second byte)');
  }
  nlen |= octet << 8;

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        if (USE_TYPEDARRAY) {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        } else {
          while (preCopy--) {
            output[op++] = input[ip++];
          }
        }
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBuffer({fixRatio: 2});
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  if (USE_TYPEDARRAY) {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  } else {
    while (len--) {
      output[op++] = input[ip++];
    }
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
 * parse fixed huffman block.
 */
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {
  this.decodeHuffman(
    Zlib.RawInflate.FixedLiteralLengthTable,
    Zlib.RawInflate.FixedDistanceTable
  );
};

/**
 * parse dynamic huffman block.
 */
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array.<number>)} code lengths. */
  var codeLengths =
    new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array.<number>)} literal and length code lengths. */
  var litlenLengths;
  /** @type {!(Uint8Array|Array.<number>)} distance code lengths. */
  var distLengths;
  /** @type {number} loop counter. */
  var i;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
  }
  codeLengthsTable = buildHuffmanTable(codeLengths);

  /**
   * decode function
   * @param {number} num number of lengths.
   * @param {!Array} table code lengths table.
   * @param {!(Uint8Array|Array.<number>)} lengths code lengths buffer.
   * @return {!(Uint8Array|Array.<number>)} code lengths buffer.
   */
  function decode(num, table, lengths) {
    /** @type {number} */
    var code;
    /** @type {number} */
    var prev;
    /** @type {number} */
    var repeat;
    /** @type {number} */
    var i;

    for (i = 0; i < num;) {
      code = this.readCodeByTable(table);
      switch (code) {
        case 16:
          repeat = 3 + this.readBits(2);
          while (repeat--) { lengths[i++] = prev; }
          break;
        case 17:
          repeat = 3 + this.readBits(3);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        case 18:
          repeat = 11 + this.readBits(7);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        default:
          lengths[i++] = code;
          prev = code;
          break;
      }
    }

    return lengths;
  }

  // literal and length code
  litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);

  // distance code
  distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);

  //return;
  this.decodeHuffman(
    buildHuffmanTable(decode.call(this, hlit, codeLengthsTable, litlenLengths)),
    buildHuffmanTable(decode.call(this, hdist, codeLengthsTable, distLengths))
  );
};

/**
 * decode huffman code
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffman = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBuffer();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * decode huffman code (adaptive)
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBuffer();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * expand output buffer.
 * @param {Object=} opt_param option parameters.
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.expandBuffer = function(opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer =
    new (USE_TYPEDARRAY ? Uint8Array : Array)(
        this.op - Zlib.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
  /** @type {number} copy index. */
  var i;
  /** @type {number} copy limit */
  var il;

  var output = this.output;

  // copy to output buffer
  if (USE_TYPEDARRAY) {
    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
  } else {
    for (i = 0, il = buffer.length; i < il; ++i) {
      buffer[i] = output[i + Zlib.RawInflate.MaxBackwardLength];
    }
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  if (USE_TYPEDARRAY) {
    output.set(
      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)
    );
  } else {
    for (i = 0; i < Zlib.RawInflate.MaxBackwardLength; ++i) {
      output[i] = output[backward + i];
    }
  }

  this.op = Zlib.RawInflate.MaxBackwardLength;

  return output;
};

/**
 * expand output buffer. (adaptive)
 * @param {Object=} opt_param option parameters.
 * @return {!(Array.<number>|Uint8Array)} output buffer pointer.
 */
Zlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {
  /** @type {!(Array.<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  if (USE_TYPEDARRAY) {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  } else {
    buffer = output;
  }

  this.output = buffer;

  return this.output;
};

/**
 * concat output buffer.
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBuffer = function() {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array.<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return USE_TYPEDARRAY ?
      this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) :
      this.output.slice(Zlib.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
 * concat output buffer. (dynamic)
 * @return {!(Array.<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBufferDynamic = function() {
  /** @type {Array.<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  if (USE_TYPEDARRAY) {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  } else {
    if (this.output.length > op) {
      this.output.length = op;
    }
    buffer = this.output;
  }

  this.buffer = buffer;

  return this.buffer;
};




/* vim:set expandtab ts=2 sw=2 tw=80: */
/**
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @constructor
 * @param {!(Uint8Array|Array)} input deflated buffer.
 * @param {Object=} opt_params option parameters.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
 *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
 *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
 */
Zlib.Inflate = function(input, opt_params) {
  /** @type {number} */
  var bufferSize;
  /** @type {Zlib.Inflate.BufferType} */
  var bufferType;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
}

/**
 * @enum {number}
 */
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;

/**
 * decompress.
 * @return {!(Uint8Array|Array)} inflated buffer.
 */
Zlib.Inflate.prototype.decompress = function() {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};




/* vim:set expandtab ts=2 sw=2 tw=80: */

	global["LWF"].Zlib = Zlib;

}).call(this);
